<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="noodp" />
    <title class="pjax-title">C&#43;&#43;函数 - Dling</title><meta name="Description" content="Dling | 煜江的个人博客"><meta property="og:title" content="C&#43;&#43;函数" />
<meta property="og:description" content="函数声明函数声明负责指定函数的名字、返回值的类型以及调用该函数所需的参数数量和类型： 1 2 3 Elem* next_elem(); //无须参数，返回Elem* void exit(int); //int类型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" /><meta property="og:image" content="http://example.org/logo.jpg"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-09T15:53:25+08:00" />
<meta property="article:modified_time" content="2022-11-09T15:53:25+08:00" /><meta property="og:site_name" content="Dling | 煜江的个人博客" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="http://example.org/logo.jpg"/>

<meta name="twitter:title" content="C&#43;&#43;函数"/>
<meta name="twitter:description" content="函数声明函数声明负责指定函数的名字、返回值的类型以及调用该函数所需的参数数量和类型： 1 2 3 Elem* next_elem(); //无须参数，返回Elem* void exit(int); //int类型"/>
<meta name="application-name" content="Dling">
<meta name="apple-mobile-web-app-title" content="Dling">

<meta name="theme-color" content="#f8f8f8"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" /><link rel="prev" href="http://example.org/2022/c-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.1d6e6517c44074bf1c692657d249d106a5e98bb9db25f7773715b24eda7aa575354611c095c23092aa17916f1b5be527.css" integrity="sha384-HW5lF8RAdL8caSZX0knRBqXpi7nbJfd3NxWyTtp6pXU1RhHAlcIwkqoXkW8bW&#43;Un"><link rel="stylesheet" href="/css/style.min.8540842213936bd2a523af7a572a979f0061839c28d9f3f25e5edb76d34b76136170ccd1a71501f0ecc51daadc867cb2.css" integrity="sha384-hUCEIhOTa9KlI696VyqXnwBhg5wo2fPyXl7bdtNLdhNhcMzRpxUB8OzFHarchnyy"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t">
        <noscript><link rel="stylesheet" href="/lib/fontawesome-free/all.min.2cba216129d7b04299cad0e4a8bb0eb317de61d6e2489778de53950bfcb59fa58d01a258c9e2675ffa3c07c058996f2d.css" integrity="sha384-LLohYSnXsEKZytDkqLsOsxfeYdbiSJd43lOVC/y1n6WNAaJYyeJnX/o8B8BYmW8t"></noscript><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC">
        <noscript><link rel="stylesheet" href="/lib/animate/animate.min.1aedca555d87f5dfb2038403a5507b55c3b284994056b717774b61123af82b39df6853cb7b4c50272a2757138d6b8642.css" integrity="sha384-Gu3KVV2H9d&#43;yA4QDpVB7VcOyhJlAVrcXd0thEjr4KznfaFPLe0xQJyonVxONa4ZC"></noscript>
    
    
    
    <script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "C++函数",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/example.org\/2022\/c-%E5%87%BD%E6%95%B0\/"
        },"image": ["http:\/\/example.org\/images\/screenshot.png"],"genre": "posts","keywords": "常量表达式, 函数指针, 函数重载","wordcount":  7186 ,
        "url": "http:\/\/example.org\/2022\/c-%E5%87%BD%E6%95%B0\/","datePublished": "2022-11-09T15:53:25+08:00","dateModified": "2022-11-09T15:53:25+08:00","license": "This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher": {
            "@type": "Organization",
            "name": "煜江叔叔","logo": "http:\/\/example.org\/avatar.jpg"},"author": {
                "@type": "Person",
                "name": "煜江叔叔"
            },"description": ""
    }
    </script></head>

<body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">
        function setTheme(theme) {document.body.setAttribute('theme', theme);}
        function saveTheme(theme) {window.localStorage && localStorage.setItem('theme', theme);}
        function getMeta(metaName) {const metas = document.getElementsByTagName('meta'); for (let i = 0; i < metas.length; i++) if (metas[i].getAttribute('name') === metaName) return metas[i]; return '';}
        if (window.localStorage && localStorage.getItem('theme')) {let theme = localStorage.getItem('theme');theme === 'light' || theme === 'dark' || theme === 'black' ? setTheme(theme) : (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light')); } else { if ('light' === 'light' || 'light' === 'dark' || 'light' === 'black') setTheme('light'), saveTheme('light'); else saveTheme('auto'), window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? setTheme('dark') : setTheme('light');}
        let metaColors = {'light': '#f8f8f8','dark': '#252627','black': '#000000'}
        getMeta('theme-color').content = metaColors[document.body.getAttribute('theme')];
    </script>
    <div id="back-to-top"></div>
    <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="Dling"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>Dling</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"><i class="fa fa-archive faa-wrench"></i> 归档 </a><a class="menu-item" href="/tags/"><i class="fa fa-tag faa-wrench"></i> 标签 </a><a class="menu-item" href="/categories/"><i class="fa fa-folder-open faa-wrench"></i> 分类 </a><a class="menu-item" href="/series/"><i class="fas fa-object-group"></i> 系列 </a><a class="menu-item" href="/about/"><i class="fa fa-info-circle faa-wrench"></i> 关于 </a><a class="menu-item" href="/link/"><i class="fas fa-link"></i> 友链 </a><a class="menu-item" href="https://github.com/Treamn" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i>  </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a></div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="Dling"><span class="header-title-pre"><i class="fas fa-terminal"></i></span>Dling</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="#" onclick="return false;" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="#" onclick="return false;" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="#" onclick="return false;" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title=""><i class="fa fa-archive faa-wrench"></i>归档</a><a class="menu-item" href="/tags/" title=""><i class="fa fa-tag faa-wrench"></i>标签</a><a class="menu-item" href="/categories/" title=""><i class="fa fa-folder-open faa-wrench"></i>分类</a><a class="menu-item" href="/series/" title=""><i class="fas fa-object-group"></i>系列</a><a class="menu-item" href="/about/" title=""><i class="fa fa-info-circle faa-wrench"></i>关于</a><a class="menu-item" href="/link/" title=""><i class="fas fa-link"></i>友链</a><a class="menu-item" href="https://github.com/Treamn" title="GitHub" rel="noopener noreffer" target="_blank"><i class='fab fa-github fa-fw'></i></a><a href="#" onclick="return false;" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
            <div class="container"><div class="toc" id="toc-auto">
        <h2 class="toc-title">目录</h2>
        <div class="toc-content" id="toc-content-auto"><nav id="TableOfContents">
  <ul>
    <li><a href="#函数声明">函数声明</a>
      <ul>
        <li><a href="#函数声明的组成要件">函数声明的组成要件</a></li>
        <li><a href="#函数定义">函数定义</a></li>
        <li><a href="#返回值">返回值</a></li>
        <li><a href="#inline函数">inline函数</a></li>
      </ul>
    </li>
    <li><a href="#constexpr函数">constexpr函数</a>
      <ul>
        <li>
          <ul>
            <li><a href="#constexpr与引用">constexpr与引用</a></li>
            <li><a href="#条件求值">条件求值</a></li>
          </ul>
        </li>
        <li><a href="#noreturn函数">[[noreturn]]函数</a></li>
        <li><a href="#局部变量">局部变量</a></li>
      </ul>
    </li>
    <li><a href="#参数传递">参数传递</a>
      <ul>
        <li><a href="#引用参数">引用参数</a></li>
        <li><a href="#数组参数">数组参数</a></li>
        <li><a href="#列表参数">列表参数</a></li>
        <li><a href="#数量未定的参数">数量未定的参数</a></li>
        <li><a href="#默认参数">默认参数</a></li>
      </ul>
    </li>
    <li><a href="#重载函数">重载函数</a>
      <ul>
        <li><a href="#自动重载解析">自动重载解析</a></li>
        <li><a href="#重载与返回类型">重载与返回类型</a></li>
        <li><a href="#重载与作用域">重载与作用域</a></li>
        <li><a href="#多实参解析">多实参解析</a></li>
        <li><a href="#手动重载解析">手动重载解析</a></li>
      </ul>
    </li>
    <li><a href="#前置和后置条件">前置和后置条件</a></li>
    <li><a href="#函数指针">函数指针</a></li>
  </ul>
</nav></div>
    </div><script>document.getElementsByTagName("main")[0].setAttribute("pageStyle", "wide")</script><script>document.getElementsByTagName("main")[0].setAttribute("autoTOC", "true")</script><article class="page single"><h1 class="single-title animate__animated animate__flipInX">C&#43;&#43;函数</h1><div class="post-meta">
            <div class="post-meta-line">
                <span class="post-author"><i class="author fas fa-user-circle fa-fw"></i><a href="/" title="Author" rel=" author" class="author">煜江叔叔</a>
                </span>&nbsp;<span class="post-category">收录于 </span>&nbsp;<span class="post-category">类别 <a href="/categories/c++%E5%AD%A6%E4%B9%A0/"><i class="far fa-folder fa-fw"></i>C++学习</a></span>&nbsp;<span class="post-category">和</span>&nbsp;<span class="post-series">系列 <a href="/series/c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%AF%AD%E8%A8%80/"><i class="far fa-list-alt fa-fw"></i>C++程序设计语言</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="11-09">11-09</time>&nbsp;<i class="far fa-edit fa-fw"></i>&nbsp;<time datetime="11-09">11-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7186 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 15 分钟&nbsp;</div>
        </div><div class="details series-nav open">
                                <div class="details-summary series-title">
                                    <span>系列 - C&#43;&#43;程序设计语言</span>
                                    <span><i class="details-icon fas fa-angle-right"></i></span>
                                </div>
                                <div class="details-content series-content">
                                    <nav>
                                        <ul><li><span class="active">C&#43;&#43;函数</span></li>
                                                    <li><a href="/2022/c-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">C&#43;&#43;异常处理</a></li>
                                                    <li><a href="/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/">C&#43;&#43;选择适当操作</a></li>
                                                    <li><a href="/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">C&#43;&#43;表达式</a></li>
                                                    <li><a href="/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/">C&#43;&#43;结构联合与枚举</a></li>
                                                    <li><a href="/2022/c-%E8%AF%AD%E5%8F%A5/">C&#43;&#43;语句</a></li>
                                                    <li><a href="/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/">C&#43;&#43;指针与引用</a></li>
                                                    <li><a href="/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/">C&#43;&#43;类型与声明</a></li>
                                                    <li><a href="/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/">C&#43;&#43;概览抽象机制</a></li>
                                                    <li><a href="/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">C&#43;&#43;概览基础知识</a></li></ul>
                                    </nav>
                                </div>
                            </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#函数声明">函数声明</a>
      <ul>
        <li><a href="#函数声明的组成要件">函数声明的组成要件</a></li>
        <li><a href="#函数定义">函数定义</a></li>
        <li><a href="#返回值">返回值</a></li>
        <li><a href="#inline函数">inline函数</a></li>
      </ul>
    </li>
    <li><a href="#constexpr函数">constexpr函数</a>
      <ul>
        <li>
          <ul>
            <li><a href="#constexpr与引用">constexpr与引用</a></li>
            <li><a href="#条件求值">条件求值</a></li>
          </ul>
        </li>
        <li><a href="#noreturn函数">[[noreturn]]函数</a></li>
        <li><a href="#局部变量">局部变量</a></li>
      </ul>
    </li>
    <li><a href="#参数传递">参数传递</a>
      <ul>
        <li><a href="#引用参数">引用参数</a></li>
        <li><a href="#数组参数">数组参数</a></li>
        <li><a href="#列表参数">列表参数</a></li>
        <li><a href="#数量未定的参数">数量未定的参数</a></li>
        <li><a href="#默认参数">默认参数</a></li>
      </ul>
    </li>
    <li><a href="#重载函数">重载函数</a>
      <ul>
        <li><a href="#自动重载解析">自动重载解析</a></li>
        <li><a href="#重载与返回类型">重载与返回类型</a></li>
        <li><a href="#重载与作用域">重载与作用域</a></li>
        <li><a href="#多实参解析">多实参解析</a></li>
        <li><a href="#手动重载解析">手动重载解析</a></li>
      </ul>
    </li>
    <li><a href="#前置和后置条件">前置和后置条件</a></li>
    <li><a href="#函数指针">函数指针</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h2 id="函数声明" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e" class="header-mark"></a>函数声明</h2><p>函数声明负责指定函数的名字、返回值的类型以及调用该函数所需的参数数量和类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">Elem</span><span class="o">*</span> <span class="nf">next_elem</span><span class="p">();</span> <span class="c1">//无须参数，返回Elem*
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">exit</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//int类型的参数，无返回值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span> <span class="c1">//double类型的参数，返回double
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="函数声明的组成要件" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e%e7%9a%84%e7%bb%84%e6%88%90%e8%a6%81%e4%bb%b6" class="header-mark"></a>函数声明的组成要件</h3><p>函数声明除了指定函数的名字、一组参数以及函数的返回类型外，还包括多种限定符和修饰符：</p>
<ul>
<li>函数的名字，必选</li>
<li>参数列表，可以为空，必选</li>
<li>返回类型，可以是void，可以是前置或后置形式(使用auto)，必选</li>
<li>inline，表示一种愿望，通过内联函数体实现函数调用</li>
<li>constexpr，表示当给定常量表达式作为实参时，应该可以在编译时对函数求值</li>
<li>noexcept，表示该函数不允许抛出异常</li>
<li>链接说明，例如static</li>
<li>[[noreturn]]，表示该函数不会用常规的调用/返回机制返回结果</li>
</ul>
<p>此外，成员函数还能被限定为：</p>
<ul>
<li>virtual，表示该函数可以被派生类覆盖</li>
<li>override，表示该函数必须覆盖基类中的一个虚函数</li>
<li>final，表示该函数不能被派生类覆盖</li>
<li>static，表示函数不与某一特定的对象关联</li>
<li>const，表示该函数不能修改其对象的内容</li>
</ul>
<h3 id="函数定义" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b0%e5%ae%9a%e4%b9%89" class="header-mark"></a>函数定义</h3><p>函数的定义和全部声明必须对应同一类型。不过，为了与C语言兼容，会自动忽略参数类型的顶层const，下面两条声明语句对应的是同一个函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span> <span class="c1">//类型是void(int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">);</span> <span class="c1">//类型是void(int)
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>函数f()可以定义成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">//允许在此处修改x
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>或者定义成</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">//不允许在此处修改x
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不论对哪种情况而言，都只是函数调用者提供的实参的一个副本。<br>
通常通过不命名某个参数来表示该参数未在函数定义中使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">search</span><span class="p">(</span><span class="n">table</span><span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">key</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//未用到第三个参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一般来说，未命名的参数有助于简化代码并提升代码的可扩展性。<br>
除了函数之外，还能调用其他一些东西，它们遵循函数的大多数规则，比如参数传递规则：</p>
<ul>
<li>构造函数：严格来说不是函数，它没有返回值，可以初始化基类和成员，无法得到其地址。</li>
<li>析构函数：不能被重载，无法得到其地址。</li>
<li>函数对象：不是函数，不能被重载，但是其operaotr()是函数。</li>
<li>lambda表达式：是定义函数对象的一种简写形式。</li>
</ul>
<h3 id="返回值" class="headerLink">
    <a href="#%e8%bf%94%e5%9b%9e%e5%80%bc" class="header-mark"></a>返回值</h3><p>传统上，返回类型位于函数声明语句一开始的地方。然而，也可以在函数声明中把返回类型写在参数列表之后：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">string</span> <span class="nf">to_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="nf">to_string</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">string</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>前置的auto关键字表示函数的返回类型放在参数列表之后。后置返回类型则由符号-&gt;引导。
后置返回类型的必要性源于函数模板声明，因为其返回类型是依赖于参数的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span><span class="k">class</span> <span class="nc">U</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="k">auto</span> <span class="n">product</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">x</span><span class="p">,</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;&amp;</span> <span class="n">y</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数如果调用了它自身，称之为递归。
函数可以包含多条reutrn语句：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">fac2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">n</span><span class="o">*</span><span class="n">fac2</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>与参数传递的语义类似，函数返回值的语义也与拷贝初始化的语义一致。return语句初始化一个返回类型的变量，编译器检查返回表达式的类型是否与函数的返回类型吻合，并在必要时执行标准的或者用户自定义的类型转换：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">f</span><span class="p">(){</span><span class="k">return</span> <span class="mi">1</span><span class="p">;}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每次调用函数时，重新分配它的实参以及局部变量的拷贝。一旦函数返回了结果，所占的存储空间就被重新分配了。因此，不应该返回指向局部而非static变量的指针，我们无法预计该指针所指位置的内容将发生什么样的改变：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">*</span> <span class="nf">fp</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="n">local</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>引用有时也会发生类似的错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span><span class="o">&amp;</span> <span class="n">fr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">local</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">local</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>并不存在void值，不过，可以调用void函数令其作为另一个void函数的返回值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">h</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">g</span><span class="p">(</span><span class="n">p</span><span class="p">);</span> <span class="c1">//OK，等价与“g(p)；return；”
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当编写模板函数返回类型是模板参数时，这种返回类型有助于避免某些特殊情况。<br>
return语句的形式属于下述5种之一：</p>
<ul>
<li>执行一条return语句。</li>
<li>“跳转到函数末尾”，也就是说，直接到达函数体末端。这种情况只允许出现在无返回值的函数中。</li>
<li>抛出一个未被局部捕获的异常。</li>
<li>在一个noexcept函数中抛出一个异常且没有局部捕获，造成程序终止。</li>
<li>直接或间接请求一个无返回值的系统函数。</li>
</ul>
<h3 id="inline函数" class="headerLink">
    <a href="#inline%e5%87%bd%e6%95%b0" class="header-mark"></a>inline函数</h3><p>函数可以被定义为inline：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kr">inline</span> <span class="kt">int</span> <span class="nf">fac</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">?</span><span class="mi">1</span><span class="o">:</span><span class="n">n</span><span class="o">*</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="constexpr函数" class="headerLink">
    <a href="#constexpr%e5%87%bd%e6%95%b0" class="header-mark"></a>constexpr函数</h2><p>通常，函数无法在编译时求值，因此就不能在常量表达式中被调用。但是将函数指定为constexpr，就能向编译器传递这样的信息，即，如果给定了常量表达式作为实参，则希望该函数能被用在常量表达式中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">fac</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">?</span> <span class="n">n</span><span class="o">*</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">f9</span> <span class="o">=</span> <span class="n">fac</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当constexpr出现在函数定义中时，含义是“如果给定了常量表达式作为实参，则该函数应该能用在常量表达式中”。而当constexpr出现在对象定义中时，它的含义是“在编译时对初始化器求值”：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">f5</span> <span class="o">=</span> <span class="n">fac</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">//可能在编译时求值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">//在运行时求值（n是变量）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">f6</span> <span class="o">=</span> <span class="n">fac</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span> <span class="c1">//必须在编译时求值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">fnn</span> <span class="o">=</span> <span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">);</span> <span class="c1">//错误，无法确保在编译时求值（n是变量）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">a</span><span class="p">[</span><span class="n">fac</span><span class="p">(</span><span class="mi">4</span><span class="p">)];</span> <span class="c1">//OK，数组的尺寸必须是常量，而fac()恰好是constexpr
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">a2</span><span class="p">[</span><span class="n">fac</span><span class="p">(</span><span class="n">n</span><span class="p">)];</span> <span class="c1">//错误，数组的尺寸必须是常量，而n是一个变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数必须足够简单才能在编译时求值：constexpr函数必须包含一条独立的return语句，没有循环，也没有局部变量。同时，constexpr函数不能有副作用。也就是说，constexpr函数应该是一个纯函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">glob</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">bad1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="c1">//错误，constexpr函数不能是void
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">glob</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="c1">//错误，在constexpr函数中有副作用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">bad2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">else</span> <span class="k">return</span> <span class="o">-</span><span class="n">a</span><span class="p">;</span> <span class="c1">//错误，在constexpr函数中有if语句
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">bad3</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//错误，在constexpr函数中有局部变量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">;</span> <span class="o">+=</span><span class="n">i</span><span class="p">)</span> <span class="c1">//错误，在constexpr函数中有循环
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">fac</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>与普通的constexpr函数相比，constexpr构造函数的规则有所区别：只允许简单地执行成员初始化操作。</p>
<h4 id="constexpr与引用" class="headerLink">
    <a href="#constexpr%e4%b8%8e%e5%bc%95%e7%94%a8" class="header-mark"></a>constexpr与引用</h4><p>constexpr函数不允许有副作用，因此不能向非局部对象写入内容：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">ftbl</span><span class="p">[]{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">flb</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ftbl</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ftbl</span><span class="p">))</span> <span class="o">?</span> <span class="n">ftbl</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">:</span> <span class="n">flb</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>constexpr函数可以接受引用实参。尽管它不能通过这些引用写入内容，但是const引用参数同样有用。</p>
<h4 id="条件求值" class="headerLink">
    <a href="#%e6%9d%a1%e4%bb%b6%e6%b1%82%e5%80%bc" class="header-mark"></a>条件求值</h4><p>constexpr函数之外的条件表达式不会在编译时求值，这意味着它可以请求运行时的值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">check</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span><span class="p">(</span><span class="n">low</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="o">?</span> <span class="nl">i</span> <span class="p">:</span> <span class="k">throw</span> <span class="n">out_of_range</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="mi">99</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">));</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中，假定low和high是设计时未知而编译时已知的配置参数。此时，f(x,y,z)计算的是依赖于实现的值。</p>
<h3 id="noreturn函数" class="headerLink">
    <a href="#noreturn%e5%87%bd%e6%95%b0" class="header-mark"></a>[[noreturn]]函数</h3><p>形如[[&hellip;]]的概念被称为属性，属性可以置于任何位置。<br>
把[[noreturn]]放在函数声明语句的开始位置表示我们不希望函数返回任何结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="na">[[noreturn]]</span> <span class="kt">void</span> <span class="n">exit</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果函数被设定为[[noreturn]]，但是函数的内部仍然返回了某个值，将产生未定义的行为。</p>
<h3 id="局部变量" class="headerLink">
    <a href="#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f" class="header-mark"></a>局部变量</h3><p>定义在函数内部的名字称为局部名字。当线程执行到局部变量或常量的定义处时，它们将被初始化。将变量声明成static，则在函数的所有调用中都使用唯一的一份静态分配的对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">while</span><span class="p">(</span><span class="n">a</span><span class="o">--</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="k">static</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码的输出是：<br>
0,0<br>
1,0<br>
2,0</p>
<h2 id="参数传递" class="headerLink">
    <a href="#%e5%8f%82%e6%95%b0%e4%bc%a0%e9%80%92" class="header-mark"></a>参数传递</h2><h3 id="引用参数" class="headerLink">
    <a href="#%e5%bc%95%e7%94%a8%e5%8f%82%e6%95%b0" class="header-mark"></a>引用参数</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">ref</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用f()时，++val递增第一个实参在当前函数内的副本，而++ref递增第二个实参本身。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>调用(i,j)递增j的值，但是不会递增i的值。第一个实参i是以传值的方式传入函数，第二个实参j是以传引用的方式传入函数的。应该尽量避免修改引用类型的实参；但是，遇到大对象时，引用传递比值传递更有效。此时，应该将引用类型的参数声明成const的，表明使用引用只是处于效率的考虑，而非想让函数修改对象的值:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Large</span><span class="o">&amp;</span> <span class="n">arg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//不允许修改“arg”的值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果在还是函数的声明中有某个引用参数未被指定为const，则倾向于认为函数将修改该参数的值。<br>
类似的，指针类型的参数被声明成const意味着该指针所指对象的值不会被函数改变：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">char</span><span class="o">*</span> <span class="nf">strcpy</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">to</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">from</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">strcmp</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>字面值，常量以及需要执行类型转换的参数可以被传递给const T&amp;参数，但是不能传递给普通的非const T&amp;参数。一方面，允许向const T&amp;的转换以确保凡是能传给T类参数的值都能传给const T&amp;类型的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">fsqrt</span><span class="p">(</span><span class="k">const</span> <span class="kt">float</span><span class="o">&amp;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">r</span> <span class="o">=</span> <span class="n">faqrt</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">);</span> <span class="c1">//传递存放2.0f的临时变量的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r</span> <span class="o">=</span> <span class="n">fsqrt</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="c1">//传递r的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">r</span> <span class="o">=</span> <span class="n">fsqrt</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">//传递存放static_cast&lt;float&gt;(d)的临时变量的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另一方面，禁止向非const引用参数转换可以有效规避风险：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">fsqrt</span><span class="p">(</span><span class="kt">float</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">,</span> <span class="kt">float</span> <span class="n">r</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">update</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">);</span> <span class="c1">//错误，常量实参
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">update</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="c1">//传递r的引用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">update</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">//错误，需要执行类型转换
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>引用传递的准确描述是左值引用传递，原因是函数不能接受一个右值引用作为它的参数。左值能绑定在左值引用上(不能绑定在右值引用上)，右值能绑定在右值引用上(不能绑定在左值引用上)：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">//非const左值引用参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">//const左值引用参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;&amp;</span><span class="p">);</span> <span class="c1">//右值引用参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vi</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">cvi</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">vi</span><span class="p">);</span> <span class="c1">//f(vector&lt;int&gt;&amp;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f</span><span class="p">(</span><span class="n">cvi</span><span class="p">);</span> <span class="c1">//f(const vector&lt;int&gt;&amp;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">});</span> <span class="c1">//f(vector&lt;int&gt;&amp;&amp;)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于右值引用，最常见的用处是定义构造函数或者移动赋值运算。<br>
选择参数传递方式：</p>
<ol>
<li>对于小对象使用值传递的方式</li>
<li>对无需修改的大对象使用const引用传递</li>
<li>如果需要返回计算结果，最好使用return修改对象</li>
<li>使用右值实现移动和转发</li>
<li>如果找不到合适的对象，则传递指针</li>
<li>除非万不得已，否则不要使用引用传递</li>
</ol>
<h3 id="数组参数" class="headerLink">
    <a href="#%e6%95%b0%e7%bb%84%e5%8f%82%e6%95%b0" class="header-mark"></a>数组参数</h3><p>当数组作为函数的参数时，实际传入的是指向该数组首元素的指针：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">strlen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">char</span> <span class="n">v</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&#34;Annemarie&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">strlrn</span><span class="p">(</span><span class="s">&#34;Nicholas&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当作为参数被传入函数时，类型T[]会被转换成T*。这意味着如果对数组参数的元素赋值，就会改变数组元素的实际值。<br>
数组类型的参数与指针类型的参数等价：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">odd</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">odd</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[]);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">odd</span><span class="p">(</span><span class="kt">int</span> <span class="n">buf</span><span class="p">[</span><span class="mi">1020</span><span class="p">]);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这三条语句是等价的，声明的是同一个函数。<br>
对被调函数来说，数组的尺寸是不可见的，可以再传入一个参数表示数组的大小：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">compute1</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">vec_ptr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">vec_size</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>更好地做法是传入某些容器的引用。<br>
如果向传入一个数组而非容器或指向数组首元素的指针，可以将参数类型声明成数组的引用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)[</span><span class="mi">4</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span> <span class="c1">//OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span> <span class="c1">//错误，元素个数优有误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于数组引用类型的参数来说，元素个数也是其类型的一部分，因此，数组的引用的灵活性远不如指针或容器。通常在模板中才使用数组引用，此时元素个数可以通过推断得到：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span> <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)[</span><span class="n">N</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">//...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">a1</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="n">a2</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="n">a1</span><span class="p">);</span> <span class="c1">//T是int，N是10
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f</span><span class="p">(</span><span class="n">a2</span><span class="p">);</span> <span class="c1">//T是double，N是100
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样的后果是调用f()所用的数组类型有多少个，对应的函数定义就有多少个。<br>
多维数组的情况比较复杂，一般用指针的数组替代，此时无需特殊处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">day</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;mon&#34;</span><span class="p">,</span><span class="s">&#34;tue&#34;</span><span class="p">,</span><span class="s">&#34;wed&#34;</span><span class="p">,</span><span class="s">&#34;thu&#34;</span><span class="p">,</span><span class="s">&#34;fri&#34;</span><span class="p">,</span><span class="s">&#34;sat&#34;</span><span class="p">,</span><span class="s">&#34;sun&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>一如既往，vector即类似类型比内置的底层数组和指针更好。</p>
<h3 id="列表参数" class="headerLink">
    <a href="#%e5%88%97%e8%a1%a8%e5%8f%82%e6%95%b0" class="header-mark"></a>列表参数</h3><p>一个由{}限定的列表可以作为下述形参的实参：</p>
<ol>
<li>类型std::initialize_list<T>，其中列表的值能隐式的转换成T</li>
<li>能用列表中的值初始化的类型</li>
<li>T类型数组的引用，其中列表的值能隐式的转换成T</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">initialize_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">S</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">S</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span><span class="kt">int</span> <span class="n">N</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">f3</span><span class="p">(</span><span class="n">T</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">)[</span><span class="n">N</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f4</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">f1</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">});</span> <span class="c1">//T是int，initialize_list的大小是4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f2</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="s">&#34;MKS&#34;</span><span class="p">});</span> <span class="c1">//f2(S{1,&#34;MKS&#34;});
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f3</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">});</span> <span class="c1">//T是int，N是4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f4</span><span class="p">({</span><span class="mi">1</span><span class="p">});</span> <span class="c1">//f4(int{1});
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果存在二义性，则initialize_list参数的函数会被优先考虑。</p>
<h3 id="数量未定的参数" class="headerLink">
    <a href="#%e6%95%b0%e9%87%8f%e6%9c%aa%e5%ae%9a%e7%9a%84%e5%8f%82%e6%95%b0" class="header-mark"></a>数量未定的参数</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="p">...);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这条语句规定对标准库函数printf()的调用必须至少有一个C风格字符串的参数，同时也可以有也可以没有其他参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;Hello world!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">printf</span><span class="p">(</span><span class="s">&#34;My name is %s %s&#34;</span><span class="p">,</span><span class="n">first_name</span><span class="p">,</span> <span class="n">second_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">printtf</span><span class="p">(</span><span class="s">&#34;%d + %d = %d&#34;</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>想使用未限定类型的参数时，应该优先考虑使用重载函数、带默认参数的函数、接受initializer_list参数的函数或者可变参数模板。只有当参数数量和参数类型都不确定且可变模板也不适用时，才考虑使用省略号参数。</p>
<h3 id="默认参数" class="headerLink">
    <a href="#%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0" class="header-mark"></a>默认参数</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">complex</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">re</span><span class="p">,</span><span class="n">im</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">coplex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">,</span><span class="kt">double</span> <span class="n">i</span><span class="p">)</span><span class="o">:</span><span class="n">re</span><span class="p">{</span><span class="n">r</span><span class="p">},</span><span class="n">im</span><span class="p">{</span><span class="n">i</span><span class="p">}{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">)</span><span class="o">:</span><span class="n">re</span><span class="p">{</span><span class="n">r</span><span class="p">},</span><span class="n">im</span><span class="p">{</span><span class="mi">0</span><span class="p">}{}</span>
</span></span><span class="line"><span class="cl">    <span class="n">complex</span><span class="p">()</span><span class="o">:</span><span class="n">re</span><span class="p">{</span><span class="mi">0</span><span class="p">},</span><span class="n">im</span><span class="p">{</span><span class="mi">0</span><span class="p">}{}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果想在complex中加入一些调试、跟踪和统计的代码。只要加在一个地方就可以了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="n">complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="o">=</span><span class="p">{},</span> <span class="kt">double</span> <span class="n">i</span><span class="o">=</span><span class="p">{})</span><span class="o">:</span><span class="n">re</span><span class="p">{</span><span class="n">r</span><span class="p">},</span><span class="n">im</span><span class="p">{</span><span class="n">i</span><span class="p">}{}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果用户提供的参数数量不足，则使用预置的默认参数。<br>
默认参数在函数声明时执行类型检查，在调用函数时求值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">X</span><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">def_arg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span> <span class="n">def_arg</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">X</span><span class="o">::</span><span class="n">def_arg</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">.</span><span class="n">f</span><span class="p">();</span> <span class="c1">//maybe f(7)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">a</span><span class="p">.</span><span class="n">def_arg</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">a</span><span class="p">.</span><span class="n">f</span><span class="p">();</span> <span class="c1">//f(9)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最好避免使用值可能发生改变的默认参数。<br>
只能为参数列表中位置靠后的参数提供默认值：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="o">=</span><span class="k">nullptr</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="kt">int</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span> <span class="c1">//错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="nf">h</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="kt">char</span><span class="o">*</span> <span class="o">=</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">//错误
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>在同一作用域的一系列声明语句中，默认参数不能重复或者改变：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">7</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span><span class="mi">7</span><span class="p">);</span> <span class="c1">//错误，不允许重复默认参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">=</span><span class="mi">8</span><span class="p">);</span> <span class="c1">//错误，默认参数不一致
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">=</span><span class="mi">9</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="重载函数" class="headerLink">
    <a href="#%e9%87%8d%e8%bd%bd%e5%87%bd%e6%95%b0" class="header-mark"></a>重载函数</h2><p>为不同数据类型的同一种操作起相同的名字称为重载。</p>
<h3 id="自动重载解析" class="headerLink">
    <a href="#%e8%87%aa%e5%8a%a8%e9%87%8d%e8%bd%bd%e8%a7%a3%e6%9e%90" class="header-mark"></a>自动重载解析</h3><p>当调用函数fct时，由编译器决定使用名为fct的那组函数中的哪一个，一句是考察实参类型与作用域中名为fct的哪个函数的形参类型最匹配。当找到了最佳匹配时，调用该函数；反之，引发编译器错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">print</span><span class="p">(</span><span class="mi">1L</span><span class="p">);</span>  <span class="c1">//print(long)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span> <span class="c1">//print(double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>   <span class="c1">//错误，具有二义性
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了合理的解决问题，我们采用如下顺序尝试一系列评判准则：<br>
[1] 精确匹配：也就是说，无须类型转换或者仅需简单地类型转换即可实现匹配<br>
[2] 执行提升后匹配：也就是说，执行了整数提升(bool转为int)以及float转为double <br>
[3] 执行标准类型转换后实现匹配，T*转换为void*，以及int转换为unsigned int<br>
[4] 执行用户自定义的类型转换后实现匹配<br>
[5]使用函数声明中的省略号&hellip;进行匹配<br>
在该体系中，如果某次函数调用在能找到匹配的最高层级上发现了不止一个可用匹配，则本次调用将因产生了二义性而被拒绝，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">chat</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">h</span><span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">short</span> <span class="n">s</span><span class="p">,</span> <span class="kt">float</span> <span class="n">f</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">);</span> <span class="c1">//精确匹配，print(char)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//精确匹配，print(int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">//精确匹配，print(int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="c1">//float转换为double的提升
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">print</span><span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">);</span> <span class="c1">//精确匹配，print(char)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="mi">49</span><span class="p">);</span> <span class="c1">//精确匹配，print(int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//精确匹配，print(int)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="s">&#34;a&#34;</span><span class="p">);</span> <span class="c1">//精确匹配，print(const char*)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">print</span><span class="p">(</span><span class="k">nullptr</span><span class="p">);</span> <span class="c1">//nullptr_t转换const char*的提升
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>重载函数与函数声明的次序无关。</p>
<h3 id="重载与返回类型" class="headerLink">
    <a href="#%e9%87%8d%e8%bd%bd%e4%b8%8e%e8%bf%94%e5%9b%9e%e7%b1%bb%e5%9e%8b" class="header-mark"></a>重载与返回类型</h3><p>在重载解析过程中补考虑函数的返回类型，这样可以确保对运算符或者函数调用的解析独立于上下文：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">float</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">sqrt</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">voi</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span> <span class="n">da</span><span class="p">,</span> <span class="kt">float</span> <span class="n">fla</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">float</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">da</span><span class="p">);</span> <span class="c1">//sqrt(double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">da</span><span class="p">);</span> <span class="c1">//sqrt(double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">fl</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">fla</span><span class="p">);</span> <span class="c1">//sqrt(float)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">fla</span><span class="p">);</span> <span class="c1">//sqrt(float)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="重载与作用域" class="headerLink">
    <a href="#%e9%87%8d%e8%bd%bd%e4%b8%8e%e4%bd%9c%e7%94%a8%e5%9f%9f" class="header-mark"></a>重载与作用域</h3><p>重载发生在一组重载函数的成员内部，也就是说，重载函数应该位于同一个作用域内，不同的非名字空间作用域中的函数不会重载：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">f</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//调用d(double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>基类和派生类提供的作用域不同，因此默认情况下基类函数和派生函数不会发生重载：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">Derived</span><span class="o">:</span><span class="n">Base</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="n">Derived</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//Derived::f(double)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="多实参解析" class="headerLink">
    <a href="#%e5%a4%9a%e5%ae%9e%e5%8f%82%e8%a7%a3%e6%9e%90" class="header-mark"></a>多实参解析</h3><p>对于一组重载函数以及一次调用来说，如果该调用对于各函数的参数类型在计算的效率和精度上差别明显，则可以应用重载解析规则从中选出最合适的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">double</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">complex</span> <span class="nf">pow</span><span class="p">(</span><span class="kt">double</span><span class="p">,</span> <span class="n">complex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">complex</span> <span class="nf">pow</span><span class="p">(</span><span class="n">complex</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">complex</span> <span class="nf">pow</span><span class="p">(</span><span class="n">complex</span><span class="p">,</span> <span class="n">complex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">k</span><span class="p">(</span><span class="n">coomplex</span> <span class="n">z</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">complex</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">complex</span> <span class="n">z3</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">complex</span> <span class="n">z4</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当重载函数包含两个或者多个参数时，上述的解析规则将作用于每一个参数，并且选出该参数的最佳匹配函数。如果某个函数是其中一个参数的最佳匹配，停驶在其他参数上也是更优的匹配或者至少不弱于别的函数，则该函数就是最终确定的最佳匹配函数。如果找不到符合上述条件的函数，则本次调用将因二义性的原因被拒绝：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">//错误，是调用pow(int(2.0),2)还是pow(2.0double(2))
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对于该调用来说，2.0的最佳匹配函数是pow(double, double)，2的最佳匹配函数是pow(int, int)，因此存在二义性，是一次错误的调用。</p>
<h3 id="手动重载解析" class="headerLink">
    <a href="#%e6%89%8b%e5%8a%a8%e9%87%8d%e8%bd%bd%e8%a7%a3%e6%9e%90" class="header-mark"></a>手动重载解析</h3><p>某个函数的重载版本过少或过多都可能导致二义性，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">k</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">f1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span> <span class="c1">//二义性：f1(char)还是f1(long)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">f2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">//二义性：f2(char*)还是f2(int*)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在可能的情况下，尽量把一组重载函数当成整体来看，考察其对于函数的恶语义来说是否有意义。</p>
<h2 id="前置和后置条件" class="headerLink">
    <a href="#%e5%89%8d%e7%bd%ae%e5%92%8c%e5%90%8e%e7%bd%ae%e6%9d%a1%e4%bb%b6" class="header-mark"></a>前置和后置条件</h2><p>我们把函数调用是应该遵循的约定称为前置条件，把函数返回值应该遵循的约定称为后置条件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">area</span><span class="p">(</span><span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wid</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">计算长方形的面积  
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">前置条件：长方形的长和宽都是正数
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">后置条件：返回值是正数  
</span></span></span><span class="line"><span class="cl"><span class="cm">
</span></span></span><span class="line"><span class="cl"><span class="cm">后置条件：返回值是长方形的面积，其中长方形的长和宽分别是len和wid
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">len</span><span class="o">*</span><span class="n">wid</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="函数指针" class="headerLink">
    <a href="#%e5%87%bd%e6%95%b0%e6%8c%87%e9%92%88" class="header-mark"></a>函数指针</h2><p>程序员只能对函数做两种操作：调用它或者获取它的地址。通过获取函数地址得到的指针能被用来调用该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">error</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">efct</span><span class="p">)(</span><span class="n">string</span><span class="p">);</span> <span class="c1">//指向函数的指针，该函数接受一个字符串参数，不返回任何东西
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">efct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">;</span> <span class="c1">//efct指向error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">efct</span><span class="p">(</span><span class="s">&#34;error&#34;</span><span class="p">);</span> <span class="c1">//通过efct调用error
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译器发现efct是个函数指针，因此会调用它所指的函数。也就是说，解引用函数指针时可以用*，也可以不用；同样，在获取函数地址时可以用&amp;，也可以不用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)(</span><span class="n">string</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f2</span><span class="p">)(</span><span class="n">string</span><span class="p">)</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">g</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">f1</span><span class="p">(</span><span class="s">&#34;Vasa&#34;</span><span class="p">);</span> <span class="c1">//上下等价
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">(</span><span class="o">*</span><span class="n">f1</span><span class="p">)(</span><span class="s">&#34;Mary Rose&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>函数指针的参数类型声明与函数本身类似。进行指针赋值操作时，要求完整的函数类型都必须精确匹配：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">pf</span><span class="p">)(</span><span class="n">string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">f2</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(){</span>
</span></span><span class="line"><span class="cl">    <span class="n">pf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f1</span><span class="p">;</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f2</span><span class="p">;</span> <span class="c1">//错误，返回类型错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f3</span><span class="p">;</span> <span class="c1">//错误，返回类型错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="n">pf</span><span class="p">(</span><span class="s">&#34;Hera&#34;</span><span class="p">);</span> <span class="c1">// OK
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">pf</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">//错误，返回类型错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">pf</span><span class="p">(</span><span class="s">&#34;Zeus&#34;</span><span class="p">);</span> <span class="c1">// 错误，试图将void赋给nit
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>C++允许将一个函数指针转换为别的指针类型，但之后必须把得到的结果指针转换回它原来的类型，否则就会出现意想不到的情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">P1</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">using</span> <span class="n">P2</span> <span class="o">=</span> <span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">Pa</span> <span class="n">pf</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">P2</span> <span class="n">pf2</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">P2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pf2</span><span class="p">();</span> <span class="c1">//可能发生严重错误
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">P1</span> <span class="n">pf1</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">P1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f2</span><span class="p">);</span>  <span class="c1">// 把pf2转换回来
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">pf1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div></div>

        <div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 11-09</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"><span><a class="link-to-mardown" href=/2022/c-%E5%87%BD%E6%95%B0/index.md target="_blank" rel="noopener noreferrer">阅读原始文档</a>
                    </span></div>
            <div class="post-info-share">
                <span><a href="#" onclick="return false;" title="分享到 Twitter" data-sharer="twitter" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" data-title="C&#43;&#43;函数" data-hashtags="常量表达式,函数指针,函数重载"><i class="fab fa-twitter fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Facebook" data-sharer="facebook" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" data-hashtag="常量表达式"><i class="fab fa-facebook-square fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Linkedin" data-sharer="linkedin" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/"><i class="fab fa-linkedin fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" data-title="C&#43;&#43;函数" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Pinterest" data-sharer="pinterest" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/"><i class="fab fa-pinterest fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Hacker News" data-sharer="hackernews" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" data-title="C&#43;&#43;函数"><i class="fab fa-hacker-news fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Reddit" data-sharer="reddit" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/"><i class="fab fa-reddit fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Line" data-sharer="line" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" data-title="C&#43;&#43;函数"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="#" onclick="return false;" title="分享到 微博" data-sharer="weibo" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" data-title="C&#43;&#43;函数"><i class="fab fa-weibo fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Blogger" data-sharer="blogger" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" data-title="C&#43;&#43;函数" data-description=""><i class="fab fa-blogger fa-fw"></i></a><a href="#" onclick="return false;" title="分享到 Skype" data-sharer="skype" data-url="http://example.org/2022/c-%E5%87%BD%E6%95%B0/" data-title="C&#43;&#43;函数"><i class="fab fa-skype fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F/">常量表达式</a>,&nbsp;<a href="/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/">函数指针</a>,&nbsp;<a href="/tags/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD/">函数重载</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/2022/c-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" class="prev" rel="prev" title="C&#43;&#43;异常处理"><i class="fas fa-angle-left fa-fw"></i>C&#43;&#43;异常处理</a></div>
</div>
<div id="comments"><div id="gitalk" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://github.com/gitalk/gitalk"></a>Gitalk</a>.
            </noscript></div></article></div>
        </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">
                    由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.94.2">Hugo</a> 强力驱动&nbsp;|&nbsp;主题 - <a href="https://github.com/HEIGE-PCloud/DoIt" target="_blank" rel="noopener noreffer" title="DoIt 0.2.13"><i class="far fa-edit fa-fw"></i> DoIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2022 - 2023</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank" rel="noopener noreferrer">煜江叔叔</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
            <div class="footer-line"></div>
            <div class="footer-line">
            </div>
        </div><script>
                    if('serviceWorker' in navigator) {
                        navigator.serviceWorker
                            .register('/sw.min.js', { scope: '/' })
                            .then(function(registration) {
                            });
                
                        navigator.serviceWorker
                            .ready
                            .then(function(registration) {
                            });
                    }
                </script></footer></div>

    <div id="fixed-buttons"><a href="#back-to-top" id="back-to-top-button" class="fixed-button" title="回到顶部">
            <i class="fas fa-arrow-up fa-fw"></i>
        </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
            <i class="fas fa-comment fa-fw"></i>
        </a>
    </div><div class="assets"><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.dd4cfdb9c1bcaa687c9794e0620c478af43dec711c465b0560c274a0c20d6023bc183b8817015eb778ab746927905d6e.js" integrity="sha384-3Uz9ucG8qmh8l5TgYgxHivQ97HEcRlsFYMJ0oMINYCO8GDuIFwFet3irdGknkF1u"></script><script type="text/javascript" src="/lib/fuse/fuse.min.48c164d6be2fb1688f4fe95c476118b3a5dbda2aad6b2cd12c8ccb959d37db926987c59fdc9338e377b745807f0c06b0.js" integrity="sha384-SMFk1r4vsWiPT&#43;lcR2EYs6Xb2iqtayzRLIzLlZ0325Jph8Wf3JM443e3RYB/DAaw"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.de04ffbec7a95a47f3fdf7fb3e958d51e333796a07ddc0e19bf03c8ccee8ba800ad3f7cfffd6dc1c7479907ab69dff9e.js" integrity="sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf&#43;e"></script><script type="text/javascript" src="/lib/topbar/topbar.min.1c26dd3f83978c568ee1c91cb7c6f1e397518b40c73c772d534ff3f3bb81cae306c6b7e8ee2275017e43fe0c0ed56822.js" integrity="sha384-HCbdP4OXjFaO4ckct8bx45dRi0DHPHctU0/z87uByuMGxrfo7iJ1AX5D/gwO1Wgi"></script><script type="text/javascript" src="/lib/pjax/pjax.min.811be7fbe3806492067fb1a7b4488f825fae80cc1d97e76064e8db943473e99ba8cb53fc73cd34a2cd2de52f2548f677.js" integrity="sha384-gRvn&#43;&#43;OAZJIGf7GntEiPgl&#43;ugMwdl&#43;dgZOjblDRz6Zuoy1P8c800os0t5S8lSPZ3"></script><script type="text/javascript" src="/js/theme.min.js" defer></script></div>

<div class="pjax-assets"><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":12},"comment":{"gitalk":{"admin":["Treamn"],"clientID":"12d9838c8dc0fc1529e1","clientSecret":"ecfdb88bf5980b6312b96a4b40344fe630029771","id":"2022-11-09T15:53:25+08:00","owner":"Treamn","repo":"Treamn.github.io","title":"C++函数"}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"distance":100,"findAllMatches":true,"fuseIndexURL":"/index.json","highlightTag":"em","ignoreFieldNorm":false,"ignoreLocation":true,"isCaseSensitive":true,"location":0,"maxResultLength":10,"minMatchCharLength":2,"noResultsFound":"没有找到结果","snippetLength":50,"threshold":0.1,"type":"fuse","useExtendedSearch":false},"sharerjs":true};</script><script type="text/javascript" src="/lib/gitalk/gitalk.min.1420a0c0459673bc6824e7ba713f1e0ec1540e86491daf1b6149a7af9cd3f396c86b9182d03e4c727faefae17b746033.js" integrity="sha384-FCCgwEWWc7xoJOe6cT8eDsFUDoZJHa8bYUmnr5zT85bIa5GC0D5Mcn&#43;u&#43;uF7dGAz"></script><script type="text/javascript" src="/js/gitalk.min.js" defer></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.094758c1816ef1698123c876e7b739ac27751905f428bfb349857a93244d636b615bb42a43298a19f4c2235587c33bf2.js" integrity="sha384-CUdYwYFu8WmBI8h257c5rCd1GQX0KL&#43;zSYV6kyRNY2thW7QqQymKGfTCI1WHwzvy"></script><script type="text/javascript" src="/lib/sharer/sharer.min.0097b33812ac4873e9a2e0813de400c9ea9b07e223998d3cbc38a89bdfa3f45cc344689061a836fcd6f4c120eed429b4.js" integrity="sha384-AJezOBKsSHPpouCBPeQAyeqbB&#43;IjmY08vDiom9&#43;j9FzDRGiQYag2/Nb0wSDu1Cm0"></script><script type="text/javascript" src="/lib/katex/katex.min.cf57c90eac3c640a6318edffba73d650fb08ca67ec266cab0d5582f13bff6b51de3ad1a693035dffbc544b45dc9efb31.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" defer></script><script type="text/javascript" src="/lib/katex/auto-render.min.f970658d73cf8aff8ecdf6c1ddc5662c77f885d5051e558d64de6ca4d43bae61d35e977b5af26e9ba7c8002a4d35f211.js" integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" defer></script><script type="text/javascript" src="/lib/katex/copy-tex.min.129f44b345428d59fd74579a376b90c6019c1a61bea5f678781687c54a715c3391aeb54009954ea72c32cef15119b9af.js" integrity="sha384-Ep9Es0VCjVn9dFeaN2uQxgGcGmG&#43;pfZ4eBaHxUpxXDORrrVACZVOpywyzvFRGbmv" defer></script><script type="text/javascript" src="/lib/katex/mhchem.min.50463d2113e457e4d34d8ee72b5c12adf8563c3272f70af83e6620dc32cf70de45e0d0e5230199916b56bde291ff8e5c.js" integrity="sha384-UEY9IRPkV&#43;TTTY7nK1wSrfhWPDJy9wr4PmYg3DLPcN5F4NDlIwGZkWtWveKR/45c" defer></script><script type="text/javascript" src="/js/katex.min.js" defer></script><link rel="stylesheet" href="/lib/gitalk/gitalk.min.b250718923eb2b3c2ba2de589fcc7f623ebf3efa17f0e501e7de204156024b108524ffafaf0958fd09d3b68cf0412999.css" integrity="sha384-slBxiSPrKzwrot5Yn8x/Yj6/PvoX8OUB594gQVYCSxCFJP&#43;vrwlY/QnTtozwQSmZ"><link rel="stylesheet" href="/lib/katex/katex.min.c1295c9b11c1c40c96352d034d67fdec66a788f699f663cc2bd92b0081cb3f444ae3739dcd761e19ee5b23006356ac7d.css" integrity="sha384-wSlcmxHBxAyWNS0DTWf97GaniPaZ9mPMK9krAIHLP0RK43OdzXYeGe5bIwBjVqx9"><link rel="preload" as="style" onload="this.onload=null;this.rel='stylesheet'" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK">
        <noscript><link rel="stylesheet" href="/lib/katex/copy-tex.min.1f5388069d157848068f2228e33a72016ef3233cfb0afc2940343e446a708357e5b391b470f94c0e1c80745c331651ca.css" integrity="sha384-H1OIBp0VeEgGjyIo4zpyAW7zIzz7CvwpQDQ&#43;RGpwg1fls5G0cPlMDhyAdFwzFlHK"></noscript></div>
</body>

</html>