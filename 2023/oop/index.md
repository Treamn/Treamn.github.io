# OOP


## 概述  
虚函数：基类希望它的派生类个自定义适合自身的版本，此时基类就将这些函数声明成虚函数。    


## 定义基类和派生类   
### 定义基类   

作为继承关系中根节点的类通常都会定义一个虚析构函数。   

基类希望派生类有权访问成员，同时禁止其他成员访问。此时使用protected访问运算符说明这样的成员。  

### 定义派生类   

#### 派生类中的虚函数   
派生类经常覆盖它继承的虚函数。如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。   

#### 派生类构造函数   
尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也要使用基类的构造函数来初始化它的基类部分。    



#### 继承与静态成员    
如果基类定义了一个静态成员，则在整个继承体系中值存在该成员的唯一定义。不论从基类派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。    


#### 派生类的声明   
派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表：
```cpp
class Bulk_quote : public Quote;   //错误，派生列表不能出现在这里
class Bulk_quote;   //正确
```

#### 被用作基类的类   
如果想将某个类用作基类，则该类必须已经定义而非仅仅声明。    


#### 防止继承的发生   
在类名后跟一个关键字final即可防止继承发生：
```cpp
class NoDerived final{};    //NoDerived不能作为基类
class Base{};
class Last final : Base{};   //Last不能作为基类
```


### 类型转换与继承    

#### 静态类型与动态类型   
当使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型与该表达式表示对象的动态类型区分开来。表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。    

#### 不存在从基类向派生类的隐式类型转换    
因为一个基类的对象可嗯是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换。   
基类的指针可以指向派生类，但是派生类的指针不能指向基类。   
即使一个基类指针或引用绑定在一个派生类对象上，也不能执行从基类向派生类的转换。
```cpp
Bulk_quote bulk;
Quote *itemp = &bulk;        //正确，动态类型是Bulk_qoute
Bulk_quote *bulkp = itemp;   //错误，不能将基类转换成派生类
```


## 虚函数      

使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为直到运行时才知道到底调用哪个版本的虚函数，所以所有虚函数都必须有定义。      

### 对虚函数的调用可能在运行时才被解析   




### 派生类中的虚函数   
当在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字指出该函数的性质。但是不是必须要这么做，因为一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数。   
一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。   
派生类中虚函数的返回类型也必须与基类函数匹配。   



### final和override说明符   
可以使用override关键字来说明派生类中的虚函数。    
如果使用override标记了某个函数，但是该函数没有覆盖已经存在的虚函数，此时编译器将报错。  
```cpp
struct B{
    virtual void f1(int) const;
    virtual void f2();
    void f3();
};

struct D1:B{
    void f1(int) const override;  //正确
    void f2(int) override;        //错误，没有f2(int)的函数
    void f3() override;           //错误，f3不是虚函数
    void f4() override;           //错误，B中没有f4函数
};
```
如果已经把函数定义成final，则之后的任何覆盖该函数的操作都啊经引发错误：
```cpp
struct D2:B{
    void f1(int) const final;
};
struct D3:D2{
    void f2();             //正确
    void f1(int) const;    //错误，D2将f2声明成final
};
```


### 虚函数与默认实参   

如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。  

**如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致**


## 抽象基类   

### 纯虚函数

和普通的虚函数不一样，一个纯虚函数无须定义。通过在函数体的位置书写**=0**就可以将一个虚函数说明为纯虚函数。其中，=0只能出现在类内部的虚函数声明语句处。    
可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，不能在类的内部为一个=0的函数提供函数体。   


### 含有纯虚函数的类是抽象基类   

抽象基类负责定义接口，而后续的其他类可以覆盖该接口。不能直接创建一个抽象基类的对象。

### 派生类构造函数只初始化它的直接基类  




## 访问控制与继承   

每个类分别控制其成员对于派生类来说是否可访问    

### 受保护的成员   
protected关键字用来声明希望与派生类分享但是不想被其他公共访问使用的成员。    
- 和私有成员类似，受保护的成员对于类的用户来说是不可访问的。   
- 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的。   
- 派生类的成员或友元只能通过派生类对象来访问基类受保护的成员。派生类对于一个基类对象中的受保护成员没有任何访问权限。    


派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。    


### 公有、私有和受保护继承    

公有继承和私有继承均能访问受保护的成员，但是都不能访问私有成员。     


### 派生类向基类转换的可访问性   

- 只有当D公有继承B时，才能使用派生类向基类的转换；如果D继承B的方式是私有或是受保护的，则不能使用转换。   
- 不论D以什么方式继承B，D的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。   
- 如果D继承B的方式是公有的或是受保护的，则D的派生类的成员和友元可以使用D向B的类型转换；反之，如果D继承B的方式是私有地，则不能使用。


### 友元和继承   
友元关系不能继承。基类的友元在访问派生类成员是不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员。   
不能继承友元关系；每个类控制负责各自成员的访问权限。

### 改变个别成员的可访问性   
有时需要改变派生类继承的某个名字的访问级别，通过使用using声明达到这一目的：

using声明语句中名字的访问权限由该using声明语句之前的访问说明符来决定。如果using语句出现在private部分，则该名字只能被类的成员和友元访问；如果using语句位于public部分，则类的所有用户都能访问它；protected同理。   


### 默认的继承保护级别   

默认情况下，使用class关键字定义的派生类是私有继承的，而使用struct关键字定义的派生类是公有继承的：
```cpp
class Base{};
struct D1:Base{};  //默认public继承
class D2:Base{};   //默认private继承
```


一个私有派生的类最好显式的将private声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。  



## 继承中的类作用域   
































