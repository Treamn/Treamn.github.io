[{"categories":["C++学习"],"content":"函数声明函数声明负责指定函数的名字、返回值的类型以及调用该函数所需的参数数量和类型： Elem* next_elem(); //无须参数，返回Elem* void exit(int); //int类型的参数，无返回值 double sqrt(double); //double类型的参数，返回double ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:1:0","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#函数声明"},{"categories":["C++学习"],"content":"函数声明的组成要件函数声明除了指定函数的名字、一组参数以及函数的返回类型外，还包括多种限定符和修饰符： 函数的名字，必选 参数列表，可以为空，必选 返回类型，可以是void，可以是前置或后置形式(使用auto)，必选 inline，表示一种愿望，通过内联函数体实现函数调用 constexpr，表示当给定常量表达式作为实参时，应该可以在编译时对函数求值 noexcept，表示该函数不允许抛出异常 链接说明，例如static [[noreturn]]，表示该函数不会用常规的调用/返回机制返回结果 此外，成员函数还能被限定为： virtual，表示该函数可以被派生类覆盖 override，表示该函数必须覆盖基类中的一个虚函数 final，表示该函数不能被派生类覆盖 static，表示函数不与某一特定的对象关联 const，表示该函数不能修改其对象的内容 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:1:1","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#函数声明的组成要件"},{"categories":["C++学习"],"content":"函数定义函数的定义和全部声明必须对应同一类型。不过，为了与C语言兼容，会自动忽略参数类型的顶层const，下面两条声明语句对应的是同一个函数： void f(int); //类型是void(int) void f(const int); //类型是void(int) 函数f()可以定义成： void f(int x); //允许在此处修改x 或者定义成 void f(const int x); //不允许在此处修改x 不论对哪种情况而言，都只是函数调用者提供的实参的一个副本。 通常通过不命名某个参数来表示该参数未在函数定义中使用： void search(table* t, const char* key, const char*){ //未用到第三个参数 } 一般来说，未命名的参数有助于简化代码并提升代码的可扩展性。 除了函数之外，还能调用其他一些东西，它们遵循函数的大多数规则，比如参数传递规则： 构造函数：严格来说不是函数，它没有返回值，可以初始化基类和成员，无法得到其地址。 析构函数：不能被重载，无法得到其地址。 函数对象：不是函数，不能被重载，但是其operaotr()是函数。 lambda表达式：是定义函数对象的一种简写形式。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:1:2","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#函数定义"},{"categories":["C++学习"],"content":"返回值传统上，返回类型位于函数声明语句一开始的地方。然而，也可以在函数声明中把返回类型写在参数列表之后： string to_string(int a); auto to_string(int a)-\u003estring; 前置的auto关键字表示函数的返回类型放在参数列表之后。后置返回类型则由符号-\u003e引导。 后置返回类型的必要性源于函数模板声明，因为其返回类型是依赖于参数的： template\u003cclass T,class U\u003e auto product(const vector\u003cT\u003e\u0026 x,const vector\u003cU\u003e\u0026 y) -\u003e decltype(x*y); 函数如果调用了它自身，称之为递归。 函数可以包含多条reutrn语句： int fac2(int n) { if(n \u003e 1) return n*fac2(n-1); return 1; } 与参数传递的语义类似，函数返回值的语义也与拷贝初始化的语义一致。return语句初始化一个返回类型的变量，编译器检查返回表达式的类型是否与函数的返回类型吻合，并在必要时执行标准的或者用户自定义的类型转换： double f(){return 1;} 每次调用函数时，重新分配它的实参以及局部变量的拷贝。一旦函数返回了结果，所占的存储空间就被重新分配了。因此，不应该返回指向局部而非static变量的指针，我们无法预计该指针所指位置的内容将发生什么样的改变： int* fp() { int local = 1; return \u0026local; } 引用有时也会发生类似的错误： int\u0026 fr() { int local = 1; return local; } 并不存在void值，不过，可以调用void函数令其作为另一个void函数的返回值： void g(int* p); void h(int* p); { return g(p); //OK，等价与“g(p)；return；” } 当编写模板函数返回类型是模板参数时，这种返回类型有助于避免某些特殊情况。 return语句的形式属于下述5种之一： 执行一条return语句。 “跳转到函数末尾”，也就是说，直接到达函数体末端。这种情况只允许出现在无返回值的函数中。 抛出一个未被局部捕获的异常。 在一个noexcept函数中抛出一个异常且没有局部捕获，造成程序终止。 直接或间接请求一个无返回值的系统函数。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:1:3","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#返回值"},{"categories":["C++学习"],"content":"inline函数函数可以被定义为inline： inline int fac(int n){ return(n\u003c2)?1:n*fac(n-1); } ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:1:4","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#inline函数"},{"categories":["C++学习"],"content":"constexpr函数通常，函数无法在编译时求值，因此就不能在常量表达式中被调用。但是将函数指定为constexpr，就能向编译器传递这样的信息，即，如果给定了常量表达式作为实参，则希望该函数能被用在常量表达式中： constexpr int fac(int n) { return(n \u003e 1)? n*fac(n-1) : 1; } constexpr int f9 = fac(9); 当constexpr出现在函数定义中时，含义是“如果给定了常量表达式作为实参，则该函数应该能用在常量表达式中”。而当constexpr出现在对象定义中时，它的含义是“在编译时对初始化器求值”： void f(int n) { int f5 = fac(5); //可能在编译时求值 int fn = fac(n); //在运行时求值（n是变量） constexpr int f6 = fac(6); //必须在编译时求值 constexpr int fnn = fac(n); //错误，无法确保在编译时求值（n是变量） char a[fac(4)]; //OK，数组的尺寸必须是常量，而fac()恰好是constexpr char a2[fac(n)]; //错误，数组的尺寸必须是常量，而n是一个变量 } 函数必须足够简单才能在编译时求值：constexpr函数必须包含一条独立的return语句，没有循环，也没有局部变量。同时，constexpr函数不能有副作用。也就是说，constexpr函数应该是一个纯函数： int glob; constexpr void bad1(int a) { //错误，constexpr函数不能是void glob = a; //错误，在constexpr函数中有副作用 } constexpr int bad2(int a) { if(a \u003e= 0) return a; else return -a; //错误，在constexpr函数中有if语句 } constexpr int bad3(int a) { sum = 0; //错误，在constexpr函数中有局部变量 for(int i = 0; i \u003c a; +=i) //错误，在constexpr函数中有循环 sum += fac(i); return sum; } 与普通的constexpr函数相比，constexpr构造函数的规则有所区别：只允许简单地执行成员初始化操作。 constexpr与引用constexpr函数不允许有副作用，因此不能向非局部对象写入内容： constexpr int ftbl[]{1,2,3,5,8,13}; constexpr int flb(int n) { return (n \u003c sizeof(ftbl)/sizeof(*ftbl)) ? ftbl[n] : flb(n); } constexpr函数可以接受引用实参。尽管它不能通过这些引用写入内容，但是const引用参数同样有用。 条件求值constexpr函数之外的条件表达式不会在编译时求值，这意味着它可以请求运行时的值： constexpr int check(int i) { return(low \u003c= i \u0026\u0026 i \u003c high) ? i : throw out_of_range(); } constexpr int low = 0; constexpr int high = 99; constexpr int val = check(f(x,y,z)); 其中，假定low和high是设计时未知而编译时已知的配置参数。此时，f(x,y,z)计算的是依赖于实现的值。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:2:0","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#constexpr函数"},{"categories":["C++学习"],"content":"constexpr函数通常，函数无法在编译时求值，因此就不能在常量表达式中被调用。但是将函数指定为constexpr，就能向编译器传递这样的信息，即，如果给定了常量表达式作为实参，则希望该函数能被用在常量表达式中： constexpr int fac(int n) { return(n 1)? n*fac(n-1) : 1; } constexpr int f9 = fac(9); 当constexpr出现在函数定义中时，含义是“如果给定了常量表达式作为实参，则该函数应该能用在常量表达式中”。而当constexpr出现在对象定义中时，它的含义是“在编译时对初始化器求值”： void f(int n) { int f5 = fac(5); //可能在编译时求值 int fn = fac(n); //在运行时求值（n是变量） constexpr int f6 = fac(6); //必须在编译时求值 constexpr int fnn = fac(n); //错误，无法确保在编译时求值（n是变量） char a[fac(4)]; //OK，数组的尺寸必须是常量，而fac()恰好是constexpr char a2[fac(n)]; //错误，数组的尺寸必须是常量，而n是一个变量 } 函数必须足够简单才能在编译时求值：constexpr函数必须包含一条独立的return语句，没有循环，也没有局部变量。同时，constexpr函数不能有副作用。也就是说，constexpr函数应该是一个纯函数： int glob; constexpr void bad1(int a) { //错误，constexpr函数不能是void glob = a; //错误，在constexpr函数中有副作用 } constexpr int bad2(int a) { if(a = 0) return a; else return -a; //错误，在constexpr函数中有if语句 } constexpr int bad3(int a) { sum = 0; //错误，在constexpr函数中有局部变量 for(int i = 0; i ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:2:0","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#constexpr与引用"},{"categories":["C++学习"],"content":"constexpr函数通常，函数无法在编译时求值，因此就不能在常量表达式中被调用。但是将函数指定为constexpr，就能向编译器传递这样的信息，即，如果给定了常量表达式作为实参，则希望该函数能被用在常量表达式中： constexpr int fac(int n) { return(n 1)? n*fac(n-1) : 1; } constexpr int f9 = fac(9); 当constexpr出现在函数定义中时，含义是“如果给定了常量表达式作为实参，则该函数应该能用在常量表达式中”。而当constexpr出现在对象定义中时，它的含义是“在编译时对初始化器求值”： void f(int n) { int f5 = fac(5); //可能在编译时求值 int fn = fac(n); //在运行时求值（n是变量） constexpr int f6 = fac(6); //必须在编译时求值 constexpr int fnn = fac(n); //错误，无法确保在编译时求值（n是变量） char a[fac(4)]; //OK，数组的尺寸必须是常量，而fac()恰好是constexpr char a2[fac(n)]; //错误，数组的尺寸必须是常量，而n是一个变量 } 函数必须足够简单才能在编译时求值：constexpr函数必须包含一条独立的return语句，没有循环，也没有局部变量。同时，constexpr函数不能有副作用。也就是说，constexpr函数应该是一个纯函数： int glob; constexpr void bad1(int a) { //错误，constexpr函数不能是void glob = a; //错误，在constexpr函数中有副作用 } constexpr int bad2(int a) { if(a = 0) return a; else return -a; //错误，在constexpr函数中有if语句 } constexpr int bad3(int a) { sum = 0; //错误，在constexpr函数中有局部变量 for(int i = 0; i ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:2:0","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#条件求值"},{"categories":["C++学习"],"content":"[[noreturn]]函数形如[[…]]的概念被称为属性，属性可以置于任何位置。 把[[noreturn]]放在函数声明语句的开始位置表示我们不希望函数返回任何结果： [[noreturn]] void exit(int); 如果函数被设定为[[noreturn]]，但是函数的内部仍然返回了某个值，将产生未定义的行为。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:2:1","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#noreturn函数"},{"categories":["C++学习"],"content":"局部变量定义在函数内部的名字称为局部名字。当线程执行到局部变量或常量的定义处时，它们将被初始化。将变量声明成static，则在函数的所有调用中都使用唯一的一份静态分配的对象： void f(int a) { while(a--){ static int n = 0; int x = 0; cout \u003c\u003c n++ \u003c\u003c x++; } } int main() { f(3); } 上述代码的输出是： 0,0 1,0 2,0 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:2:2","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#局部变量"},{"categories":["C++学习"],"content":"参数传递","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:3:0","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#参数传递"},{"categories":["C++学习"],"content":"引用参数 void f(int val, int\u0026 ref) { ++val; ++ref; } 调用f()时，++val递增第一个实参在当前函数内的副本，而++ref递增第二个实参本身。 void g() { int i = 1; int j = 1; f(i,j); } 调用(i,j)递增j的值，但是不会递增i的值。第一个实参i是以传值的方式传入函数，第二个实参j是以传引用的方式传入函数的。应该尽量避免修改引用类型的实参；但是，遇到大对象时，引用传递比值传递更有效。此时，应该将引用类型的参数声明成const的，表明使用引用只是处于效率的考虑，而非想让函数修改对象的值: void f(const Large\u0026 arg) { //不允许修改“arg”的值 } 如果在还是函数的声明中有某个引用参数未被指定为const，则倾向于认为函数将修改该参数的值。 类似的，指针类型的参数被声明成const意味着该指针所指对象的值不会被函数改变： int strlen(const char*); char* strcpy(char* to, const char* from); int strcmp(const char*, const char*); 字面值，常量以及需要执行类型转换的参数可以被传递给const T\u0026参数，但是不能传递给普通的非const T\u0026参数。一方面，允许向const T\u0026的转换以确保凡是能传给T类参数的值都能传给const T\u0026类型的参数： float fsqrt(const float\u0026); void g(double d) { float r = faqrt(2.0f); //传递存放2.0f的临时变量的引用 r = fsqrt(r); //传递r的引用 r = fsqrt(d); //传递存放static_cast\u003cfloat\u003e(d)的临时变量的引用 } 另一方面，禁止向非const引用参数转换可以有效规避风险： void fsqrt(float\u0026 i); void g(double d, float r) { update(2.0f); //错误，常量实参 update(r); //传递r的引用 update(d); //错误，需要执行类型转换 } 引用传递的准确描述是左值引用传递，原因是函数不能接受一个右值引用作为它的参数。左值能绑定在左值引用上(不能绑定在右值引用上)，右值能绑定在右值引用上(不能绑定在左值引用上)： void f(vector\u003cint\u003e\u0026); //非const左值引用参数 void f(const vector\u003cint\u003e\u0026); //const左值引用参数 void f(vector\u003cint\u003e\u0026\u0026); //右值引用参数 void g(vector\u003cint\u003e\u0026 vi, const vector\u003cint\u003e\u0026 cvi) { f(vi); //f(vector\u003cint\u003e\u0026) f(cvi); //f(const vector\u003cint\u003e\u0026) f(vector\u003cint\u003e{1,2,3,4}); //f(vector\u003cint\u003e\u0026\u0026) } 对于右值引用，最常见的用处是定义构造函数或者移动赋值运算。 选择参数传递方式： 对于小对象使用值传递的方式 对无需修改的大对象使用const引用传递 如果需要返回计算结果，最好使用return修改对象 使用右值实现移动和转发 如果找不到合适的对象，则传递指针 除非万不得已，否则不要使用引用传递 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:3:1","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#引用参数"},{"categories":["C++学习"],"content":"数组参数当数组作为函数的参数时，实际传入的是指向该数组首元素的指针： int strlen(const char*); void f() { char v[] = \"Annemarie\"; int i = strlen(V); int j = strlrn(\"Nicholas\"); } 当作为参数被传入函数时，类型T[]会被转换成T*。这意味着如果对数组参数的元素赋值，就会改变数组元素的实际值。 数组类型的参数与指针类型的参数等价： void odd(int* p); void odd(int a[]); void odd(int buf[1020]); 这三条语句是等价的，声明的是同一个函数。 对被调函数来说，数组的尺寸是不可见的，可以再传入一个参数表示数组的大小： void compute1(int* vec_ptr, int vec_size); 更好地做法是传入某些容器的引用。 如果向传入一个数组而非容器或指向数组首元素的指针，可以将参数类型声明成数组的引用： void f(int(\u0026r)[4]); void g() { int a1[] = {1,2,3,4}; int a2[] = {1,2}; f(a1); //OK f(a2); //错误，元素个数优有误 } 对于数组引用类型的参数来说，元素个数也是其类型的一部分，因此，数组的引用的灵活性远不如指针或容器。通常在模板中才使用数组引用，此时元素个数可以通过推断得到： template\u003cclass T, int N\u003e void f(T(\u0026r)[N]); { //... } int a1[10]; double a2[100]; void g() { f(a1); //T是int，N是10 f(a2); //T是double，N是100 } 这样的后果是调用f()所用的数组类型有多少个，对应的函数定义就有多少个。 多维数组的情况比较复杂，一般用指针的数组替代，此时无需特殊处理： const char* day[] = { \"mon\",\"tue\",\"wed\",\"thu\",\"fri\",\"sat\",\"sun\" }; 一如既往，vector即类似类型比内置的底层数组和指针更好。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:3:2","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#数组参数"},{"categories":["C++学习"],"content":"列表参数一个由{}限定的列表可以作为下述形参的实参： 类型std::initialize_list，其中列表的值能隐式的转换成T 能用列表中的值初始化的类型 T类型数组的引用，其中列表的值能隐式的转换成T template\u003cclass T\u003e void f1(initialize_list\u003cT\u003e); struct S{ int a; string s; }; void f2(S); template\u003cclass T,int N\u003e void f3(T(\u0026r)[N]); void f4(int); void g() { f1({1,2,3,4}); //T是int，initialize_list的大小是4 f2({1,\"MKS\"}); //f2(S{1,\"MKS\"}); f3({1,2,3,4}); //T是int，N是4 f4({1}); //f4(int{1}); } 如果存在二义性，则initialize_list参数的函数会被优先考虑。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:3:3","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#列表参数"},{"categories":["C++学习"],"content":"数量未定的参数 int print(const char* ...); 这条语句规定对标准库函数printf()的调用必须至少有一个C风格字符串的参数，同时也可以有也可以没有其他参数： printf(\"Hello world!\\n\"); printf(\"My name is %s %s\",first_name, second_name); printtf(\"%d + %d = %d\",2,3,5); 想使用未限定类型的参数时，应该优先考虑使用重载函数、带默认参数的函数、接受initializer_list参数的函数或者可变参数模板。只有当参数数量和参数类型都不确定且可变模板也不适用时，才考虑使用省略号参数。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:3:4","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#数量未定的参数"},{"categories":["C++学习"],"content":"默认参数 class complex{ double re,im; public: coplex(double r,double i):re{r},im{i}{} complex(double r):re{r},im{0}{} complex():re{0},im{0}{} }; 如果想在complex中加入一些调试、跟踪和统计的代码。只要加在一个地方就可以了： complex(double r={}, double i={}):re{r},im{i}{} 如果用户提供的参数数量不足，则使用预置的默认参数。 默认参数在函数声明时执行类型检查，在调用函数时求值： class X{ public: static int def_arg; void f(int = def_arg); }; int X::def_arg = 7; void g(X\u0026 a) { a.f(); //maybe f(7) a.def_arg = 9; a.f(); //f(9) } 最好避免使用值可能发生改变的默认参数。 只能为参数列表中位置靠后的参数提供默认值： int f(int, int =0, char* =nullptr); int g(int =0, int =0,char*); //错误 int h(int =0,int,char* =nullptr); //错误 在同一作用域的一系列声明语句中，默认参数不能重复或者改变： void f(int x=7); void f(int =7); //错误，不允许重复默认参数 void f(int =8); //错误，默认参数不一致 void g() { void f(int x=9); } ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:3:5","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#默认参数"},{"categories":["C++学习"],"content":"重载函数为不同数据类型的同一种操作起相同的名字称为重载。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:4:0","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#重载函数"},{"categories":["C++学习"],"content":"自动重载解析当调用函数fct时，由编译器决定使用名为fct的那组函数中的哪一个，一句是考察实参类型与作用域中名为fct的哪个函数的形参类型最匹配。当找到了最佳匹配时，调用该函数；反之，引发编译器错误： void print(double); void print(long); void f() { print(1L); //print(long) print(1.0); //print(double) print(1); //错误，具有二义性 } 为了合理的解决问题，我们采用如下顺序尝试一系列评判准则： [1] 精确匹配：也就是说，无须类型转换或者仅需简单地类型转换即可实现匹配 [2] 执行提升后匹配：也就是说，执行了整数提升(bool转为int)以及float转为double [3] 执行标准类型转换后实现匹配，T*转换为void*，以及int转换为unsigned int [4] 执行用户自定义的类型转换后实现匹配 [5]使用函数声明中的省略号…进行匹配 在该体系中，如果某次函数调用在能找到匹配的最高层级上发现了不止一个可用匹配，则本次调用将因产生了二义性而被拒绝，例如： void print(int); void print(const chat*); void print(double); void print(long); void print(char); void h(char c, short s, float f){ print(c); //精确匹配，print(char) print(i); //精确匹配，print(int) print(s); //精确匹配，print(int) print(f); //float转换为double的提升 print('a'); //精确匹配，print(char) print(49); //精确匹配，print(int) print(0); //精确匹配，print(int) print(\"a\"); //精确匹配，print(const char*) print(nullptr); //nullptr_t转换const char*的提升 } 重载函数与函数声明的次序无关。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:4:1","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#自动重载解析"},{"categories":["C++学习"],"content":"重载与返回类型在重载解析过程中补考虑函数的返回类型，这样可以确保对运算符或者函数调用的解析独立于上下文： float sqrt(float); double sqrt(double); voi f(double da, float fla){ float fl = sqrt(da); //sqrt(double) double d = sqrt(da); //sqrt(double) fl = sqrt(fla); //sqrt(float) d = sqrt(fla); //sqrt(float) } ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:4:2","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#重载与返回类型"},{"categories":["C++学习"],"content":"重载与作用域重载发生在一组重载函数的成员内部，也就是说，重载函数应该位于同一个作用域内，不同的非名字空间作用域中的函数不会重载： void f(int); void g(){ void f(double); f(1); //调用d(double) } 基类和派生类提供的作用域不同，因此默认情况下基类函数和派生函数不会发生重载： struct Base{ void f(int); }; struct Derived:Base{ void f(double); }; void g(Derived\u0026 d){ d.f(1); //Derived::f(double) } ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:4:3","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#重载与作用域"},{"categories":["C++学习"],"content":"多实参解析对于一组重载函数以及一次调用来说，如果该调用对于各函数的参数类型在计算的效率和精度上差别明显，则可以应用重载解析规则从中选出最合适的函数： int pow(int, int); double pow(double, double); complex pow(double, complex); complex pow(complex, int); complex pow(complex, complex); void k(coomplex z){ int i = pow(2,2); double d = pow(2.0, 2.0); complex z2 = pow(2, z); complex z3 = pow(z, 2); complex z4 = pow(z, z); } 当重载函数包含两个或者多个参数时，上述的解析规则将作用于每一个参数，并且选出该参数的最佳匹配函数。如果某个函数是其中一个参数的最佳匹配，停驶在其他参数上也是更优的匹配或者至少不弱于别的函数，则该函数就是最终确定的最佳匹配函数。如果找不到符合上述条件的函数，则本次调用将因二义性的原因被拒绝： void g(){ double d = pow(2.0, 2); //错误，是调用pow(int(2.0),2)还是pow(2.0double(2)) } 对于该调用来说，2.0的最佳匹配函数是pow(double, double)，2的最佳匹配函数是pow(int, int)，因此存在二义性，是一次错误的调用。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:4:4","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#多实参解析"},{"categories":["C++学习"],"content":"手动重载解析某个函数的重载版本过少或过多都可能导致二义性，例如： void f1(char); void f1(long); void f2(char*); void f2(int*); void k(int i){ f1(i); //二义性：f1(char)还是f1(long) f2(0); //二义性：f2(char*)还是f2(int*) } 在可能的情况下，尽量把一组重载函数当成整体来看，考察其对于函数的恶语义来说是否有意义。 ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:4:5","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#手动重载解析"},{"categories":["C++学习"],"content":"前置和后置条件我们把函数调用是应该遵循的约定称为前置条件，把函数返回值应该遵循的约定称为后置条件： int area(int len, int wid) /* 计算长方形的面积 前置条件：长方形的长和宽都是正数 后置条件：返回值是正数 后置条件：返回值是长方形的面积，其中长方形的长和宽分别是len和wid */ { return len*wid; } ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:5:0","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#前置和后置条件"},{"categories":["C++学习"],"content":"函数指针程序员只能对函数做两种操作：调用它或者获取它的地址。通过获取函数地址得到的指针能被用来调用该函数： void error(string s); void (*efct)(string); //指向函数的指针，该函数接受一个字符串参数，不返回任何东西 void f(){ efct = \u0026error; //efct指向error efct(\"error\"); //通过efct调用error } 编译器发现efct是个函数指针，因此会调用它所指的函数。也就是说，解引用函数指针时可以用*，也可以不用；同样，在获取函数地址时可以用\u0026，也可以不用： void (*f1)(string) = \u0026error; void (*f2)(string) = error; void g(){ f1(\"Vasa\"); //上下等价 (*f1)(\"Mary Rose\"); } 函数指针的参数类型声明与函数本身类似。进行指针赋值操作时，要求完整的函数类型都必须精确匹配： void (*pf)(string); void f1(string); int f2(string); void f3(int*); void f(){ pf = \u0026f1; // OK pf = \u0026f2; //错误，返回类型错误 pf = \u0026f3; //错误，返回类型错误 pf(\"Hera\"); // OK pf(1); //错误，返回类型错误 int i = pf(\"Zeus\"); // 错误，试图将void赋给nit } C++允许将一个函数指针转换为别的指针类型，但之后必须把得到的结果指针转换回它原来的类型，否则就会出现意想不到的情况： using P1 = int(*)(int*); using P2 = void(*)(void); void f(Pa pf){ P2 pf2 = reinterpret_cast\u003cP2\u003e(pf); pf2(); //可能发生严重错误 P1 pf1 = reinterpret_cast\u003cP1\u003e(f2); // 把pf2转换回来 int x = 7; int y = pf1(\u0026x); } ","date":"11-09","objectID":"/2022/c-%E5%87%BD%E6%95%B0/:6:0","series":["C++程序设计语言"],"tags":["常量表达式","函数指针","函数重载"],"title":"C++函数","uri":"/2022/c-%E5%87%BD%E6%95%B0/#函数指针"},{"categories":["C++学习"],"content":"其他运算符","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:1:0","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#其他运算符"},{"categories":["C++学习"],"content":"逻辑运算符逻辑运算符\u0026\u0026、||和！接受算数类型以及指针类型的运算对象。将其转换成bool类型。最后返回一个bool类型的结果。只有当逻辑上确实需要时，\u0026\u0026和||才会对第二个实参求值。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:1:1","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#逻辑运算符"},{"categories":["C++学习"],"content":"位逻辑运算符位逻辑运算符\u0026,|,^,~,»,«作用域整型对象，即char、short、int、long、long long以及对应的unsigned版本，以及bool、wchar_t、char16_t和char32_t等类型。一个普通的enum(非enum class)可被隐式的转换成整数类型，从而作为位逻辑运算符的运算对象。算数类型转换决定了结果的类型。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:1:2","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#位逻辑运算符"},{"categories":["C++学习"],"content":"条件表达式某些if语句可以改写成条件表达式： if(a \u003c= b) max = b; else max = a; 可以改写为： max = (a \u003c= b) ? b : a; 条件表达式能用在常量表达式中。 在条件表达式c?e1:e2中使用一堆可选的表达式e1和e2，这对表达式的类型必须相同，或者它们都能一是的转换成同一种类型T。对于算数类型来说，可使用常规的算数类型转换和规则找到公共类型T；对于其他表达式，要求e1能隐式转换成e2的类型，或者e2能隐式转换成e1的类型。此外，throw表达式也能作为条件表达式的一个分支： void fct(int* p) { int i = (p) ? p : std::runtime_error{\"unexpected nullptr}; } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:1:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#条件表达式"},{"categories":["C++学习"],"content":"递增与递减++和–既可以作为前缀运算符，也可以作为后缀运算符。++x的值时x的新值(递增后的值)，y=++x等价于y=(x=x+1)。相反，x++是x的旧值，y=x++等价于y=(t=x,x=x+a,t)。 当++和–作用于指针时，将会直接操作指针所指数组中的元素，p++令p指向下一个元素。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:1:4","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#递增与递减"},{"categories":["C++学习"],"content":"自由存储new分配的对象“位于自由存储之上”。 struct Enode{ Token_value oper; Enode* left; Enode* right; }; Enode* expr(bool get) { Enode* left = term(get); for(;;){ switch(ts.current().kind){ case Kind:➕ case Kind:➖ left = new Enode{ts.currert().kind,left,term(true)}; break; default: return left; } } } 在Kind::plus和Kind::minus分支中，在自由存储上新建一个Enode并将其初始化为{ts.currert().kind,left,term(true)}。所得的指针赋给left并最终从expr()返回回来。 使用{}列表的形式传递实参，也可以使用传统的()列表形式指定初始化器。但是，如果使用符号=初始化一个用new创建的对象，会引发程序错误： int* p = new int = 7; 如果某一类型含有默认构造函数，则可以省略掉初始化器。但是如果对内置类型这么做，变量就会处于未初始化的状态： auto pc new complex\u003cdouble\u003e; //初始化为{0,0} auto pi = new pi; //未被初始化 最好使用{}，这样可以确保变量执行默认初始化： auto pc new complex\u003cdouble\u003e{}; //初始化为{0,0} auto pi = new pi{}; //初始化为0 代码生成器先使用expr()创建的Enode，然后将其删除： void generate(Enode* n) { switch(n-\u003eoper){ case Kind:➕ //.. delete n; } } 对于一个用new创建的对象来说，必须使用delete显式的将它销毁，只有将其销毁，它占用的空间才能被其他new使用。 delete运算符只能作用于new返回的指针或nullptr。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:2:0","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#自由存储"},{"categories":["C++学习"],"content":"内存管理自由存储的问题包括： 对象泄漏：使用new，但是忘了用delete释放掉。 提前释放：在尚有其他指针指向该对象并且后续仍会使用对象的情况下过早的delete。 重复释放：同一对象被释放两次。 提前释放可能造成难以想象的影响： int* p1 = new int{99}; int* p2 = p1; delete p1; //此时p2所指的不是有效对象 p1 = nullptr; char* p3 = new char{'x'}; //此时p3可能指向p2 *p2 = 999; // 该行可能错误 cout \u003c\u003c *p3 \u003c\u003c '\\n'; //输出内容不是x 重复释放的问题在于资源管理器通常无法追踪资源的所有者： void sloppy{} { int* p = new int[1000]; delete[] p; delete[] p; } 在第二的delete时，*p的内存区域可能被重新分配，此时重新分配的内容可能受到影响。 有两种方法可以避免上述问题： 除非万不得已不要把对象放在自由存储上，优先使用作用域内的变量。 在自由存储上构建对象时，把它的指针放在一个管理器对象中，此类对象通常含有一个析构函数，可以确保释放资源。如string，vector等标准库容器。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:2:1","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#内存管理"},{"categories":["C++学习"],"content":"数组new还能用来创建对象的数组： char* save_string(const char* p) { char* s = new char[strlen(p)+1]; strcpy(s,p); return s; } int main(int argc, char* argv[]) { if(argc \u003c 2) exit(1); char* p = save_string(argv[1]); delete[] p; } 普通的delete用于删除单个对象，delete[]负责删除数组。 除非必须直接使用char*，否则一般情况下，标准库string是更好地选择，它可以简化save_string(): string save_string(const char* p) { return string{p}; } int main(int argc, char* argv[]) { if(argc \u003c 2) exit(1); string s = save_string(argvp[1]); } 不必再纠结new[]和delete[]。 delete和delete[]必须清楚分配的对象有多大，才能准确释放new分配的空间。这意味着用new的标准实现分配的对象要比静态对象所占的空间稍大一点。超出的部分至少要容的下对象的尺寸。 vector本身就是一个对象，因此可以使用普通的new和delete分配和释放vector： void f(int n){ vector\u003cint\u003e* p = new vector\u003cint\u003e(n); int* 1 = mew int[n]; delete p; delete[] q; } delete[]只能用于两种情况，一种是指向由new创建的数组的指针，另一种是空指针。 不要用new创建局部对象： void f1{} { X* p = new X; delete p; } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:2:2","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#数组"},{"categories":["C++学习"],"content":"获取内存空间自由存储运算符new、delete、new[]和delete[]的实现位于\u003cnew\u003e头文件中： void* operator new(size_t); //为单个对象分配空间 void* operator delete(void* p); //如果p为真，释放new()分配的全部空间 void* operator new[](size_t); //为数组分配空间 void operator delete[](void* p); //如果p为真，释放new[]()分配的所有空间 当运算符new需要为对象分配空间时，调用operator new()分配适量的字节。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:2:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#获取内存空间"},{"categories":["C++学习"],"content":"重载new默认情况下，new运算符在自由存储上创建它的对象。如果想在别的地方分配对象： class X{ public: X(int); }; 如果想把对象放置在别的地方，可以提供一个含有额外实参的分配函数，然后在使用new的时候传入指定的额外实参： void* operator new(size_t,void* p){return p;} //显式运算符，将对象置于别处 void* buf = reinterpret_cast\u003cvoid*\u003e(0xF00F); //一个明确的地址 X* p2 = new(buf) X; //在buf处构建X 通常把提供额外的实参给operator new()的new(buf) X语法称为放置语法。每个operator new()都接受一个尺寸作为它的第一个实参，而该尺寸的对象时隐式提供的。每个perator new()都以size_t作为它的第一个实参： void* operator new(size_t sz,void* p) noexcept; //将大小为sz的对象置于p处 void* operator new[](size_t sz,void* p) noexcept; //将大小为sz的对象置于p处 void* operator delete(void* p,void*) noexcept; //若p为真，令*p无效 void* operator delete[](void* p,void*) noexcept; //若p为真，令*p无效 放置式new还能从某一特定区域分配内存： class Arena{ public: virtual void* alloc(size_t) = 0; virtual void free(void*) = 0; }; void operator new(size_t sz, Arena* a) { return a -\u003e alloc(sz); } 现在能在不同的Arena里分配任意类型的对象： extern Arena* Persistent; extern Arena* Shared; void g(int i){ X* p = new(Persistent) X(i); //在某持续性存储上分配X X* 1 = new(Shared) X(i); //在共享内存上分配X } nothrow new有的程序不允许出现异常，此时，可以使用nothrow的new和delete： void f(int n){ int* p = new(nothrow) int[n]; if(p == nullptr){ //... } operator delete(nothrow,p); //释放*p } 如果没能分配到有效的内存，上面的operator new不会抛出bad_alloc，而是返回一个nullptr。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:2:4","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#重载new"},{"categories":["C++学习"],"content":"重载new默认情况下，new运算符在自由存储上创建它的对象。如果想在别的地方分配对象： class X{ public: X(int); }; 如果想把对象放置在别的地方，可以提供一个含有额外实参的分配函数，然后在使用new的时候传入指定的额外实参： void* operator new(size_t,void* p){return p;} //显式运算符，将对象置于别处 void* buf = reinterpret_cast(0xF00F); //一个明确的地址 X* p2 = new(buf) X; //在buf处构建X 通常把提供额外的实参给operator new()的new(buf) X语法称为放置语法。每个operator new()都接受一个尺寸作为它的第一个实参，而该尺寸的对象时隐式提供的。每个perator new()都以size_t作为它的第一个实参： void* operator new(size_t sz,void* p) noexcept; //将大小为sz的对象置于p处 void* operator new[](size_t sz,void* p) noexcept; //将大小为sz的对象置于p处 void* operator delete(void* p,void*) noexcept; //若p为真，令*p无效 void* operator delete[](void* p,void*) noexcept; //若p为真，令*p无效 放置式new还能从某一特定区域分配内存： class Arena{ public: virtual void* alloc(size_t) = 0; virtual void free(void*) = 0; }; void operator new(size_t sz, Arena* a) { return a - alloc(sz); } 现在能在不同的Arena里分配任意类型的对象： extern Arena* Persistent; extern Arena* Shared; void g(int i){ X* p = new(Persistent) X(i); //在某持续性存储上分配X X* 1 = new(Shared) X(i); //在共享内存上分配X } nothrow new有的程序不允许出现异常，此时，可以使用nothrow的new和delete： void f(int n){ int* p = new(nothrow) int[n]; if(p == nullptr){ //... } operator delete(nothrow,p); //释放*p } 如果没能分配到有效的内存，上面的operator new不会抛出bad_alloc，而是返回一个nullptr。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:2:4","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#nothrow-new"},{"categories":["C++学习"],"content":"列表{}列表的表现形式有两种： 限定为某种类型，形如T{…}，意为创建一个T类型的对象并用T{…}初始化它。 未限定的{…}，类型根据上下文确定。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:3:0","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#列表"},{"categories":["C++学习"],"content":"实现模型{}列表的实现模型由三部分组成： 如果{}列表被用作构造函数的实参，则其实现过程与使用()列表类似。 如果{}列表被用于初始化一个聚合体(一个数组或一个为提供构造函数的类)的元素，则列表的每个元素分别初始化聚合体中的一个元素。 如果{}列表被用于构建一个initializer_list对象，则列表的每个元素分别初始化initializer_list的底层数组的一个元素。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:3:1","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#实现模型"},{"categories":["C++学习"],"content":"限定列表把初始化器列表用作表达式的基本思想是：如果能用T x{v};初始化一个变量x，那么也能用T{v}或new T{v}的形式创建一个对象并将其当成一条表达式。 struct S{int a,b;}; void f(){ S v{7,8}; //直接初始化一个变量 v = S{7,8}; //用限定列表进行赋值 S* p = new S{7,8}; //使用限定列表在自由存储上构建对象 } 使用限定列表构建对象与直接初始化的规则相同。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:3:2","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#限定列表"},{"categories":["C++学习"],"content":"未限定列表当我们明确知道所用类型时，可以使用未限定列表。它只能被用作一条表达式，并且仅限于以下场景： 函数实参 返回值 赋值运算符的右侧运算对象 下标 例如： int f(double d, Matrix\u0026 m) { int v{7}; //直接初始化 int v2 = {7}; //拷贝初始化 int v3 = m[{2,3}]; //假设m接受一个值作为其下标 v = {8}; //赋值运算的右侧运算对象 v += {88}; //赋值运算的右侧运算对象 {v} = 9; //错误，不能作为赋值运算的左侧运算对象 v = 7+{10}; //错误，不能作为赋值运算的左侧运算对象 f({10.0}); //函数实参 return {11}; //返回值 } {}列表是处理同质、变长列表最简单的方法，但是注意0个元素的情况是例外。此时，应该使用默认的构造函数。 只有当{}列表的所有元素类型相同时，才能推断该列表的类型： auto x0 = {}; //错误，缺少元素 auto x1 = {1}; //initializer_list\u003cint\u003e auto x2 = {1,2}; //initializer_list\u003cint\u003e auto x3 = {1,2,3}; //initializer_list\u003cint\u003e auto x4 = {1,2.0}; //错误，元素类型不相同 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:3:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#未限定列表"},{"categories":["C++学习"],"content":"lambda表达式lambda表达式也称未lambda函数。是定义和使用匿名函数的一种简便方式。 一条lambda表达式包含以下组成要件： 一个可能为空的捕获列表，指明定义环境中哪些名字能被用在lambda表达式内，以及这些名字的访问方式是拷贝还是引用。 一个可选的参数列表，指明lamdba表达式所需的参数。 一个可选的mutable修饰符，指明该lamdba表达式可能会修改它自身的状态。 一个可选的noexcept修饰符。 一个可选的-\u003e形式的返回类型声明。 一个表达式体，指明要执行的代码。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:0","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#lambda表达式"},{"categories":["C++学习"],"content":"实现模型如果把lambda表达式看成是一种定义并使用函数对象的便捷方式： void print_modulo(const vector\u003cint\u003e\u0026 v,ostream\u0026 os, int m) { for_each(begin(v),end(v), [\u0026os,m](int x){if(x%m==0) os \u003c\u003c x \u003c\u003c '\\n';} ); } 上述函数等价于 class Modulo_print{ ostream\u0026 os; int m; public: Modulo_print(ostream\u0026 s, int mm:os(s),m(mm)){} void operator(int x)const {if(x%m==0) os \u003c\u003c x \u003c\u003c '\\n';} }; lambda的主体部分变为了operator()()的函数体。因为lambda并不返回值，所以operator()()是void。默认情况下，operator()()是const，因此在lambda内部无法修改捕获的变量。 把由lambda生成的类的对象称为闭包对象： void print_modulo(const vector\u003cint\u003e\u0026 v,ostream\u0026 os, int m) { for_each(begin(v),end(v),Modulo_print{os,m}); } 如果lambda通过引用捕获它的每个局部变量，则其闭包对象可以油画成简单地包含一个指向外层栈框架的指针。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:1","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#实现模型-1"},{"categories":["C++学习"],"content":"lambda的替代品很多lambda表达式很小且只用一次。此时，最一种比较现实的做法是定义一个局部类，并且定义的位置就在使用之前： void print_modulo(const vector\u003cint\u003e\u0026 v,ostream\u0026 os, int m) { class Modulo_print{ ostream\u0026 os; int m; public: Modulo_print(ostream\u0026 s, int mm:os(s),m(mm)){} void operator(int x)const {if(x%m==0) os \u003c\u003c x \u003c\u003c '\\n';} }; for_each(begin(v),end(v),Modulo_print{os,m}); } 与之相比，使用lambda明显更优，如果确需一个名字，就命名为lambda： void print_modulo(const vector\u003cint\u003e\u0026 v,ostream\u0026 os, int m) { auto Modulo_print = [\u0026os,m](int x){if(x%m==0) os \u003c\u003c x \u003c\u003c '\\n';}; for_each(begin(v),end(v),Modulo_print); } 可泛化print_modulo()，令其可以处理更多的容器类型： template\u003cclass C\u003e void print_modulo(const C\u0026 v, ostream\u0026 os, int m) { for(auto x:v) if(x %m == 0) os \u003c\u003c x \u003c\u003c '\\n'; } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:2","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#lambda的替代品"},{"categories":["C++学习"],"content":"捕获lambda的主要用途是封装一部分代码以便将其用作参数。lambda允许我们“内联的”这么做，而无须命名一个函数然后在别处使用它。有些lambda无须访问它的局部环境，这样的lambda使用空引入符[]定义: void algo(vector\u003cint\u003e\u0026 v) { sort(v.begin(),v.end()); //排列值 sort(v.begin(),v.end(),[](int x,int y){return abs(x) \u003c ans(y);}); //排列绝对值 } 如果需要访问局部名字，就必须明确指出，否则会产生错误： void f(vector\u003cint\u003e\u0026 v) { bool sensitive = true; sort(v.begin(),v.end(),) [](int x,int y){return sensitive ? x \u003c y : abs(x) \u003c ans(y);} // 错误，无权访问 ; } 对于一条lambda表达式来说，它的第一个字符永远是[。lambda引入符的形式有很多种： []：空捕获列表。lambda内部无法使用其外层上下文中的任何局部名字。 [\u0026]：通过引用隐式捕获。所有局部名字都能使用，所有局部变量都通过引用访问。 [=]：通过值隐式捕获。所有局部名字都能使用，所有名字都指向局部变量的副本。 [捕获列表]：显式捕获；捕获列表是通过值或引用的方式捕获的局部变量的名字列表。以\u0026为前缀的变量名字通过引用捕获，其他变量通过值捕获，捕获列表中可以出现this，或紧跟…的名字以表示元素。 [\u0026,捕获列表]：对于名字没有出现在捕获列表中的局部变量，通过引用隐式捕获。捕获列表中可以出现this。列出的名字不能以\u0026为前缀。捕获列表中的变量名通过值的方式捕获。 [=,捕获列表]：对于名字没有出现在捕获列表中的局部变量，通过值隐式捕获。捕获列表中可以出现this。列出的名字不能以\u0026为前缀。捕获列表中的变量名通过值的方式捕获。 以\u0026为前缀的局部名字总是通过引用捕获，相反，不义\u0026为前缀的局部名字总是通过值捕获。只有通过引用的捕获允许修改调用环境中的变量。 lambda与生命周期lambda的生命周期可能比它的调用者长。当把lambda传递给另外一个线程或者被调用者把lambda存在别处以供后续使用时，这种情况就会发生： void setup(Menu\u0026 m) { Point p1,p2,p3; m.add(\"draw triangle\",[\u0026]{m.draw(p1,p2,p3)};); } 如果lambda的生命周期可能比调用者长，就必须确保所有局部信息都被拷贝到闭包对象中，并且这些值应该通过return机制或者适当的实参返回： m.add(\"draw triangle\",[=]{m.draw(p1,p2,p3)};); 名字空间名字因为名字空间变量(包括全局变量)永远是可访问的，所以无须“捕获”它们。 lambda与this当lambda被用在成员函数中时，我们将this添加到捕获列表中，这样类的成员就位于可被捕获的名字集合中了： class Request{ function\u003cmap\u003cstring,string\u003e(const map\u003cstring,string\u003e\u0026)\u003e oper; //操作 map\u003cstring,string\u003e values; //参数 map\u003cstring,strign\u003e results; //结果 public: Request(const string\u0026 s); void execute() { [this](){return=oper(values);} //根据结果执行相应操作 } }; 成员通过引用的方式捕获。也就是说，[this]意味着成员是通过this访问，而非拷贝到lambda中。 mutable的lambda生成的函数对象的operator()()是一个const成员函数。只有在极少数情况下，如果确实希望修改状态，则可以把lambda声明成mutable的： void algo(vector\u003cint\u003e\u0026 v) { int count = v.size(); std::generate(v.begin(),v.end(), [count]()mutable{return --count;} ); } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#捕获"},{"categories":["C++学习"],"content":"捕获lambda的主要用途是封装一部分代码以便将其用作参数。lambda允许我们“内联的”这么做，而无须命名一个函数然后在别处使用它。有些lambda无须访问它的局部环境，这样的lambda使用空引入符[]定义: void algo(vector\u0026 v) { sort(v.begin(),v.end()); //排列值 sort(v.begin(),v.end(),[](int x,int y){return abs(x) \u0026 v) { bool sensitive = true; sort(v.begin(),v.end(),) [](int x,int y){return sensitive ? x (const map\u0026) oper; //操作 map values; //参数 map results; //结果 public: Request(const string\u0026 s); void execute() { [this](){return=oper(values);} //根据结果执行相应操作 } }; 成员通过引用的方式捕获。也就是说，[this]意味着成员是通过this访问，而非拷贝到lambda中。 mutable的lambda生成的函数对象的operator()()是一个const成员函数。只有在极少数情况下，如果确实希望修改状态，则可以把lambda声明成mutable的： void algo(vector\u0026 v) { int count = v.size(); std::generate(v.begin(),v.end(), [count]()mutable{return --count;} ); } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#lambda与生命周期"},{"categories":["C++学习"],"content":"捕获lambda的主要用途是封装一部分代码以便将其用作参数。lambda允许我们“内联的”这么做，而无须命名一个函数然后在别处使用它。有些lambda无须访问它的局部环境，这样的lambda使用空引入符[]定义: void algo(vector\u0026 v) { sort(v.begin(),v.end()); //排列值 sort(v.begin(),v.end(),[](int x,int y){return abs(x) \u0026 v) { bool sensitive = true; sort(v.begin(),v.end(),) [](int x,int y){return sensitive ? x (const map\u0026) oper; //操作 map values; //参数 map results; //结果 public: Request(const string\u0026 s); void execute() { [this](){return=oper(values);} //根据结果执行相应操作 } }; 成员通过引用的方式捕获。也就是说，[this]意味着成员是通过this访问，而非拷贝到lambda中。 mutable的lambda生成的函数对象的operator()()是一个const成员函数。只有在极少数情况下，如果确实希望修改状态，则可以把lambda声明成mutable的： void algo(vector\u0026 v) { int count = v.size(); std::generate(v.begin(),v.end(), [count]()mutable{return --count;} ); } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#名字空间名字"},{"categories":["C++学习"],"content":"捕获lambda的主要用途是封装一部分代码以便将其用作参数。lambda允许我们“内联的”这么做，而无须命名一个函数然后在别处使用它。有些lambda无须访问它的局部环境，这样的lambda使用空引入符[]定义: void algo(vector\u0026 v) { sort(v.begin(),v.end()); //排列值 sort(v.begin(),v.end(),[](int x,int y){return abs(x) \u0026 v) { bool sensitive = true; sort(v.begin(),v.end(),) [](int x,int y){return sensitive ? x (const map\u0026) oper; //操作 map values; //参数 map results; //结果 public: Request(const string\u0026 s); void execute() { [this](){return=oper(values);} //根据结果执行相应操作 } }; 成员通过引用的方式捕获。也就是说，[this]意味着成员是通过this访问，而非拷贝到lambda中。 mutable的lambda生成的函数对象的operator()()是一个const成员函数。只有在极少数情况下，如果确实希望修改状态，则可以把lambda声明成mutable的： void algo(vector\u0026 v) { int count = v.size(); std::generate(v.begin(),v.end(), [count]()mutable{return --count;} ); } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#lambda与this"},{"categories":["C++学习"],"content":"捕获lambda的主要用途是封装一部分代码以便将其用作参数。lambda允许我们“内联的”这么做，而无须命名一个函数然后在别处使用它。有些lambda无须访问它的局部环境，这样的lambda使用空引入符[]定义: void algo(vector\u0026 v) { sort(v.begin(),v.end()); //排列值 sort(v.begin(),v.end(),[](int x,int y){return abs(x) \u0026 v) { bool sensitive = true; sort(v.begin(),v.end(),) [](int x,int y){return sensitive ? x (const map\u0026) oper; //操作 map values; //参数 map results; //结果 public: Request(const string\u0026 s); void execute() { [this](){return=oper(values);} //根据结果执行相应操作 } }; 成员通过引用的方式捕获。也就是说，[this]意味着成员是通过this访问，而非拷贝到lambda中。 mutable的lambda生成的函数对象的operator()()是一个const成员函数。只有在极少数情况下，如果确实希望修改状态，则可以把lambda声明成mutable的： void algo(vector\u0026 v) { int count = v.size(); std::generate(v.begin(),v.end(), [count]()mutable{return --count;} ); } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#mutable的lambda"},{"categories":["C++学习"],"content":"调用和返回向lambda传递参数的规则和向函数传递参数是一样的，从lambda返回结果也是如此。有两点需要注意： 如果一条lambda表达式不接任何参数，则其参数列表可以被忽略。因此，lambda表达式的最简形式是[]{}。 lambda表达式的返回类型能由lambda表达式本身推断得到。 如果在lambda的主体部分不包含return语句，则该lambda的返回类型是void。如果lambda的主体部分只包含一条return语句，则该lambda的返回类型宁国市该return表达式的类型。其他情况下，必须显式的提供一个返回类型： void g(double y) { [\u0026]{f(y);} //返回类型是void auto z1 = [=](int x){return x+y;} //返回类型是double auto z2 = [=,y]{if (y) return 1;else return 2;} //错误，lambda主体部分过于复杂，无法推断其类型 auto z3 = [y](){return 1:2;} // 返回类型是int auto z4 = [=,y]()-\u003eint{if (y) return 1;else return 2;} //OK，显式的返回类型 } ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:4","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#调用和返回"},{"categories":["C++学习"],"content":"lambda的类型任意两个lambda类型都不相同，一旦两个lambda具有相同的类型，模板实例化机制就无法辨识它们了。lambda是一种局部类类型，含有一个构造函数以及一个const成员函数operator()()。lambda除了能作为参数外，还能用于初始化一个声明为auto或std::function\u003cR(AL)\u003e的变量。其中R是lambda的返回类型，AL是它的类型参数列表。 例如，编写一个能更改C风格字符串中字符的lambda： auto rev = [\u0026rev](char* b, char* e){ if(1\u003ce-b){swap(*b,*--e);rev(++b,e);} }; 然而，由于无法推断出一个auto变量的类型之前使用它，因此上面的写法行不通。相反，应该先引入一个新名字，然后使用它： void f(string\u0026 s1, string\u0026 s2) { function\u003cvoid(char* b,char* e)\u003e rev = [\u0026](char* b,char* e){ if(1\u003ce-b){swap(*b,*--e);rev(++b,e);}}; rev(\u0026s1[0],\u0026s1[0]+s1.size()); rev(\u0026s2[0],\u0026s2[0]+s2.size()); } 这样就可以确保在使用rev之前知道它的类型。 如果只想给lambda起个名字，而不递归的使用它，则可以考虑使用auto： void f(vector\u003cstring\u003e\u0026 vs1, vector\u003cstring\u003e\u0026 vs2) { auto rev = [\u0026](char* b,char* e){ if(1\u003ce-b){swap(*b,*--e);rev(++b,e);}}; rev(\u0026s1[0],\u0026s1[0]+s1.size()); rev(\u0026s2[0],\u0026s2[0]+s2.size()); } 如果一个lambda什么也不捕获，则可以将它赋值给一个指向正确类型的指针： double(*p1)(double) = [](double a){return sqrt(a);}; double(*p2)(double) = [\u0026](double a){return sqrt(a);}; //错误，lambda捕获了内容 double(*p3)(int) = [](int a){return sqrt(a);}; //错误，参数类型不匹配 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:4:5","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#lambda的类型"},{"categories":["C++学习"],"content":"显式类型转换C++提供多种显式类型转换的操作，这些操作在便利程度以及安全性上都有所不同： 构造，使用{}符号提供对新值类型安全的构造。 命名的转换，提供不同等级的类型转换： const_cast,对某些声明为const的对象获得写入的权利 static_cast，反转一个定义良好的隐式类型转换 reinterpret_cast，改变位模式的含义 dynamic_cast，动态的检查类层次的关系 C风格的转换，提供命名的类型转换或其组合 函数化符号，提供C风格转换的另一种形式 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:5:0","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#显式类型转换"},{"categories":["C++学习"],"content":"构造用值e构建一个类型为T的值可以表示为T{e}： auto d1 = double{2}; double d2 {double{2}/4}; 符号T{v}有一个好处是，它只执行“行为良好的”；类型转换： void f(int); void f(double); void g(int i, double d) { f(i); //调用f(int) f(double{i}); //错误，{}拒绝执行整数向浮点数的类型转换 f(d); //调用f(double) f(int{d}); //错误，{}拒绝截断的行为 f(static_cast\u003cint\u003e(d)); //调用f(int)，传入的是个截断的值 f(round(d)); //调用f(double)，传入的是个四舍五入的值 f(static_cast\u003cint\u003e(lround(d))); //调用f(int)，传入的是个四舍五入的值 // 如果round(d)溢出int的范围，它仍会被截断 } 一旦在程序中使用目标类型作为显式的限定，则在这种情况下就不允许行为不正常的类型转换： void g2(char* p) { int x = int{p}; //错误，不存在char*向int的类型转换 using Pint = int*; int* p2 = Pint{p}; //错误，不存在char*向int*的类型转换 } 对T{v}来说，“行为非常良好”的含义是存在v向T的“非窄化”类型转换或者有一个T的类型正确的构造函数。 构造函数符号T{}用于表示类型T的默认值： template\u003cclass T\u003e void f(const T\u0026); void g3() { f(int{}); //默认的int值 f(complex\u003cdouble\u003e{}); 默认的complex值 } 对于内置类型来说，显式的使用其构造函数得到的值是该类型对应的0值。因此，int{}可以看成是0的另一种写法。对用户自定义类型T来说，如果含有默认构造函数，则T{}的结果由默认构造函数定义；否则，由每个成员的默认构造函数MT{}定义。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:5:1","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#构造"},{"categories":["C++学习"],"content":"命名转换 static_cast执行关联类型之间的转换，比如一种指针类型向同一个类层次中其他指针类型的转换，或者整数类型向枚举类型的转换，或浮点类型向整数类型的转换。还能执行构造函数和转换运算符定义的类型转换。 reinterpret_cast处理非关联类型之间的转换，比如整数向指针的转换以及指针向另一个非关联指针类型的转换。 const_cast，参与转换的类型尽在const修饰符及volstile修饰符上有所区别。 dynamic_cast执行指针或者引用向类层次体系的类型转换，并在运行时检查。 在决定使用显式类型转换之前，清华时间仔细考虑一下是否真的必须这么做。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:5:2","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#命名转换"},{"categories":["C++学习"],"content":"函数形式的转换用值e构建类型T的值的过程可以表示为函数形式的符号T(e): void f(double d) { int i = int(d); //截断 complex z = complex(d); //从d构建一个coplex } T(e)有时称为函数形式的转换，不幸的是，对于内置类型T来说，T(e)等价于(T)e，这意味着对大多数内置类型来说，T(e)并不安全： void f(double d, char* p) { int a = int(d); //截断 int b = int(p); //不可移植 } `` 即使是从一种较长的整数类型向较短的整数类型的显式转换也会导致不可移植的依赖于实现的行为。 ","date":"11-07","objectID":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/:5:3","series":["C++程序设计语言"],"tags":["运算符","lambda表达式","显式类型转换"],"title":"C++选择适当操作","uri":"/2022/c-%E9%80%89%E6%8B%A9%E9%80%82%E5%BD%93%E6%93%8D%E4%BD%9C/#函数形式的转换"},{"categories":["C++学习"],"content":"桌面计算器实例计算器包含四个部分：分析器、输入函数、符号表和驱动。实际上，它的功能类似一个微型编译器：其中分析器负责分析语法，输入函数负责处理输入及词法分析，符号表存放永久信息，驱动处理初始化、输出和错误。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#桌面计算器实例"},{"categories":["C++学习"],"content":"分析器下面是计算器程序遵循的一套语法： program: end //end是输入的结束 expr_list end expr_list: expression print //print是换行或分号 expression print expr_list expression: expression + term expression - term term term: term / primary term * primary primary primary: number //number是一个浮点型字面值常量 name //name是一个标识符 nae=expression - primary (expression) 换句话说，程序就是以分号隔开的一段表达式序列。表达式的基本单元是数字，名字以及运算符等。其中，名字不需要在使用之前提前声明。 此处使用的是递归下降语法分析机制，这是一种被广泛接受且含义明确的自顶向下技术。 在处理输入的环节，分析器使用Token_stream，它负责把读入字符的过程以及字符的组成情况封装到Token中。也就是说Token_stream的作用是“单词化”，负责把字符流转换成Token。其中Token是一个形如{单词类型，值}的对，在{数字，123.45}的例子中，123.45被转换成浮点数值。 Token的定义如下所示： enum class Kind:char{ name,number,end, plus='+', minus='-', mul='*',div='/', print=';', assign='=',lp='(', rp=')' }; struct Token{ Kind kind; srting string_value; double number_value; } 把每个单词表示成字符对应的整数形式是一种便捷有效的手段，有助于进行调试。 Token_stream接口的形式是： class Token_stream{ public: Token get(); //读取并返回下一单词 const Token\u0026 current(); //刚刚读入的单词 }; 每个分析函数接受一个名为get的bool类型实参，它指明函数是否需要调用Token_stream::get()以获取下一个单词。每个分析函数求值“它的”表达式并返回相应的值。函数expr()处理加法和减法，它包含一个循环，依次寻找加法和减法所需的项： double expr(bool get) { double left = term(get); for(;;){ //读作forever switch(ts.current().kind){ case Kind:➕ left += term(true); break; case Kind:➕ left -= term(true); break; default: return left; } } } C++规定赋值运算符可与下面的二元运算符一起使用： + - * / % \u0026 | ^ \u003c\u003c \u003e\u003e 因此，下面的赋值运算符都是合法的： = += -= *= /= %= \u0026= |= ^= \u003c\u003c= \u003e\u003e= 其中，^是异或运算符，«和»分别是左移和右移运算符。 函数term执行乘法和除法操作，其方式与expr()处理加法和减法的方式一样： double term(bool get) { double left = prim(get); for(;;){ //读作forever switch(ts.current().kind){ case Kind::nul: left *= term(true); break; case Kind::div: if(auto d = prim(true)){ left /= term(true); break; } return error(\"divide by 0\"); default: return left; } } } 除数为0的除法其结果是未定义的，通常会依法严重的程序错误。 当确实需要使用变量d并且立即对它进行初始化时，才会把该变量引入程序中。因此，仅当d不等于0时执行除法赋值语句left/=d。 函数prim()处理初等项的方式很像expr()和term()。因为需要进入调用层次的狭义层，所以在这里需要多做一点事情，而且不必使用循环： double term(bool get) { if(get) ts.get(); switch(ts.current().kind){ case Kind::number:{ double v = ts.current().number_value; ts.get(); break; } case Kind::name:{ double\u0026 v = tabel[ts.current().string_value]; if(ts.get().kind == Kind::assign) v = expr(true); return v; } case Kind:➖ return -prim(true); case kind::lp:{ auto e = expr(true); if(ts.get().kind != Kind::rp) return error(\"')'expected\"); ts.get(); return e; } default: return error(\"primary expected\"); } } 当发现Token是一个number时，它的值被置于它的number_value中。与之类似，当发现Token十一个name时，它的值被置于对应的string_value中。 相对于分析初等项表达式所需实际的Token数量来说，prim永远多读取一个。这是因为在某些情况下它必须这么做，因此从一致性的考虑除法，它干脆在所有的情况下都统一了起来。当分析函数只想移动到下一个Token时，它不需要使用ts.get()的返回值。此时，可以从ts.current获取结果。 在对某个名字执行具体操作前，计算器受限向前查看该名字是否被赋值或者只是从中读取了内容。两种情况下都要用到符号表，符号表的类型是map： map\u003cstring,double\u003e table; 也就是说，当table以string作为索引时，所得到的结果值是与该string对应的double。例如，假定用户的输入是： radius = 6378.388； 则计算器将进入case Kind::name并且执行 double\u0026 v = table[\"radius\"]; v = 6378.388; 引用v用于保存与radius关联的double，expr()从输入的字符序列计算得到值。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:1","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#分析器"},{"categories":["C++学习"],"content":"输入首先，给出Token_stream的完整定义： class Token_stream{ public: Token_stream(istream\u0026 s):ip{\u0026s},owns{false}{} Token_stream(istream* p):ip{p},owns{true}{} Token_stream(){close();} Token get(); Token\u0026 current(); void set_input(istream\u0026 s){close(); ip = \u0026s; owns=false;} void set_input(istream* p){close(); ip = p; owns=true;} private: void close(){if(owns) delete ip;} istream* ip; bool owns; Token ct{Kind::end}; } 我们用一个输入流初始化Token_stream，从该输入流中获取它的字符。Token_stream占有一个以指针方式传递的istream，而不是以引用的方式传递istream。当指针指向需要析构的资源，而这样的指针被包含在类的内部。 Token_stream保存三个值：一个指向其输入流的指针(ip)、一个用于指示输入流所有权的布尔值(ows)和当前的单词(gt)。 一开始的语句从*ip读取第一个非空白字符到ch，并且检查读取的操作是否成功： Token Token_stream::get(){ char ch = 0; *ip \u003e\u003e ch; switch(ch){ case 0: return ct={Kind::end}; 默认情况下，»运算符会跳过空白，并当输入操作失败时不更改ch的值。 表达式终结符、括号和匀速阿福的处理方式很简单，直接返回它们的值即可： case ';'; case '*'; case '/'; case '+'; case '-'; case '('; case ')'; case '='; return ct = {static_cast\u003cKind\u003e(ch)}; 因为在char和kind之间没有隐式类型转换规则，所以必须使用static_cast。 数字的处理方式是： case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':case '.': ip -\u003e putback(ch); *ip-\u003ect.number_value; ct.kind-Kind::number; return ct; 如果单词不是输入结束符、运算符、变电符号或者数字，则它必然是一个名字。处理名字的方式与数字类似： default: if(isalpha(ch)){ ip -\u003e putback(ch); *ip \u003e\u003e ct.string_value; ct,kind = Kind::name; return ct; } 最后，可嗯会得到一个错误。处理错误的一种简单但是有效的方法是调用error函数，然后返回一个print单词： error(\"bad token\"); return ct = {Kind::print}; 标准库函数isalpha()可以令我们不必把每个字符作为一个单独的case标签。»运算符在字符串内连续读取直到遇到一个空白符时停止。因此，在运算符使用某个名字作为它的运算对象之前，用户必须加上一个空白符表示名字的结束。 下面是完整的输入函数： Token Token_stream::get(){ char ch = ; *ip\u003e\u003ech; switch(ch){ case 0: return ct = {Kind::end}; case ';'; case '*'; case '/'; case '+'; case '-'; case '('; case ')'; case '='; return ct = {static_cast\u003cKind\u003e}; case '0':case '1':case '2':case '3':case '4':case '5':case '6':case '7':case '8':case '9':case '.': ip -\u003e putback(ch); *ip-\u003ect.number_value; ct.kind-Kind::number; return ct; default: if(isalpha(ch)){ ip -\u003e putback(ch); *ip \u003e\u003e ct.string_value; ct,kind = Kind::name; return ct; } error(\"bad token\"); return ct = {Kind::print}; } } ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:2","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#输入"},{"categories":["C++学习"],"content":"底层输入在函数get()中，用依次读取单个字符的方式替换面向类型的默认输入操作。 首先，用换行等价替代分号指示表达式的结束： Token Token_stream::get(){ char ch; do{ // 跳过除‘\\n之外的其他空白符’ if(!ip-\u003eget(ch)) return ct={Kind::end}; }while(ch != '\\n' \u0026\u0026 iaspace(ch)); } switch(ch){ case ';': case '\\n': return ct = {Kind::print}; do和while语句十分类似，唯一区别就是do循环的受控语句部分至少会执行一次。 当调用ip-\u003eget(ch)时，从输入流*ip读取一个字符存放到ch中。默认情况下，get()不会像»那样跳过空白符。如果cin中没有字符可供读取，则(!ip-\u003eget(ch))的条件满足；此例中，程序返回Kind::end以结束计算器的执行。 标准库函数isspace()提供对空白符的检测方法；如果c是一个空白字符，则isspace返回一个非零值，否则返回0.类似的检测函数还有isdigit()(是否是数字)、isalpha()(是否是字母和isalnum()(是否是字母或数字)。 跳过空白符后，下一个字符决定接下来的单词是什么类型。 \u003e\u003e运算符的机制是读取字符串的内容直到遇见空白符为止。为解决这一问题，我们每次只读取一个字符，当该字符不是字母或者数字时终止读取过程： default: //名字，名字=，或者错误 is(isalpha(ch)){ string_value = ch; while(ip-\u003eget(ch) \u0026\u0026 isalnum(ch)) string_value += ch; //把ch加到string_value末尾 ip-\u003eputback(ch); return ct={Kind::name}; } ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:3","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#底层输入"},{"categories":["C++学习"],"content":"错误处理error()函数负责统计错误数量、输出错误消息，然后返回： int no_of_errors; double error(const string\u0026 s){ no_of_errors++; cerr \u003c\u003c \"error:\" \u003c\u003c s \u003c\u003c '\\n'; return 1; } 其中，cerr是一个不带缓冲的输出流，常用于错误报告。 error()函数之所以要求要返回一个值是因为错误通常发生在表达式的求值过程中，所以，我们要么放弃整个求值过程，要么返回一个不会造成后续错误的值。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:4","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#错误处理"},{"categories":["C++学习"],"content":"驱动程序所有程序模块编写完成后，我们还需要一个驱动控制程序开始执行，其中main()负责启动程序及报告错误；calculate()负责完成实际的计算任务： Token_stream ts{cin}; void calculate(){ for(;;){ ts.get(); if(ts.current().kind == Kind::end) break; if(ts.current().print == Kind::end) continue; cout \u003c\u003c expr(false) \u003c\u003c '\\n'; } } int main(){ table[\"pi\"] = 3.14; table[\"e\"] = 2.71; calculate(); return no_of_errors; } 主循环的核心任务是读取表达式并输出答案，用下面的代码行来实现： cout \u003c\u003c expr(false) \u003c\u003c '\\n'; 实参false告诉expr()无须调用ts.get()来读取单词。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:5","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#驱动程序"},{"categories":["C++学习"],"content":"头文件 #include\u003ciostream\u003e#include\u003cstring\u003e#include\u003cmap\u003e#include\u003ccctype\u003e ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:6","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#头文件"},{"categories":["C++学习"],"content":"命令行参数main()被传入两个实参，分别是：argc指明实参的数量，argv代表实参的数组。argv的类型是char*[argc+1]。argv[0]表示程序的名字。因此argc的值至少是1.实参列表以0作为结束符，即，argv[argc]==0。 基本的思想是像从输入流读取数据一样读取命令行字符串的内容，从字符串湖区数据的流叫isstringstream： Token_stream ts {cin}; int main(int argc, char* argv[]){ switch(argc){ case 1: braek; case 2: ts.set_input(new isstringstream{argv[1]}); break; default: error(\"too many arguments\"); return 1; } table[\"pi\"] = 3.14; table[\"e\"] = 2.71; calculate(); return no_of_errors; } 为了便于传递和分发程序的实参，用一个简单地函数创建一个vector： vector\u003cstring\u003e arguments(int argc, char* argv[]){ vector\u003cstring\u003e res; for(int i = 0; i != argc; ++i) res.push_back(argv[i]); return res; } ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:7","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#命令行参数"},{"categories":["C++学习"],"content":"运算符概述","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#运算符概述"},{"categories":["C++学习"],"content":"结果算数运算符的结果类型由一组称为“常见算数类型转换”的规则决定。这些规则的基本目标是产生“最大的”运算对象类型的结果。例如，如果一个二元运算符由一个浮点型运算对象，则相应的运算基于浮点数运算规则执行，所得的结果也十一个浮点值。类似的，如果它有一个long运算对象，则运算基于长整型运算规则进行，所得结果是long。在开始执行运算前，尺寸小于int的运算对象先转换成int类型。 只要逻辑上说的通，对于接受左值运算对象的运算符来说，它的结果是一个表示该左值运算对象的左值： void f(int x,int y){ int j = x = y; //x=y的值是x在执行赋值运算之后的结果值 int* p = \u0026++x; //p指向x int* q = \u0026(x++); //错误：x++不是一个左值 int* p2 = \u0026(x\u003ey?x:y); //具有较大值的int的地址 int\u0026 r = (x\u003cy\u003e)?x:1; //错误，1不是左值 } 如果?:的第二个和第三个运算对象都是左值且类型相同，则该运算符的运算结果是同一个类型的左值。 sizeof的结果是名为size_t的无符号整数类型，该类型定义在\u003ccstddef\u003e中。两个指针相减的结果是名为ptrdiff_t的带符号整数类型，同样定义在\u003ccstddef\u003e中。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:1","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#结果"},{"categories":["C++学习"],"content":"求值顺序逗号运算符(,)，逻辑与运算符(\u0026\u0026)，逻辑或运算符(||)规定它们的左侧运算对象先被求值，然后才是右侧运算对象。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:2","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#求值顺序"},{"categories":["C++学习"],"content":"常量表达式 constexpr：编译时求值。 const：在作用域内不改变其值。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:0","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#常量表达式"},{"categories":["C++学习"],"content":"符号化常量常量最重要的一个用处是为值提供符号化的名字。这样可以起到把信息局部化的作用。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:1","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#符号化常量"},{"categories":["C++学习"],"content":"常量表达式中的constconst常用于表示接口。同时，const也可以表示常量值： const int x = 7; const string s = 'asdf'; const int y = sqrt(x); 以常量表达式初始化的const可以用在常量表达式中。与constexpr不同的是，const可以用非常量表达式初始化，但是此时该const将不能用作常量表达式： constexpr int xx = x; //OK constexpr string ss = s; //错误，s不是常量表达式 constexpr int yy = y; //错误，sqrt(x)不是常量表达式 发生错误的原因是string不是字面值常量类型，sqrt()不是一个constexpr函数。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:2","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#常量表达式中的const"},{"categories":["C++学习"],"content":"字面值常量类型在常量表达式中可以使用简单的用户自定义类型： struct Point{ int x,y,z; constexpr Point up(int d){return {x,y,z+d};} constexpr Point move(int dx,int dy){return {x+dx, y+dy};} }; 含有constexpr构造函数的类称为字面值常量类型。构造函数必须足够简单才能声明成constexpr，其中“简单”的含义是它的函数体必须为空且所有成员都是用潜在的常量表达式初始化的： constexpr Point origo{0,0}; constexpr int z = origo.x; constexpr Point a[]={ origo, Point{1,1},Point{2,2},origo.move(3,3) }; constexpr int x = a[1].x; //x值变为1 constexpr Point xy{0,sqrt(2)}; //错误，sqrt(2)不是常量表达式 即使把数组声明成constexpr，仍然能够访问该数组的元素及对象成员。 可以定义constexpr函数使其接受字面值常量类型的实参： constexpr int square(int x){ return x*x; } constexpr int radial_distance(Point p){ return isqrt(square(p.x)+square(p.y)+square(p.z)); } constexpr Point p1{10,20,30}; constexpr p2{p1.up(20)}; constexpr int dist = radial_distance(pa); 因为没有一个便于使用的constexpr浮点型平方根函数，所以用了int而非double。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:3","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#字面值常量类型"},{"categories":["C++学习"],"content":"引用参数=和+=等用于修改对象的操作不能是constexpr的。相反，real()和imag()等简单读取对象内容的操作可以是constexpr的，我们在编译时用一条给定的常量表达式对它们求值。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:4","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#引用参数"},{"categories":["C++学习"],"content":"隐式类型转换","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:0","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#隐式类型转换"},{"categories":["C++学习"],"content":"提升保护值不被改变的隐式类型转换通擦汗能够称为提升。在执行算数运算前，通常先把较短的整数类型通过整型提升成int。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:1","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#提升"},{"categories":["C++学习"],"content":"类型转换使用{}列表能防止窄化计算的发生： void f(double d){ char c{d}; //错误，编译器发现程序试图把双精度浮点数转换成字符类型 } 整数类型转换整数能被转换成其他整数类型。一个普通的枚举值也能转换成整数类型。 如果目标类型时unsigned的，则结果值所占的二进制位数以目标类型为准： unsigned char uc = 1023;//二进制1111111111:uc值变为二进制11111111，即255 如果目标类型是signed的，则当原值能用目标类型表示时，它不会发生改变；反之，结果值依赖于具体实现。 浮点数类型转换如果原值能用目标类型完整的表示，则所得的结果与原值相等。如果原值介于两个相邻的目标值之间，则结果取它们中的一个。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:2","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#类型转换"},{"categories":["C++学习"],"content":"类型转换使用{}列表能防止窄化计算的发生： void f(double d){ char c{d}; //错误，编译器发现程序试图把双精度浮点数转换成字符类型 } 整数类型转换整数能被转换成其他整数类型。一个普通的枚举值也能转换成整数类型。 如果目标类型时unsigned的，则结果值所占的二进制位数以目标类型为准： unsigned char uc = 1023;//二进制1111111111:uc值变为二进制11111111，即255 如果目标类型是signed的，则当原值能用目标类型表示时，它不会发生改变；反之，结果值依赖于具体实现。 浮点数类型转换如果原值能用目标类型完整的表示，则所得的结果与原值相等。如果原值介于两个相邻的目标值之间，则结果取它们中的一个。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:2","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#整数类型转换"},{"categories":["C++学习"],"content":"类型转换使用{}列表能防止窄化计算的发生： void f(double d){ char c{d}; //错误，编译器发现程序试图把双精度浮点数转换成字符类型 } 整数类型转换整数能被转换成其他整数类型。一个普通的枚举值也能转换成整数类型。 如果目标类型时unsigned的，则结果值所占的二进制位数以目标类型为准： unsigned char uc = 1023;//二进制1111111111:uc值变为二进制11111111，即255 如果目标类型是signed的，则当原值能用目标类型表示时，它不会发生改变；反之，结果值依赖于具体实现。 浮点数类型转换如果原值能用目标类型完整的表示，则所得的结果与原值相等。如果原值介于两个相邻的目标值之间，则结果取它们中的一个。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:2","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#浮点数类型转换"},{"categories":["C++学习"],"content":"指针和引用类型的转换任何指向对象类型的指针都能隐式的转换成void*。指向派生类的指针能隐式的转换成指向其可访问的且明确无二义的基类的指针。指向函数的指针和指向成员的指针不能隐式的转换成void*。 求值结果为0的常量表达式能隐式的转换成任意指针类型的空指针。类似的，求值结果为0的常量表达式也能隐式的转换成指向成员的指针类型： int* p = (1+2)*(2*(1-1)); 最好直接使用nullptr。 T*可以隐式地转换成const T*。类似的，T\u0026能隐式的转换成const T\u0026。 ","date":"10-31","objectID":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:3","series":["C++程序设计语言"],"tags":["运算符","常量表达式"],"title":"C++表达式","uri":"/2022/c-%E8%A1%A8%E8%BE%BE%E5%BC%8F/#指针和引用类型的转换"},{"categories":["C++学习"],"content":"结构数组是相同类型的集合，相反，struct是任意类型元素的集合： struct Address{ const char* name; int number; const char* street; const char* town; char state[2]; const char* zip; }; 声明Address类型的变量和声明其他类型变量的方式一模一样，可以用点运算符(.)为每个成员分别赋值： void f(){ Address jd; jd.name = \"Jim Dandy\"; jd.number = 61; } struct类型的变量能使用{}的形式初始化： Address jd = { \"Jim Dandy\", 61, \"South ST\", \"New Providence\", {'N','J'}, \"07974\" }; 不能用字符串\"NJ\"初始化jd.state。字符串以符号’\\0’结尾，因此“NJ”实际上包含3个字符。 通常使用-\u003e运算符访问结构的内容： void print_addr(Address* p){ cout \u003c\u003c p-\u003ename; } 如果p是一个指针，则p-\u003em等价于(*p).m。 除此之外，也能以引用的方式传递struct，并使用.运算符访问它： void print_addr2(const Address\u0026 r){ cout \u003c\u003c p.name; } 结构类型的对象可以被赋值、作为实参传入函数，或者作为函数的结果返回： Address current; Address set_current(Address next){ address prev = current; current = next; return prev; } ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:1:0","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#结构"},{"categories":["C++学习"],"content":"struce的名字类型名字只要一出现就能马上使用了，无须等到该类型的声明全部完成： struct Link{ Link* previous; }; 但是，只有等到struct的声明全部完成，才能声明它的对象： struct No_good{ No_good member; //错误，递归定义 }; 要想让两个或更多struct互相引用，必须提前声明好struct的名字： struct List; struct Link{ Link* pre; Link* suc; List* member_of; int data; }; struct List{ Link* head; }; 如果没有一开始声明List，则在稍后声明Link时使用List*类型的指针将造成错误。 可以在真正定义一个struct类型之前就使用它的名字，只要在此过程中不使用成员的名字和结构的大小就行。然而，直到struct的声明全部完成之前，它都是一个不完整的类型。 ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:1:1","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#struce的名字"},{"categories":["C++学习"],"content":"结构与类struct是一种class，它的成员默认是public的。struct可以包含成员函数，尤其是构造函数： struct Points{ vector\u003cPoint\u003e elem; Points(Point p0){elem.push_back(p0);} Points(Point p0, Points p1){elem.push_back(p0); elem.push_back(p1);} } Points x0; //错误，缺少默认构造函数 如果只是按照默认的顺序初始化结构的成员，则不需要专门定义一个构造函数： struct Points{ int x, y; } Points p0; //如果位于局部作用域中，则p0未初始化 Points p1{}; Points p2{1}; Points p3{1,2}; 如果需要改变实参的顺序、检验实参的有效性、修改实参或者建立不变式，则应该编写一个专门的构造函数。 struct Address{ const char* name; int number; const char* street; const char* town; char state[2]; const char* zip; Address(const string n, int nu, const string\u0026 s, const string\u0026 t, const string\u0026 st, int z); }; ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:1:2","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#结构与类"},{"categories":["C++学习"],"content":"结构与数组可以构建struct的数组，也可以让struct包含数组： struct Point{ int x,y; }; Point points[3]{{1,2},{3,4},{5,6}}; int x2 = points[2].x; struct Array{ Point elem[3]; }; Array points2 {{1,2},{3,4},{5,6}}; int y2 = points2.elem[2].y; 把内置数组置于struct内部意味着我们可以把数组当成一个对象来用，可以在初始化和赋值时直接拷贝struct： Array shift(Array a, Point b){ for(int i =0 ; i != 3; ++i){ a.elem[i].x += p.x; a.elem[i].y += p.y; } return a; } ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:1:3","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#结构与数组"},{"categories":["C++学习"],"content":"类型等价对两个struct来说，即使它们的成员相同，它们本身仍是不同的类型。 ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:1:4","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#类型等价"},{"categories":["C++学习"],"content":"联合union是一种特殊的struct，它的所有成员都分配在同一个地址空间上。因此，一个union实际占用的空间大小与其最大的成员一样。自然的，在同一时刻union只能保存一个成员的值： enum Type{str, num}; struct Entry{ char* name; Type t; char* s; //如果t==str，使用s int i; //如果t==num，使用i }; void f(Entry* p){ if(p-\u003et == str) cout \u003c\u003c p-\u003es; } 在此例中，成员s和i永远不会被同时使用，因此空间被浪费了。我们可以把它们指定成union的成员，解决上述问题： union Value{ char* s; int i; }; ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:2:0","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#联合"},{"categories":["C++学习"],"content":"枚举枚举类型用于存放用户指定的一组整数值。枚举类型的每种取值各自对应一个名字，我们把这些值叫做枚举值： enum class Color{red, green, blue}; 上述代码定义了一个名为Color的枚举类型，它的枚举值时red、green和blue。“一个枚举\"简称”一个enum“。 枚举类型分为两种： enum class，它的枚举值名字（如red）位于enum的局部作用域内，枚举值不会隐式的转换成其他类型。 ”普通的enum“，它的枚举值名字与枚举类型本身位于同一个作用域中，枚举值隐式的转换成整数。 通常情况下，建议使用enum class，它很少会产生意料之外的结果。 ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:2:1","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#枚举"},{"categories":["C++学习"],"content":"enum classenum class是一种限定了作用域的强类型枚举： enum class Traffic_light{red, yellow, green}; enum class Warning{green,yellow,orange,red}; Warning a1 = 7; //错误：不存在int向Warning的类型转换 int a2 = green; //错误：green位于它的作用域之外 int a3 = Warning::green; //错误：不存在Warning向int的类型转换 Warning a4 = Warning::green; void f(Traffic_light x){ if(x == 9) //错误，9不是一个Traffic_light if(x == red) //错误，当前作用域中没有red if(x == Warning::red) //错误：x不是一个Warning if(x == Traffic_light::red) } 两个enum的枚举值不会互相冲突，它们位于各自enum class的作用域中。 枚举常用一些整数类型表示，每个枚举值是一个整数。我们把用于某个枚举的类型称为它的基础类型。基础类型必须是一种带符号或无符号的整数类型，默认是int，可以显式的指定： enum class Warning:int{green,yellow,orange,red}; //sizeof(Warning) == sizeof(int) 如果认为上述定义太浪费空间，可以用char代替int： enum class Warning:char{green,yellow,orange,red}; //sizeof(Warning) == 1 默认情况下，枚举值从0开始，依次递增： static_cast\u003cint\u003e(Warning::green)==0 static_cast\u003cint\u003e(Warning::yellow)==1 static_cast\u003cint\u003e(Warning::orange)==2 static_cast\u003cint\u003e(Warning::red)==3 有了Warning之后，用Warning变量代替普通的int变量使得用户和编译器都能更好地了解该变量的真正用途： void f(Warning key) { switch(key){ case Warning::green: //... case Warning:🍊 //... case Warning::red: //... break; } } 可以用整型常量表达式初始化枚举值： enum class Print_flags{ ackonwledge=1; paper_empty=2; busy=4; out_of_black=8; out_of_color=16; }; enum属于用户自定义的类型，因此可以为它定义|和\u0026运算符： constexpr Printer_flags operator|(Print_flags a, Print_flags b){ return static_cast\u003cPrint_flags\u003e(static_cast\u003cint\u003e(a)|static_cast\u003cint\u003e(b)) } constexpr Printer_flags operator\u0026(Print_flags a, Print_flags b){ return static_cast\u003cPrint_flags\u003e(static_cast\u003cint\u003e(a)\u0026static_cast\u003cint\u003e(b)) } 因为enum class不知吃隐式类型转换，所以必须在这里使用显式的类型转换： void try_to_print(Printer_flags x) { if(x\u0026Printer_flags::ackonwledge){ //... } else if(x\u0026Printer_flags::busy){ //... } else if(x\u0026(Printer_flags::out_of_black | Printer_flags::out_of_color)) } 将operator}()和operator\u0026()定义成constexpr函数，这样就能用于常量表达式： void g(Printer_flags x){ switch(x){ casse Printer_flags::out_of_black | Printer_flags::out_of_color: //... break; } } C++允许先声明一个enum class，稍后再给出定义： enum class Color_code:char; //声明 void foobar(Color_code* p); //使用声明 //... enum class Color_code:char{ //定义 ren,yellow,green,blue }; 一个整数类型的值可以显式的转换成枚举类型。如果这个值属于枚举的基础类型的取值范围，则转换是有效的；否则，如果超出了合理的表示范围，则转换的结果是未定义的: enum class Flag:char{x=1,y=2,z=4,e=8}; Flag f0{}; //f0默认值是0 Flag f1 = 5; //类型错误，5不属于Flag Flag f2 = Flag{5}; //错误。不许窄化成enum class Flag f3 = static_cast\u003cFlag\u003e(5); //不近人情的转换 Flag f4 = static_cast\u003cFlag\u003e(999); //错误，999不是一个char类型的值 因为绝大多数整数值根本不再某一枚举类型的合理表示范围之内，因此不允许从整数到枚举类型的隐式转换。 每个枚举值对应一个整数，我们可以显式的把整数抽取出来： int i = static_cast\u003cint\u003e(Flag::y); //i==2 char c = static_cast\u003cchar\u003e(Flag::e); //c == 8 对enum class执行sizeof的结果是对其基础类型执行sizeof的结果，如果没有显式的指定基础类型，则枚举类型的尺寸等于sizeof(int)。 ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:2:2","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#enum-class"},{"categories":["C++学习"],"content":"普通的enum“普通的enum”是指C++在提出enum class之前提供的枚举类型。普通的enum的枚举值位于enum本身所在的作用域中，它们隐式的转换成某些整数类型的值： enum Traffic_light{red, yellow, green}; enum Warning{green,yellow,orange,red}; //错误：yellow被重复定义(取值相同) //错误：red被重复定义(取值不同) Warning a1 = 7; //错误：不存在int向Warning的类型转换 int a2 = green; //ok：green位于其作用域中，隐式转换成int类型 int a3 = Warning::green; //OK：Warning向int的类型转换 Warning a4 = Warning::green; //OK void f(Traffic_light x){ if(x == 9) //OK(d但是Traffic_light不包含枚举值9) if(x == red) //错误，当前作用域中有两个red if(x == Warning::red) //OK if(x == Traffic_light::red) } 我们在同一个作用域的两个普通枚举中都定义了red，从而避免一个难以发现的错误。可以人为地消除枚举值的二义性，以实现对于普通enum的“清理”： enum Traffic_light{tl_red, tl_yellow, tl_green}; enum Warning{green,yellow,orange,red}; void f(Traffic_light x){ if(x == 9) //OK if(x == red) //OK if(x == Traffic_light::red) } //错误：red不是一个Traffic_light类型的值 从编译器角度来看，x==red是合法的，但它几乎肯定是一个程序缺陷。把名字注入外层作用域(当使用enum时会发生这种情况，但是使用enum class和class不会)的行为称为名字空间污染，在规模较大的程序中应避免这么做。 可以为普通的枚举指定基础类型，就像对enum class所做的一样。此时，允许先声明枚举类型，稍后再给出定义： enum Traffic_light:char{tl_red, tl_yellow, tl_green}; //基础类型是char enum Color_code:char; //声明 void foobar(Color_code* p); //使用声明 enum Color_code:char{green,yellow,orange,red}; //定义 如果没有指定枚举的基础类型，则不能把它的声明和定义分开。 ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:2:3","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#普通的enum"},{"categories":["C++学习"],"content":"未命名的enum一个普通的enum可以是未命名的： enum{arrow_up=1, arrow_down, arrow_sideways}; 如果只需要一组整型变量，而不是用于声明变量的类型，则可以使用未命名的enum。 ","date":"10-27","objectID":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/:2:4","series":["C++程序设计语言"],"tags":["结构","联合","枚举"],"title":"C++结构联合与枚举","uri":"/2022/c-%E7%BB%93%E6%9E%84%E8%81%94%E5%90%88%E4%B8%8E%E6%9E%9A%E4%B8%BE/#未命名的enum"},{"categories":["C++学习"],"content":"选择语句","date":"10-27","objectID":"/2022/c-%E8%AF%AD%E5%8F%A5/:1:0","series":["C++程序设计语言"],"tags":["语句","循环","选择"],"title":"C++语句","uri":"/2022/c-%E8%AF%AD%E5%8F%A5/#选择语句"},{"categories":["C++学习"],"content":"switch语句case分支中的声明C++允许在switch语句的块内声明变量，但是不能不初始化： void f(int i){ switch(i){ case 0: int x; //未初始化 int y = 3; //错误：程序可能跳过该声明（显式初始化） string s; //错误：程序可能跳过该声明（隐式初始化） } } 如果确实需要在switch语句中使用变量，最好把变量的声明和使用限定在一个块中。 ","date":"10-27","objectID":"/2022/c-%E8%AF%AD%E5%8F%A5/:1:1","series":["C++程序设计语言"],"tags":["语句","循环","选择"],"title":"C++语句","uri":"/2022/c-%E8%AF%AD%E5%8F%A5/#switch语句"},{"categories":["C++学习"],"content":"switch语句case分支中的声明C++允许在switch语句的块内声明变量，但是不能不初始化： void f(int i){ switch(i){ case 0: int x; //未初始化 int y = 3; //错误：程序可能跳过该声明（显式初始化） string s; //错误：程序可能跳过该声明（隐式初始化） } } 如果确实需要在switch语句中使用变量，最好把变量的声明和使用限定在一个块中。 ","date":"10-27","objectID":"/2022/c-%E8%AF%AD%E5%8F%A5/:1:1","series":["C++程序设计语言"],"tags":["语句","循环","选择"],"title":"C++语句","uri":"/2022/c-%E8%AF%AD%E5%8F%A5/#case分支中的声明"},{"categories":["C++学习"],"content":"条件中的声明要想避免不限因误用变量，最好的办法是把变量的作用域限定在一个较小的范围内。此外，应该尽量延迟局部变量的定义，直到能给他赋初值为止。 条件中的声明语句只能声明并初始化一个变量或const。 ","date":"10-27","objectID":"/2022/c-%E8%AF%AD%E5%8F%A5/:1:2","series":["C++程序设计语言"],"tags":["语句","循环","选择"],"title":"C++语句","uri":"/2022/c-%E8%AF%AD%E5%8F%A5/#条件中的声明"},{"categories":["C++学习"],"content":"循环语句","date":"10-27","objectID":"/2022/c-%E8%AF%AD%E5%8F%A5/:2:0","series":["C++程序设计语言"],"tags":["语句","循环","选择"],"title":"C++语句","uri":"/2022/c-%E8%AF%AD%E5%8F%A5/#循环语句"},{"categories":["C++学习"],"content":"退出循环break语句负责“跳出”最外层switch语句或循环语句。 当需要中途离开循环体的时候，可以使用break语句。通常情况下，应该让完整退出的条件位于while语句或for语句的条件部分。 有时候不想完全脱出循环，只想到达循环体的末尾。continue可以跳过循环语句循环体的剩余部分： void find_prime(vector\u003cstring\u003e\u0026 v){ for(int i = 0; i != v.size(); ++i){ if(!prime(v[i])) contiune; return v[i]; } } contiune之后继续执行递增循环变量的语句，然后检验昏眩条件是否满足。因此，find_prime()等价于下面的形式： void find_prime(vector\u003cstring\u003e\u0026 v){ for(int i = 0; i != v.size(); ++i){ if(!prime(v[i])){ return v[i]; } } } ","date":"10-27","objectID":"/2022/c-%E8%AF%AD%E5%8F%A5/:2:1","series":["C++程序设计语言"],"tags":["语句","循环","选择"],"title":"C++语句","uri":"/2022/c-%E8%AF%AD%E5%8F%A5/#退出循环"},{"categories":["C++学习"],"content":"指针对于类型T来说，T是表示“指向T的指针”的；类型。换句话说，T类型的变量能存放T类型对象的地址： char c = 'a'; char* p = \u0026c; //p存放c的地址 对指针的一个基本操作是解引用，即引用指针所指的对象。这个操作也称为间接取值。解引用运算符是个前置一元运算符，对应的符号是*： char c = 'a'; char* p = \u0026c; //p存放c的地址 char c2 = *p; // c2=='a' 当指针指向数组中的元素时，C++允许对这类指针执行某些算数运算。 符号*在用作类型名的的后缀时表示“指向”的含义。如果想表示指向数组的指针或指向函数的指针，需要使用稍微复杂一点的形式： int* pi; //指向int的指针 char** ppc; //指向字符指针的指针 int* ap[15]; //ap是一个指针，包含15个指向int的指针 int(*fp)(char*); //指向函数的指针，该函数接受一个char*实参，返回一个int int* f(char*); //该函数接受一个char*实参，返回一个指向int的指针 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:1:0","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#指针"},{"categories":["C++学习"],"content":"void*void*的含义是“指向未知类型对象的指针”。 除了函数指针和指向类成员的指针，指向其他任意类型对象的指针都能被赋给一个void*类型的变量。要想使用void*，必须将其显式的转换成某一特定类型的指针。 void f(int* pi) { void* pv = pi; //OK,int*到void*的隐式转换 *pv; //错误,不允许解引用void* ++pv; //错误,不允许对void*执行递增操作 int* pi2 = static_cast\u003cint*\u003e(pv); // 显式转换回int* double* pd1 = pv; //错误 double* pd2 = pi; //错误 double* pd3 = static_cast\u003cdouble*\u003e(pv); //不安全 } 一般情况下,如果某个指针已经被转换成指向一种与实际所指对象类型完全不同的新类型,则使用转换后的指针是不安全的行为。 void最主要的用途是当我们无法假定对象的类型时,向函数传递指向该对象的指针;他用与从函数返回未知类型的对象.要使用这样的对象,必须先进行显式类型转换。 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:1:1","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#void"},{"categories":["C++学习"],"content":"nullptr字面值常量nullptr表示空指针,即不指向任何对象的指针.我们可以将nullptr赋给其他任意指针类型,但是不能赋给其他内置类型: int* pi = nullptr; double* pd = nullptr; int i = nullptr; // 错误,i不是指针 nullptr只有一个,它可以用于任意指针类型。 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:1:2","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#nullptr"},{"categories":["C++学习"],"content":"数组数组中元素的数量必须是常量表达式.如果你希望边界可变,最好使用vector: voif f(int n) { int v1[n]; //错误,数组的大小不是常量表达式 vector\u003cint\u003e v2(n); //OK,包含n个int元素vector } C++允许静态的分配数组空间,也允许在栈上或在自由存储上分配数组空间: int a1[10]; // 静态存储中的10个int void f(){ int a2[10]; // 栈上的20个int int* p = new int[40]; // 自由存储上的40个int } ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:2:0","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#数组"},{"categories":["C++学习"],"content":"数组初始化器如果初始化器提供的元素数量不足,则系统自动把剩余的元素赋值为0: int v5[8] = {1, 2, 3, 4}; 等价于 int v5[] = {1, 2, 3, 4, 0, 0, 0, 0} 不允许用一个数组初始化另一个数组,因为数组不支持赋值操作: int v6[8] = v5; //错误,不允许拷贝数组(不允许把int*赋给数组) v6 = v5; //错误,不存在数组的赋值操作 同样,不允许以传值方式传递数组。 如果想给一组对象赋值,可以使用vector,array或valarry。可以只用字符串字面值常量初始化字符的数组。 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:2:1","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#数组初始化器"},{"categories":["C++学习"],"content":"字符串字面值常量字符串字面值常量是指双引号内的字符序列:“this is a string” 字符串字面值常量实际包含的字符数量比它表现出来的样子多一个,它以一个取值为0的空字符’\\0’结尾。 字符串字面值常量的类型是\"若干个const字符组成的数组\"。 如果希望字符串能被修改，最好把字符放在一个非常量的数组中： void f(){ char p = \"Zeno\"; p[0] = 'R'; //OK } 当符号==作用于指针时，比较的是地址而非指针所指的值。 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:2:2","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#字符串字面值常量"},{"categories":["C++学习"],"content":"数组中的指针数组名可以看成是指向数组首元素的指针： int v[] = {1,2,3,4}; int* p1 = v; //指向数组首元素的指针 int* p2 = \u0026v[0]; //指向数组首元素的指针 int* p3 = v+4; //指向数组尾后元素的指针 令指针指向数组的最后一个元素的下一个位置是有效的，不过，因为该指针事实上指向的并不是数组中的任何一个元素，所以不能对它进行读写操作。试图获取和使用数组首元素之前或尾元素之后的地址都是未定义的行为，应尽量避免： int* p4 = v-1; int* p5 = v+7; ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:2:3","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#数组中的指针"},{"categories":["C++学习"],"content":"数组漫游可以通过指向数组的指针加上一个索引值访问数组元素，也可以通过直接指向数组元素的指针进行访问： void fi(char v[]){ for(int i = 0; v[i] != 0; ++i) use(v[i]); } void fp(char v[]){ for(char* p = v; *p != 0; ++p) use(*p); } 前置*运算符执行解引用预算，因此p是指针p所指的字符，++元素按令p指向数组的下一个元素。 把+、-、++、–、等算数运算符用在指针上得到的结果依赖于指针所指对象的数据类型。当我们对T类型的指针p执行算数运算时，p指向T类型的数组元素，p+1指向数组的下一个元素，p-1指向数组的上一个元素，上述规则意味着p+1对应的整数值比p对应的整数值大sizeof(T)。 指针的减法只有当参与运算的两个指针指向的是同一数组的元素时才有效，如果指针指向的位置既不是原数组中的元素，也不是尾后元素，那我们不能使用它，否则会产生未定义行为： void f(){ int v1[10]; int v2[10]; int i1 = \u0026v1[5]-\u0026v1[3]; //i1 = 2 int i2 = \u0026v1[5]-\u0026v2[3]; // 结果是未定义的 int* p1 = v2+2; //p1=\u0026v2[2] int* p2 = v2-2; //*p2是未定义的 } 因为数组的元素数量不一定能与数组本身存储在一起，所以数组不具有自解释性。当我们需要遍历一个数组，必须以某种方式提供元素的数量： void fp(char v[], int size) { for(int i = 0; i != size; ++i) use(v[i]); for(int x:v) use(x); //错误，范围for循环对指针无效 const int N = 7; char v2[N]; for(int i = 0; i != N; ++i) use(v2[i]); for(int x:v2) use(x); // 当已知数组的大小时，可以使用范围for循环 } ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:2:4","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#数组漫游"},{"categories":["C++学习"],"content":"传递数组不能以值传递的方式直接把数组传给函数，通常传递的是指向数组首元素的指针： void comp(double arg[10]) { for(int i=0; i != 10; ++i) arg[i] += 99; } void f() { double a1[10]; double a2[5]; double a3[100]; comp(a1); comp(a2); //严重错误 comp(a3); //只用到前十个元素 } comp()函数的等价形式是： void comp(double* arg) { for(int i=0; i != 10; ++i) arg[i] += 99; } 如果想在给函数传入一组元素的同时不丢掉数组的大小，就不能使用内置数组类型。可以将数组放在类中作为类的成员，或者直接定义一个句柄类。 使用内置数组有百弊而无一利。当需要一个接受二维矩阵的函数时，如果编译时知道数组的具体唯独当然没有问题。 数组的第一个维度与定位元素无关，只负责指明当前类型（int[5]）包含几个元素(3)，只要知道第二个维度sec，就能定义任意的ma[i][sec]，此时，可以把数组的第一个唯独当成实参传入函数： void print_mi5(int m[][5], int dim1) { for(int i = 0; i != dim; i++){ for(int j = 0; j != 5; j++) cout \u003c\u003c m[i][j] \u003c\u003c endl; } } 但是当需要传入两个维度时，“显而易见的解决方案”并不有效： void print_mij(int m[][], int dim1， int dim2) { for(int i = 0; i != dim1; i++){ for(int j = 0; j != dim2; j++) cout \u003c\u003c m[i][j] \u003c\u003c endl; } } 因为多为数组的第二个维度必须是已知的，这样才能准确定位其中的元素。一种正确的解决方案是： void print_mij(int* m, int dim1， int dim2) { for(int i = 0; i != dim1; i++){ for(int j = 0; j != dim2; j++) cout \u003c\u003c m[i*dim2+j] \u003c\u003c endl; } } 要想使用该函数，我们只需传入一个代表矩阵的指针即可： int test(){ int v[3][5] = { {0,1,2,3,4},{10,11,12,13,14},{20,21,22,23,24} }; print_m35(v); print_mi5(v,3); print_mij(\u0026v[0][0],3,5); } 在最后一个调用中使用v[0][0]，此处使用v[0]也可以，因为它与v[0][0]等价，但是直接用传入v会引发类型错误。 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:2:5","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#传递数组"},{"categories":["C++学习"],"content":"指针与const很多对象的值一旦初始化就不会再改动： 使用符号化常量的代码比直接使用字面值常量的代码更易维护。 我们经常通过指针读取数据，但是很少通过指针写入数据。 绝大多数函数的参数值负责读取数据，很少写入数据。 为了表达一经初始化就不可修改的特性，可以在对象的定义中加上const关键字： cinst int model = 90 const int v[] = {1, 2, 3, 4}; const int x; //错误，缺少初始化器 一旦把某物声明成const，就确保它的值再作用域内不会发生改变： void f(){ model = 99; //错误 v[2] = 8; //错误 } 使用const会改变一种类型，所谓的改变不是改变常量的分配方式，而是限制它的使用方式： void g(const X* p) { //此处无权修改*p } 一个指针牵扯到两个对象：指针本身以及指针所指的对象。在指针的声明语句中“前置”const关键字将令所指的对象而非指针本身称为常量。要领指针本身成为常量，应该用*const代替普通的*： void f1(char* p){ char s[] = \"Grom\"; const char* pc = s; //指向常量的指针 pc[3] = 'g'; //错误，pc指向常量 pc = p; //OK char *const cp = s; //常量指针 cp[3] = 'a'; //OK cp = p; //错误，cp是一个常量 const char *const cpc = s; // 指向常量的常量指针 cpc[3] = 'a'; //错误：cpc指向常量 cpc = p; //错误：cpc本身是一个常量 } 声明运算符*const的作用是令指针本身成为常量，出现在*前边的const是基本类型的一部分。 char *const cp; //指向char的常量指针 char const* pc; //指向常量const的指针 const char* pc2; //指向常量char的指针 从右向左的顺序读，例如，“cp是指向char的const指针”，而“pc2是指向const char的指针”。 对于同一个对象来说，通过一个指针访问它时是常量并不妨碍在其他情况下它是变量。这一点在涉及函数的实参时特别有用。可以把指针类型的实参声明成const，这样就能组织函数修改该指针所指的对象： const char* strchr(const char* p, char c); //找到在字符串p中zifuc第一次出现的位置 char* strchr(char* p, char c); //找到在字符串p中zifuc第一次出现的位置 第一个函数的参数是常量字符串，函数无权修改其中的元素；它的返回值是指向const的指针，也不允许修改其所指的变量。第二个函数则没有这些限制。 C++允许把非const变量的地址赋给指向常量的指针，这样不会造成什么不可接受的后果。相反，常量的地址不能赋给某个不受限的指针，如果这样的话，用户有可能通过该指针修改对象的值： void f4(){ int a = 1; const int c = 2; const int* p1 = \u0026c; const int* p2 = \u0026a; int* p3 = \u0026c; //错误，用const int*初始化int* *p3 = 7; //试图改变C } ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:3:0","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#指针与const"},{"categories":["C++学习"],"content":"引用使用指针和使用对象名存在以下差别： 语法形式不同，*p和p-\u003em分别取代了obj和obj.m。 同一个指针可以在不同时刻指向不同的对象。 指针的值可能是nullptr，使用时要小心。 引用和指针类似，作为对象的别名存放对象的机器地址。与指针相比，不会带来额外的开销。与指针的区别主要包括： 访问引用与访问对象本身从语法形式上看是一样的。 引用所引的永远是一开始初始化的那个对象。 不存在“空引用”，引用一定对应着某个对象。 引用实际上是对象的别名，最重要的用途就是作为函数的实参或返回值。 为了体现左值/右值以及const/非const的区别，存在三种形式的引用： 左值引用：引用那些我们希望改变值的对象。 const引用：引用那些我们不希望改变值的对象(如常量)。 右值引用：所引用的值在使用之后就无须保留(如临时变量)。 着三种形式统称为引用，前两种自宁国市都是左值引用。 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:4:0","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#引用"},{"categories":["C++学习"],"content":"左值引用X\u0026的意思是“X的引用”： void f(){ int var = 1; int\u0026 r {var}; int x = r; //x =1 r = 2; //var = 2 } 为确保引用对应某个对象，必须初始化引用： int var = 1; int\u0026 r1 {var}; //OK int\u0026 r2; //错误，缺少初始化 extern int\u0026 r3; //OK，r3在别处初始化 初始化引用和给引用赋值是完全不同的操作： void g(){ int var = 0; int\u0026 rr{var}; ++rr; //rr值加1 int* pp = \u0026rr; //pp指向var } ++rr的含义不是递增引用rr，而是给rr所指的int（var）加1。引用本身的值一旦经过初始化就不能再改变了；他用冤兜指向一开始指定的对象。可以使用\u0026rr得到一个指向rr所引对象的指针，但是不能令某个指针指向引用，也不能定义引用的数组。 引用的实现方式类似常量指针，每次引用实际上是对指针执行解引用。 当初始值是左值是，提供给“普通”T\u0026的初始值必须是T类型的左值。 const T\u0026的初始值不一定非得是左值，甚至可以不是T类型的： double\u0026 dr = 1; //错误，此处需要左值 const double\u0026 cdr {1}; //OK 后一条语句可以理解为： double temp = double{1}; //先用给定值创建临时变量 const double\u0026 cdr {temp}; //再将临时变量作为cdr的初始值 用于存放初始值的临时变量的生命周期从它创建之处开始，到它的作用域结束为止。 普通变量的引用和常量的引用必须分开来。 将引用作为函数的实参类型，这样函数就能修改传入其中的对象的值： void increment(int\u0026 aa){ ++aa; } void f(){ int x = 1; increment(x); // x=2 } 尽量避免函数修改它的实参值，可以让函数显式的返回一个值达到同样地目的： int next(int p) { return p+1; } void g(){ int x = 1; increment(x); //x=2 x = next(x); //x=3 } 除非函数名能明显的表达修改实参的意思，否则不要轻易使用“普通”引用。 引用还能作为函数返回值类型，此时，该函数既能作为赋值运算符的左侧运算对象，也能作为赋值运算符的右侧运算对象。 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:4:1","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#左值引用"},{"categories":["C++学习"],"content":"右值引用为支持对象的不同用法： 非const左值引用所引的对象可以由用户写入内容。 const左值引用所引的对象从用户角度来看是不可修改的。 右值引用对应一个临时对象，用户可以修改这个对象，并认定该对象以后不会用到了。 右值引用可以绑定到右值，但不能绑定到左值： string var{\"Cambridge\"}; string f(); string\u0026 r1{var}; //左值引用 string\u0026 r2{f()}; //左值引用，错误，f()是右值 string\u0026 r3{\"Princeton\"}; //左值引用，错误，不允许绑定到临时变量 string\u0026\u0026 rr1{f()}; //右值引用，正确，rr1绑定到一个右值 string\u0026\u0026 rr2{var}; //右值引用，错误，var是左值 string\u0026\u0026 rr3{\"Oxford\"}; //rr3医用一个临时变量 const string cr1\u0026{\"Harvard\"}; //OK 声明符\u0026\u0026表示“右值引用”，const左值引用和右值引用都绑定右值，但是它们的目标完全不同： 右值引用实现一种“破坏性读取”。 const左值引用的作用是保护参数内容不被修改。 右值引用使用方式基本等同于左值引用的方式： string f(string\u0026\u0026 s){ if(s.size()) s[0] = toupper(s[0]); return s; } ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:4:2","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#右值引用"},{"categories":["C++学习"],"content":"引用的引用永远是左值引用优先。 引用的引用指针只能作为别名的结果或者模板类型的参数。 ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:4:3","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#引用的引用"},{"categories":["C++学习"],"content":"指针与引用指针与引用各有优势，也都存在不足： 如果需要更换所指对象，应该使用指针。 void fp(char* p){ while(*p) cout \u003c\u003c ++*p; } void fr(char\u0026 r){ while(r) cout \u003c\u003c ++r;//增加的是引用的char的值，不是引用本身 } void fr2(char\u0026 r){ char* p = *r; while(r) cout \u003c\u003c ++r; } 反之，如果想让某个名字永远对应同一对象，应该使用引用。 如果要自定义一个运算符，使之用于指向对象的某物，应该使用引用。 Matrix operator+(const Matrix\u0026, const Matrix\u0026) Matrix operator-(const Matrix*, const Matrix*) //错误，不是用户自定义类型参数 Matrix y,z; Matrix x = y + z; Matrix x2 = \u0026y - \u0026z; 如果想让一个集合中的元素指向对象，应该使用指针。 int x,y; string\u0026 a1[] = {x,y}; //错误，引用的数组 string* a2[] = {\u0026x,\u0026y}; vector\u003cstring\u0026\u003e s1 = {x,y}; //错误，引用的向量 vector\u003cstring*\u003e s2 = {\u0026x,\u0026y}; 如果需要表示值空缺，应该使用指针。 void fp(X* p){ if(p == nullptr){ // } else{ } } void fr2(X\u0026 r){ } ","date":"10-24","objectID":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/:4:4","series":["C++程序设计语言"],"tags":["指针","数组","引用"],"title":"C++指针与引用","uri":"/2022/c-%E6%8C%87%E9%92%88%E4%B8%8E%E5%BC%95%E7%94%A8/#指针与引用"},{"categories":["C++学习"],"content":"类型","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:1:0","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#类型"},{"categories":["C++学习"],"content":"布尔值根据定义，当我们想把布尔值转换成整数时，trye转为1，false转为0。反之，整数值也能在需需要的时候隐式的转换成布尔值，其中非0整数值对应true，而0对应false。 bool b1 = 7; //b1为true bool b2{7}; //错误，发生了窄化变换 int i1 = true; // i1=1 int i2{true}; // i2=1 如果既想使用{}初始化器列表防止窄化转换的发生，同时又想把int转换为bool，可以显式声明如下： voif f(int i){ bool b{i != 0}; } 如有必要，指针也能被隐式的转换成bool。其中，非空指针对应true，值为nullptr的指针对应false。如： void g(int* p){ bool b = p; //窄化成true或false bool b2{p != nullptr}; //显式的检查指针是否为空 if (p){ } } 与if(p!=nullptr)相比，if(p)更好，不但简洁，而且可以直接表达“p是否有效”，同时也不易出错。 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:1:1","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#布尔值"},{"categories":["C++学习"],"content":"字符类型绝大多数情况下，char占8个二进制位。 signed char存放-127~127之间的值；unsigned char存放0~255之间的值。 需要注意的是，字符类型属于整形，因此，可以在字符类型上执行算数运算和位逻辑运算。如： void digits(){ for(int i = 0; i != 10; ++i) cout \u003c\u003c static_cast\u003cchar\u003e('0' + i); } 上面的代码把10个阿拉伯数字输出到cout。字符字面值常量‘0’先转换为它对应的整数值，再与i相加；所得的int再转回char并被输出到cout。‘0+i’得到的结果本来是一个int，因此如果不加上static_cat的话，输出的结果将会是48,49…而不是0，1… ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:1:2","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#字符类型"},{"categories":["C++学习"],"content":"带符号字符和无符号字符虽然从本质上来说，char的行为无非与signed char抑制或者与unsigned char一致，但这3个名字代表的类型的确各不相同。我们不能混用指向这三种字符类型的指针： void f(char c,signed char sc, unsigned char uc){ char* pc = \u0026uc; //错误，不存在对应的指针转换规则 signed char* psc = pc; //错误，不存在对应的指针转换规则 unsigned char* puc = pc; //错误，不存在对应的指针转换规则 psc = puc; //错误，不存在对应的指针转换规则 } 3种char类型的变量可以相互赋值，但是把一个特别大的值赋给带符号的char是未定义的行为： void g(char c,signed char sc, unsigned char uc){ c = 255; //如果普通的char是带符号的且占8位，则该语句的行为依赖于具体实现 c = sc; //OK c = uc; //如果普通的char是带符号的uc的值特别大，则该语句的行为依赖于具体实现 sc = uc; //如果uc的值特别大，则该语句的行为依赖于具体实现 uc = sc; //OK：转换成无符号类型 sc = c; //如果普通的char是带符号的uc的值特别大，则该语句的行为依赖于具体实现 uc = c; //OK：转换成无符号类型 } 再举个例子，假设char占8位： signed char sc = -160; unsigned char uc = sc; //uc==116(因为256-140=116) cout \u003c\u003c uc; //输出‘t’ char count[256]; //假设是占8位的char（未初始化的） ++count[sc]; //严重错误：越界访问 ++count[uc]; //OK ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:1:3","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#带符号字符和无符号字符"},{"categories":["C++学习"],"content":"字符字面值常量字符字面值常量是指单引号内的一个字符，如‘a’和‘0’等。 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:1:4","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#字符字面值常量"},{"categories":["C++学习"],"content":"void从语法结构上来说，void属于基本类型。但是它只能用作其他复杂类型的一部分，不存在任何void类型的对象。void有两个作用：一是作为函数的返回类型用以说明函数不返回任何实际的值；二是作为指针的基本类型部分表明指针所指对象的类型位置： void x; //错误，不存在void类型的对象 void\u0026 r; //错误，不存在void的引用 void f(); //函数f不返回任何实际的值 void* pv; //指针所指的对象类型未知 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:1:5","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#void"},{"categories":["C++学习"],"content":"声明大多数声明同时也是定义。我们可以把定义看成是一种特殊的声明，它提供了在策划能够许志鸿使用该实体所需的一切信息。 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:2:0","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#声明"},{"categories":["C++学习"],"content":"声明多个名字在声明语句中，运算符只作用域紧邻的一个名字，归于后续的其他名字是无效的： int* p,y; //int* p;int y; int x, *p; // int x; int *p; int v[10], *pv; // int v[10]; int *pv; ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:2:1","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#声明多个名字"},{"categories":["C++学习"],"content":"初始化初始化器有四种可能的形式： X a1{v}; X a2 = {v}; X a3 = v; X a4(v); 这些形式中，只有第一种不受限制。使用{}的初始化称为列表初始化，它能防止窄化转换,这句话的意思是： 如果一种整型存不下另一种整型的值，则后者不会被转化成前者。例如，允许char到int的转换，但是不允许int到char的转换。 如果一种浮点类型存不下另一种浮点型的值，则后者不会被转换成前者。例如，允许float到double的转换，但是不允许double到float的转换。 浮点型的值不能转换成整型值。 整型值不能转换成浮点型的值。 当使用auto关键字从初始化器推断变量的类型时，没必要采用列表初始化的方式。而且如果初始化器是{}列表，则推断到的数据类型肯定不是我们想要的结果： auto z1 {99}; //initialize_list\u003cint\u003e zuto z2 = 99; //int 因此在使用auto时应该选择=的初始化方式。 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:2:2","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#初始化"},{"categories":["C++学习"],"content":"缺少初始化器如果没有指定初始化器，则全局变量、名字空间变量、局部static变量和static成员(统称为静态对象)将会执行相应的数据类型的列表{}初始化： int a; //等同于‘int a{}’，a为0 double d; //等同于‘double d{}’, d为0.0 对于局部变量和自由存储上的对象来说，除非它恩无畏于用户自定义类型的默认构造函数中，否则不会执行默认初始化： void f(){ int x; //x没有一个定义良好的值 char buf[1024]; //buf[i]没有一个定义良好的值 int* p{new int}; //*p没有一个定义良好的值 char* q{new char[1024]};//q[i]没有一个定义良好的值 string s; //s==\"\" vector\u003cchar\u003e v; //v =={} string* ps{new string}; //*ps是“” } 如果想对内置类型的局部变量或者用new创建的内置类型的对象执行初始化，使用{}形式： void f(){ int x{}; //x==0 chat buf[1024]{}; //buf[i]==0 int* p{new int{10}}; //*p为10 char* q{new char[1024]{}} //q[i]==0 } ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:2:3","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#缺少初始化器"},{"categories":["C++学习"],"content":"推断类型：auto和decltype() auto根据对象的初始化器推断对象的数据类型，可能是变量、const、或constexpr类型。 decltype(expr)推断的对象不是一个简单的初始化器，有可能是函数的返回类型或者成员的类型。 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:3:0","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#推断类型auto和decltype"},{"categories":["C++学习"],"content":"auto类型修饰符表达式的类型越难懂、越难书写，auto就越有用： template\u003cclass T\u003e void f1(vector\u003cT\u003e\u0026 arg) { for(vector\u003cT\u003e::terator p= arg.begin(); p != arg.end(); ++P) *p = 7; for(auto p = arg.begin(); p != arg.end(); ++P) *p = 7; } 对上面的程序来说，使用auto显然是更好地选择。 与使用明确的类型名相比，使用auto可能会使得定位类型错误的难度增大，为了解决auto可能造成的影响，最常规的方法就是保持函数的规模较小。 我们可以推断出类型添加修饰符或说明符，比如const或\u0026： void f(vector\u003cint\u003e\u0026 v) { for(const auto\u0026x:v){//x类型是const int\u0026 ... } } 表达式的类型永远不会是引用类型，因为表达式回隐式的执行解引用操作： void g(int\u0026 v) { auto x = v; //x类型是int auto\u0026 y = v; //y类型是int\u0026 } ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:3:1","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#auto类型修饰符"},{"categories":["C++学习"],"content":"decltype修饰符很多时候我们既想推断得到类型，又不想在此过程中定义一个初始化的变量，此时，应该使用声明类型修饰符decltype(expr)。其中，所推得的结果是expr的声明类型： template\u003cclass T, class U\u003e auto operator+(const Matrix\u003cT\u003e\u0026 a, const Matrix\u003cU\u003e\u0026 b) -\u003e Matrix\u003cdecltype(T{} + U{})\u003e ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:3:2","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#decltype修饰符"},{"categories":["C++学习"],"content":"对象和值对象是指一块连续的存储区域，左值是指向对象的一条表达式。 “左值”的字面意思是“能用在赋值运算符左侧的东西”，但其实不是所有左值都嫩用在赋值运算符的左侧，左值有可能指某个常量。 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:4:0","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#对象和值"},{"categories":["C++学习"],"content":"左值和右值当考虑对象的寻址、拷贝、移动等操作时，有两种属性非常关键。 有身份：在程序中有对象的名字，或指向该对象的指针，或该对象的引用，这样我们就能判断两个对象是否相等或对象的值是否发生改变。 可移动：能把对象的内容移动出来。 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:4:1","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#左值和右值"},{"categories":["C++学习"],"content":"类型别名 using Pchar = char*; //字符串指针 using Pf = int(*)(double); //函数指针，接受一个double返回一个int Pchar p1 = nullptr; // p1类型是char* char* p3 = p1; //正确 不孕须在类型别名前加修饰符（如unsigned）： using Char = char; using Uchar = unsigned Char; //错误 using Uchar = unsigned char; //正确 ","date":"10-20","objectID":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/:5:0","series":["C++程序设计语言"],"tags":["类型","声明","推断类型"],"title":"C++类型与声明","uri":"/2022/c-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%A3%B0%E6%98%8E/#类型别名"},{"categories":["C++学习"],"content":"类三种重要类的基本支持: 具体类； 抽象类； 类层次中的类。 很多有用的类都可以归为这三个类别，其他类可以看成是这些类别的简单变形或组合。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:0:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#类"},{"categories":["C++学习"],"content":"具体类型具体类的基本思想是他们的行为“就像内置类型一样”。 具体类型的典型特征是，它的表现形式是其定义的一部分。在很多重要的例子中，表现形式只不过是一个或几个指向保存在别处的数据的指针，但这种表现形式出现在具体类的每一个对象中。这使得实现可以在时空上达到最优，尤其是它允许我们： 把具体类型的对象置于栈、静态分配的内存或其他对象中； 直接引用对象(而非仅仅通过指针或引用)； 创建对象后立即进行完整的初始化(比如使用构造函数)； 拷贝对象。 如果想提高灵活性，具体类型可以将其表现形式的主要部分防止在自由存储(动态内存、堆)中，然后通过存储在类对象内部的另一部分访问它们。vector和string的实现机理正是如此，我们可以把它们看做是带有精致接口的资源管理器。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:1:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#具体类型"},{"categories":["C++学习"],"content":"一种算数类型一种“经典的用户自定义算数类型”是complex： class complex{ double re,im; //表现形式，两个爽双精度浮点数 public: complex(double r, double i):re{r}, im{i}{} //用两个标量构建该复数 complex(double r):re{r},im{0}{} //用一个标量构建该复数 complex():re{0},im{0}{} //默认的复数的{0,0} double real() const{return re;} void real(double d){re = d;} double imag() const{return im;} void imag(doubre d){im = d;} complex\u0026 operator+=(complex z){re+=z.re, im+=z.im; return *this;} //加到re和im上然后返回 complex\u0026 operator-=(complex z){re-=z.re, im-=z.im; return *this;} complex\u0026 operator*=(complex); // 在类外的某处进行定义 complex\u0026 operator*=(complex); }; 这是对标准库complex略作简化后的版本，类定义把二审仅包含需要访问其表现形式的操作。它的表现形式非常简单，也是大家约定俗成的。 无需实参就可以调用的构造函数称为默认构造函数，complex()是类complex的默认构造函数。通过定义默认构造函数，可以有效防止该类型的对象未初始化。 在负责返回实部和虚部的函数中，const说明符表示这两个函数不会修改所调用的对象。 很多有用的操作并不需要直接访问complex的表现形式，因此她们的定义可以与类的定义分离开： complex operator+(complex a, complex b){return a += b;} complex operator-(complex a, complex b){return a -= b;} complex operator-(complex a){return {-a.real(), -a.imag()};} // 一元负号 complex operator*(complex a, complex b){return a *= b;} complex operator/(complex a, complex b){return a /= b;} 此处使用C++的一个特性，即。以传值方式传递实参实际上是把一份副本传递给函数，因此我们修改形参(副本)不会影响主调函数的实参，并可以将结果作为返回值。 bool operator==(complex a, complex b) //相等 { return a.real == b.real() \u0026\u0026 a.imag() == b.imag(); } bool operator!=(complex a, complex b) //不等 { return !(a == b); } complex sqrt(complex); 可以像下面这样使用complex： void f(complex z){ complex a {2.3}; //用2.3构建出{2.3,0.0} complex b {1/a}; complex c {a+z*complex{1,2.3}} if(c != b) c = -(b/a)+2*b; } 编译器自动将计算complex值的运算符转换成对应的函数调用，例如c!=b意味着operator!=(c,b),而1/a意味着operator/(complex{1},a)。 在使用用户自定义的运算符(“重载预算符”)时，应当尽量小心谨慎，并且尊重常规的使用习惯。不能定义一元运算符/，因为其语法在语言中已被固定。同样，布尔诺能够改变一个运算符操作内置类型时的含义，因此不能定义运算符+令其执行int的减法。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:1:1","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#一种算数类型"},{"categories":["C++学习"],"content":"容器容器是指一个包含若干元素的对象，因为Vector的对象都是容器，所以称Vector是一种容器类型。Vector作为double的容器有许多优点“易于理解，建立有用的不变式，提供包含边界检查的范围功能，并提供size()以允许遍历其元素。然而，它还是存在一个致命缺陷：使用new分配元素，但是从来没有释放这些元素，尽管C++定义了一个垃圾回收的接口，可将未使用的内存提供给新对象，但不能保证垃圾回收器总是可用的。某些情况下不能使用回收功能，有时处于逻辑或性能的考虑宁愿使用更精确的资源释放控制。因此，我们需要一种机制以确保构造函数分配的内存一定会被销毁，这种机制就叫析构函数： class Vector{ private: double* elem;//elem指向一个包含sz个double的数组 int sz; public: Vector(int s): elem{new double[s]},sz{s}{ //构造函数，请求资源 for(int i = 0; i != s; ++i) elem[i] = 0; //初始化元素 } ~Vector(){delete[] elem;} // 析构函数，释放资源 double\u0026 operator[](int i); int size() const; }; 析构函数得命名规则是一个求补运算符~后接类的名字，从含义上来说它是构造函数的补充。Vector的构造函数使用new运算符从自由存储分配一些内存空间，析构函数则用delete运算符释放该空间以达到清理资源的目的。这一切都无需Vector使用者的干预，只需像使用普通的内置类型变量那样使用Vector对象就行： void fct(int n){ Vector v(n); // 使用v { Vector v2(2*n); //使用v和v2 }//v2在此被销毁 }//v在此被销毁 构造函数负责分配元素接空间并正确的初始化Vector策划能够元，析构函数负责释放空间。这就是所谓的数据句柄模型。常用来管理在对象生命周期中大小会发生变化的数据。在构造按函数中请求资源，然后在析构函数中释放它们的技术称为资源获取即初始化，简称RAII，使得规避”裸new操作“的风险，该技术可以避免在普通代码中分配内存，而是把分配操作隐藏在行为良好的抽象类的实现内部。同样，也应避免”裸delete操作“。避免裸new和裸delete可以使代码远离各种潜在风险，避免资源泄漏。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:1:2","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#容器"},{"categories":["C++学习"],"content":"初始化容器容器的作用是保存元素，因此我们需要找到一种便利的方式将元素存入容器中。为了做到这一点，一种可能的方式时先用若干元素创建一个Vector，然后依次为这些元素赋值。显然这不是最好的办法，下面列举两种更简洁的途径。 初始化器列表构造函数：使用元素的列表进行初始化； push_back()：在序列的末尾添加一个新元素。 它们的声明形式如下所示： class Vector{ public: Vector(std::initializer_list\u003cdouble\u003e); //使用一个列表进行初始化 void push_back(double); //在末尾添加一个元素，容器长度加1 } 其中，push_back()可用于添加任意数量的元素： Vector read(istream\u0026 is){ Vector v; for(double d; is\u003e\u003ed); //浮点值读入d v.push_back(d); //把d加到v中 return v; } 上面的循环操作负责执行输入操作，它的终止条件是遇到文件末尾或者格式错误。在此之前，每个读入的数依次添加到Vector尾部，最后v的大小就是读取的元素数量。 用于定义初始化器列表构造函数的std::initializer_list是一种标准库类型，编译器可以辨识它：当使用{}列表时，如{1,2,3,4}，编译器会创建一个initializer_list类型的对象并将其提供给车供需。因此，可以写： Vector v1 = {1,2,3,4,5}; Vector v2 = {1.2,3.4,6.7,8}; Vector的初始化器列表构造函数可以定义成如下形式： Vector::Vector(std::initializer_list\u003cdouble\u003e lst) :elem{new double[lst.size()]},sz{lst.size()} { copy(lst.begin(),list.end(),elem); //从lst复制内容到elem中 } ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:1:3","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#初始化容器"},{"categories":["C++学习"],"content":"抽象类型complex和Vector等类型之所以被称为具体类型，时因为它们的表现形式和俗语定义的一部分。这一点上，它们和内置类型很相似。相反，抽象类型则将使用者和类的实现细节完全隔离开来。为了做到这一点，我们分离接口与表现形式并放弃纯局部变量。因为对抽象类型的表现形式一无所知(甚至对大小也不了解)，所以必须从自由存储为对象分配空间，然后通过引用或指针访问对象。 首先，为Container类设计接口，Container类可以看成是比Vector更抽象的一个版本： class Container{ public: virtual double\u0026 oprtator[](int) = 0; //纯虚函数 virtual int size() const=0; //常量成员函数 virtual ~Container(){} //析构函数 }; 对于后面定义的特定容器来说，上面这个类时纯粹的接口。关键字virtual的意思是“可能随后在其派生类中冲重新定义”。把用关键字virtual声明的函数称为虚函数。Container的派生类负责为Container接口提供具体实现。看起来有点奇怪的=0说明该函数时纯虚函数，意味着Container的派生类必须定义这个函数。因此，不能够单纯定义一个Container的对象，Container只是作为接口出现，它的派生类负责具体实现operator和size()。含有纯虚函数的类称为抽象类。 Container的用法是： void use(Container\u0026 s){ const int sz = c.size(); for(int i = 0; i != sz; ++i) cout \u003c\u003c c[i] \u003c\u003c '\\n'; } 如果一个类负责为其他一些类提供接口，那么我们把前者称为多态类型。 最为一个抽象类，Container中没有构造函数。另一方面，Container需要有一个析构函数，且该析构函数是virtual的。 一个容器为了实现抽象类Container接口所需的函数，可以使用具体类Vector： class Vector_container:public Container{ Vector v; public: Vector_container(int s):v(s){} //含有s个元素的vector ~Vector_container(){} double\u0026 operator[](int i){return v[i];} int size() const{return v,size();} }; Vector_container类派生自Container类，而Container类称为Vector_container的基类。 成员operqtor和size()覆盖了基类中对应的成员。构造函数~Vector_container()则覆盖了基类的析构函数~Container()。成员v的析构函数~Vector被其类的析构函数~Vector_container()隐式调用。 对于use(Container\u0026)这样的的函数来说，可以在完全不了解一个Container实现细节的情况下使用它，但还需某个函数(g)为其创建可供操作的对象。 void g(){ Vector_container vc{10,9,8,7,6,5,4,3,2,1,0}; use(vc); } 因为use()只知道Container的接口而不了解Vector_container，因此对于Container的其他实现，use()仍能正常工作。 class List_container:public Container{ std::list\u003cdouble\u003e ld; //一个double类型的标准库list public: List_container(){} //空列表 List_container(initializer_list\u003cdouble\u003e il): ld{il} ~List_container(){} double\u0026 operator[](int i); int size() const {return ld.size();} }; double\u0026 List_container::operator[](int i) { for(auto\u0026 x:ld){ if(i == 0) return x; --i; } throw out_of_range(\"List container\"); } 这段代码中，类的表现形式是一个标准库list。一般情况下，我们不会使用list实现一个带下标的容器。 我们可以通过一个函数创建一个List_container，然后让use()使用它： void h() { List_container lc = {1,2,3,4,5,6}; use(lc); } 这段代码的关键点在于use(Container\u0026)并不清楚它的实参是Vector_container、List_container还是其他，它根本不需要知道。只要链接Container定义的接口就可以了。因此，不论List_container的实现发生了改变还是使用Container的一个全新派生类，都不需要重新编译use(Container\u0026)。 灵活性背后的唯一不足是，只能通过引用或指针操作对象。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:2:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#抽象类型"},{"categories":["C++学习"],"content":"虚函数进一步思考Container的用法： void use(Container\u0026 c) { const int sz = c.size(); for(int i = 0; i != sz; ++i) cout \u003c\u003c c[i] \u003c\u003c '\\n'; } use中的c[i]是如何解析到正确的operator的？当h()调用use()时，必须调用List_container的operator；当g()调用use()时，必须调用Vector_container的operator.要想达到这种效果，Container对象就必须包含一些有助于它在运行时选择正确函数的信息。常见的做法时编译器将虚函数的名字转换成函数指针表中对应的索引值，这张表就是所谓的虚函数表或简称vtbl。每个含有虚函数的类都有它自己的vtbl用于辨识虚函数。 即使调用函数不清楚对象的大小和数据布局，vtbl中的函数也能确保对象被正确使用。调用函数的实现只需要知道Container中vtbl指针的位置以及每个虚函数对应的索引就可以了。这种虚调用机制的效率非常接近“普通函数调用”机制，而它的空间开销包括两部分：如果类包含虚函数，则该类的每个对象需要一个额外的指针；另外每个这样的类需要一个vtbl。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:3:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#虚函数"},{"categories":["C++学习"],"content":"类层次所谓类层次是指通过派生创建的一组类，在框架中有序排列。 类层次提供两种便利： 接口继承：派生类对象可以用在任何需要基类的地方。也就是说，基类看起来是派生类的接口一样。这样的类通常是抽象类。 实现继承：基类负责提供可以简化派生类实现的函数或数据。这样的基类通常含有数据称呀和构造函数。 具体类，尤其是表现形式不复杂的类，其行为非常类似于内置类型：我们将其定义为局部变量，通过它们的名字访问它们，随意拷贝它们等。类层次中的类则有所区别：我们倾向于通过new在自由存储中为其分配空间，然后通过指针或引用访问它们。例如，我们设计这样一个函数，首先从输入流中读入描述形状的数据，然后构造对应的Shape对象： enum class Kind{circle, triangle, smiley}; Shape* read_shape(istream\u0026 is){ //从is中读取形状描述信息，找到形状的种类k switch(k){ case Kind::circle: return new Circle{p, r}; case Kind::triangle: return new Triangle{p1, p2, p3}; case Kind:😃 Smiley* ps = new Smiley{p,r}; ps-\u003eadd_eye(e1); ps-\u003eadd_eye(e2); ps-\u003eset_mouth(m); return ps; } } 程序使用该函数的方式如下所示： void use() { std::vector\u003cShape*\u003e v; while(cin) v.push_back(read_shape(cin)); draw_all(v); rotate_all(v, 45); for(auto P:v) delete p; } ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:4:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#类层次"},{"categories":["C++学习"],"content":"拷贝和移动默认情况下，我们可以拷贝对象，不论用户自定义类型的对象还是内置类型的对象都是如此。拷贝的默认含义是逐成员的复制。如： void test(complex z1) { complex z2{z1}; // 拷贝初始化 complex z3; z3 = z2; //拷贝赋值 } 因为赋值和初始化操作都复制了complex的全部两个成员，所以在上述操作之后z1,z2,z3的值变得完全一样。 当设计一个类时，必须仔细考虑对象是否会被拷贝以及如何拷贝的问题。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:5:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#拷贝和移动"},{"categories":["C++学习"],"content":"拷贝容器当一个类作为资源句柄时，换句话说，当这个类负责通过指针访问一个对象时，采用默认的逐成员复制方式通常意味着错误。逐成员复制将违反资源句柄的不变式。例如，下面所示的默认拷贝将产生Vector的一份拷贝，而这个拷贝所指向的元素与原来的元素是同一个： void bad_copy(Vector v1) { Vector v2 = v1; v1[0] = 2; //v2[0]也是2 v2[1] = 3; //v1[1]也是3 } 类对象的拷贝操作可以通过两个成员来定义：拷贝构造函数与拷贝赋值运算符： class Vector{ private: double* elem; int sz; public: Vector(int s); ~Vector(){delete[] elem;} Vector(const Vector\u0026 a); //拷贝构造函数 Vector\u0026 operator = (const Vector\u0026 a); //拷贝赋值运算符 double\u0026 operator[](int i); const double\u0026 operator[](int i) const; int size() const; }; 对于Vector来说，拷贝构造函数的正确定义应该为指定数量的元素分配空间，然后把元素复制到空间中。 Vector::Vector(const Vector\u0026 a) //复制构造函数 :elem{new double{sz}}, //为元素分配空间 sz{a.sz} { for(int i=0; i!=sz; ++i) //复制元素 elem[i] = a.elem[i]; } 在拷贝构造函数之外我们还需要一个拷贝复制运算符： Vector\u0026 Vector::operator=(const Vector\u0026 a) { double* p = new double[a.sz]; for(int i=0; i!=sz; ++i) p[i] = a.elem[i]; delete[] elem; //删除旧元素 elem = p; sz = a.sz; return *this; } 其中，名字this预定义在成员函数中，它指向调用该成员函数的那个对象。 类X的拷贝构造函数和拷贝赋值运算符接受的实参类型通常是const X\u0026。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:5:1","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#拷贝容器"},{"categories":["C++学习"],"content":"移动容器我们能通过定义拷贝构造函数和拷贝赋值运算符来控制拷贝过程，但是对于大容量的容器来说拷贝过程有可能耗费巨大。以下面代码为例： Vector operator+(const Vector\u0026 a, const Vector\u0026 b) { if(a.size()!=b.size()) throw Vector_size_mismatch{}; Vector res(a.size()); for(int i=0; i!=a.size(); ++i) res[i] = a[i] + b[i]; return res; } 要想从+运算符返回结果，需要把局部变量res的内容拷贝到调用者可以访问的地方。可能这样使用+” void f(const Vector\u0026 x, const Vector\u0026 y, const Vector\u0026 z) { Vector r; r = x+y+z; } 有时我们并不真的想要一个副本，而只想把计算结果从函数中取出来，相对于copy一个对象，我们更希望移动它： class Vector{ Vector(const Vector\u0026 a); Vector\u0026 operator=(const Vector\u0026 a); Vector(Vector\u0026\u0026 a); //移动构造函数 Vector\u0026 operator=(Vector\u0026\u0026 a); //移动赋值运算符 }; 基于上述定义，编译器选择移动构造函数来执行从函数中移出返回值的任务。这意味着r=x+y+z不需要再拷贝Vector，只是移动它就够了。 定义Vector移动构造函数的过程非常简单： Vector::Vector(Vector\u0026\u0026 a) :elem{a.elem}, //从a中夺取元素 sz{s.sz} { a.elem = nullptr; //现在a已经没有元素了 a.sz = 0; } 符号\u0026\u0026的意思是“右值引用”，我们可以给该引用绑定一个右值。“右值”的含义与“左值”正好相反，左值的大致含义是“能出现在赋值运算符左侧的内容”，因此右值大致上就是我们无法为其赋值的值，比如函数调用返回的一个整数。进一步，右值引用的含义就是引用了一个别人无法赋值的内容。Vector的operator+运算符的局部变量res就是一个示例。 移动构造函数不接受const实参：毕竟移动构造函数最终要删除掉它实参中的值。移动赋值运算符的定义与之类似。 当右值引用被用作初始化器或者赋值操作的右侧运算对象时，程序将使用移动操作， 移动之后，源对象所进入的状态应该能允许运行析构函数。通常，我们也应该允许为一个移动操作之后的源对象赋值。 程序员可以知道一个值在什么地方不再被使用，但是编译器做不到，因此最好在程序中写的明确一点： Vector f() { Vector x(1000); Vector y(1000); Vector z(1000); z = x; //执行拷贝 y = std::move(x); //执行移动 return z； //执行移动 } 其中，标准库函数move()负责返回实参的右值引用。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:6:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#移动容器"},{"categories":["C++学习"],"content":"资源管理通过定义构造函数，拷贝操作，移动操作和析构函数，程序员就能对受控资源的全生命周期进行管理。而且移动构造函数还允许对象从一个作用域简单便捷地移动到另一个作用域。采取这种方式，我们不能或不希望拷贝到作用域之外的对象就能简单高效地移动出去了。不妨以表示并发活动的标准库thread和含有百万个double的Vector为例，前者“不能”执行拷贝操作，而后者我们“不希望“拷贝它。 std::vector\u003cthread\u003e my_threads; Vector init(int n) { thread t{heartbeat}; //同时运行heartbeat my_threads.push_back(move(t)); //把t移动到my_threads Vector vec(n); for(int i = 0; i \u003c vec.size(); ++i) vec[i] = 777; return vec; //把vec移动到init()之外 } auto v = init(); //启动heartbeat，初始化v 在很多情况下，用Vector和thread这样的资源句柄比的效果要好。事实上，以unique_ptr为代表的”智能指针“本身就是资源句柄。 ","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:7:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#资源管理"},{"categories":["C++学习"],"content":"抑制操作","date":"10-18","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/:8:0","series":["C++程序设计语言"],"tags":["函数","形参","实参"],"title":"C++概览抽象机制","uri":"/2022/c-%E6%A6%82%E8%A7%88%E6%8A%BD%E8%B1%A1%E6%9C%BA%E5%88%B6/#抑制操作"},{"categories":["C++学习"],"content":"类型在定义一个变量时，如果变量的类型可以由初始化器推断得到，则无须显式指定其类型： auto b = true; //bool auto ch = 'x'; //char auto i = 123; //int auto d = 1.2; //double auto z = sqrt(y); //sqrt(y)返回的类型 可以使用=的初始化与auto配合，因为在此过程中不存在可能引发错误的类型转换。 当没有明显的理由需要显式指定数据类型时，一般使用auto。 该定义位于一个较大的作用域中，我们希望代码的读者清楚的知道其类型； 我们希望明确规定某个变量的范围和精度（如希望使用double而非float）。 通过使用auto可以帮助避免冗余，并无须书写长类型名。 ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#类型"},{"categories":["C++学习"],"content":"常量 const：大致意思是“我承诺不改变这个值”。主要用于说明接口，这样在把变量传入函数时就不必担心变量会在函数内被改变。编译器负责确认并执行const的承诺。 constexpr：大致意思是”在编译时求值“。主要英语说明常量，作用是允许将数据至于只读内存中以及提升性能。 const int dmv = 17; //常量 int var = 17; //不是常量 const double max1 = 1.4*square(dmv); //如果square(17)是常量则正确 const double max2 = 1.4*square(var); //错误，var不是常量 const double max3 = 1.4*square(var); //OK，可在运行时求值 double sum(const vector\u003cdouble\u003e\u0026); //sum不会更改参数值 vector\u003cdouble\u003e v{1.2, 3.4, 4.5}; //v不是常量 const doublr s1 = sum(v); //OK，在运行时求值 constexpr double s2 = sum(v); //错误，sum(v)不是常量表达式 如果某个函数用在常量表达式中，则该表达式在编译时求值，则函数必须定义成constexpr。 constexpr double square(double x){ return x*x; } 要想定义成constexpr，函数必须非常简单：函数中只能有一条用于计算某个值的return语句。constexpr函数可以接受非常量实参，但其结果将不会是一个常量表达式。当程序的上下文不需要常量表达式时，我们可以使用非常量表达式实参来调用constexpr函数，这样就不用把同一个函数定义两次：其中一个用于常量表达式，另一个用于变量。 ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#常量"},{"categories":["C++学习"],"content":"指针指针的声明如下： char* p; //该指针指向字符 *表示”指向….“。指针变量中存放着一个相应类型对象的地址： char* p = \u0026v[3]; //p指向v的第四个元素 char x = *p; //*p是p所指的对象 在表达式中，前置一元运算符*表示”…的内容“，而前置一元运算符\u0026表示”…的地址“。 void print(){ int v[] = {0,1,2,3,4}; for(auto x : v) cout \u003c\u003c x \u003c\u003c '\\n'; } 如果我们不希望把v的值拷贝到变量x中，而只想令x指向一个元素，则可以书写如下代码： void increment(){ int v[] = {0,1,2,3,4}; for (auto\u0026 x : v) ++x; } 一元后值运算符\u0026表示”…的引用“，引用类似于指针，唯一的区别就是无须使用前置运算符*访问所引用的值。同样，一个引用在初始化之后就不能再引用其他对象。当用于声明语句时，运算符(如\u0026、*和[])称为声明运算符。 T a[n]; //n个T组成的数组 T* p; //指向T的指针 T\u0026 r; //T的引用 T f(A); //一个函数，接受A类型的实参，返回T类型的结果 当没有对象可指或我们希望有一种”没有可用对象“(如在列表的末尾)，令指针取值为nullptr(“空指针”)，所有指针类型共享同一个nullptr： double* pd = nullptr; Link\u003cRecord\u003e* lst = nullptr; //指向一个Record的Link指针 int x = nullptr; //错误 通常情况下，当我们希望指针实参指向某个东西时，最好检查以下是否确实如此。 int count_x(char* p, char x) //统计p[]中x出现的次数 //假定p指向一个字符数组，该数组的结尾处是0；或者p不指向任何东西 { if(p==nullptr) return 0; int count = 0; for(;*p != 0; ++p) if(*p == x) ++count; return count; } 有两点需要注意：一是可以使用++将指针移动到数组的下一元素；二是在for语句中如果不需要初始化操作，则可以省略它。 count_x()的定义假定char*是一个c风格字符串，也就是说指针指向了一个字符数组，该数组的结尾处是0。 ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#指针"},{"categories":["C++学习"],"content":"结构 struct Vector{ int sz; //元素数量 double* elem; //指向元素的指针 }; void vector_int(Vector\u0026 v, int s) { v.elem = new double[s]; //分配一个数组，包含s个double值 v.sz = s; } v的elem成员被赋予了一个由new运算符生成的指针而sz成员的值则是元素的个数，Vextor\u0026中的符号\u0026指定通过非常量引用的方式传递v，这样vector_int()就能修改传入其中的向量了。 new运算符是从一块名为自由存储(free store)的区域中分配内存。 Vector的一个简单应用如下： double read_and_sum(int s) { Vector v; vector_int(v,s); for(int i = 0; i != s; ++1) cin\u003e\u003ev.elem[i] double sum = 0; for(int i= 0; i != s; ++i) sum += v.elem[i]; return sum; } 访问struct成员的方式有两种：一种是通过名字或引用，这时我们使用.(点运算符)；另一种是通过指针，这时用到的是-\u003e。 void f(Vector v, Vector\u0026 rv, Vector* pv) { int i1 = v.sz; //通过名字访问 int i2 = rv.sz; //通过引用访问 int i4 = pv-\u003esz;//通过指针访问 } ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#结构"},{"categories":["C++学习"],"content":"类类含有一系列成员，可能是数据、函数或者类型。类的public成员定义该类的接口，private成员则只能通过接口访问。 class Vector{ public: Vector(int s): elem{new double[s]}, sz{s}{} //构建一个vector double\u0026 operator[](int i){return elem[i]} //通过下标访问元素 int size(){return sz;} private: double* elem; //指向元素的指针 int sz; //元素的数量 }; 我们仅能通过Vector的接口访问其表示形式，上面的read_and_sum()可简化为： double read_and_sum(int s) { Vector v(s); for(int i = 0; i != v.size(); ++1) cin\u003e\u003ev[i] double sum = 0; for(int i= 0; i != v.size(); ++i) sum += v[i]; return sum; } 与所属类同名的函数称为构造函数，即它是用来构造类的对象的函数。与普通函数不同，构造函数的作用是初始化类的对象，因此定义一个构造函数可以解决类变量为初始化的问题。该构造函数使用成员初始化器列表来初始化vector的成员： :elem{new double[s]}, sz{s} 这条语句的含义是：首先从自由空间获取s个double类型的元素，并用一个指向这些元素的指针初始阿护elem；然后用s初始化sz。 访问元素的功能是由一个下标函数提供的，这个函数名为operator[]，它的返回值是对相应元素的引用(double\u0026)。 ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#类"},{"categories":["C++学习"],"content":"枚举 enum class Color{red, blue, green}; enum class Traffic_light{green, yellow, red}; Color col = Color::red; Traffic_light light = Traffic_light::red; 枚举值位于enum class的作用域之内，因此可以在不同的enum class中重复使用枚举值而不引起混淆。 enum后面的class指明枚举是强类型的，且它的枚举值位于制定作用域中。不同的enum class是不同的类型，这有助于防止对常量的意外误用。在上面的例子中，不能混用Traffic_light和Color的值。 Color x = red; //错误，哪个red Color y = Traffic_light::red; //错误，此red不是Color的对象 Color z = Color::red; //OK 同样，也不能隐式的混用Color和整数值： int i = Color::red; //错误：Color::red不是一个int Color c = 2; //错误：2不是一个Color对象 如果不想显式的限定枚举名字，并且希望枚举值可以是int(无须显式转换)，则应该去掉enum class中的class而得到一个“普通的”enum。 默认情况下，enum class只定义了赋值、初始化和比较操作。然而，既然枚举类型是一种用户自定义类型，那么我们就可以为它定义别的运算符： Traffic_light\u0026 operator++(Traffic_light\u0026 t) //前置递增运算符++ { switch(t){ case Traffic_light::green: return t = Traffic_light::yellow; case Traffic_light::yelow: return t = Traffic_light::red; case Traffic_light::red: return t = Traffic_light::green; } } Traffic_light next = ++light; //next变为Traffic_light::green ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:6:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#枚举"},{"categories":["C++学习"],"content":"模块化构建C++程序的关键就是清晰的定义这些组成部分之间的交互关系。第一步也是最重要的一步，是将某个部分的接口和实现分离开来。在语言层面，C++使用声明来描述接口。声明指定了使用某个函数或某种类型所需的所有内容。 double sqrt(double); class Vector{ public: Vector(int s); double\u0026 operator[](itn i); int size(); private: double* elem; //elem指向一个数组，该数组包含sz个double int sz; }; ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:7:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#模块化"},{"categories":["C++学习"],"content":"异常Vector试图访问某个越界的元素时，应该做什么？ Vector的作者不知道使用者面临这种情况时希望如何处理。 Vector的使用者不能保证每次都检测到问题。 最佳的解决方案是由Vector的实现者负责检测可能的越界行为，然后通知使用者。之后Vector的使用者可以采取适当的应对措施。例如，Vector::operator能够检测到潜在的越界访问错误并抛出一个out_of_range异常： double\u0026 Vector::operator[](int i) { if(i \u003c 0 || size()\u003c=i) throw out_of_range{\"Vector::operator[]\"}; } throw负责吧程序的控制权从某个直接或间接调用Vector::operator[]的函数转移到out_of_range异常处理代码。为完成这一目标，实现部分需要展开函数调用栈以便返回主调函数的上下文。如： void f(Vector\u0026 v) { try{//此处异常被后面定义的处理模块处理 v[v.size()] = 7; //试图访问v末尾之后的位置 } catch(out_of_range){ //此处处理越界错误 } } 将可能处理异常的程序放在一个try块当中。显然，对v[v.size()]的赋值操作将出错。因此，程序进入到提供了out_of_range错误处理代码的catch从句中。 ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:8:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#异常"},{"categories":["C++学习"],"content":"不变式使用异常机制通报越界访问错误是函数检查实参的一个示例，此时，因为基本假设，即所谓的前置条件没有得到满足，所以函数拒绝执行。在正式说明Vector的下标运算符时，我们应该规定类似于”索引值必须在[0:size())范围内“的规则，这一规则是在operator内被检查的。 对于类来说，一条假定某事为真的声明称为类的不变式，简称不变式。建立类的不变式是构造函数的任务，它的另一个作用是确保当成员函数推出时不变式仍然成立。考虑如下情况： Vector v(-27); 与原来版本相比，下面的定义更好： Vector::Vector(int s){ if(s\u003c0) throw length_error{}; elem = new double[s]; sz = s; } 如果new运算符找不到可分配的内存，就会抛出std::bad::alloc。 void test(){ try{ Vector v(-27); } catch(std::length_error){ // 处理负值问题 } catch(std::bad::alloc){ // 处理内存耗尽问题 } } 可以自定义异常类，然后让它们把指定信息从检测到异常的点传递到处理异常的点。 通过情况下，当遭遇异常后就无法继续完成工作。此时，”处理“异常的含义仅仅是做一些简单地局部资源清理，然后重新抛出异常。 不变式的概念是设计类的关键，而前置条件也在设计函数的过程中起到同样地作用。不变式 帮助我们准确的理解想要什么； 强制要求具体而明确的描述设计，而这有助于确保代码正确。 ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:9:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#不变式"},{"categories":["C++学习"],"content":"静态断言程序异常负责报告运行时发生的错误。如果能在编译时发现错误，效果会更好。我们可以对其他一些编译时可知的属性做一些简单检查，并以编译器错误消息的形式报告所发现的问题。 static_assert(4 \u003c= sizeof(int), \"integers are too small\"); //检查整数的尺寸 如果4\u003c=sizeof(int)不满足，将会输出integers are too small的信息。也就是说，如果在当前系统上一个int占有的空间不足4个字节，就会报错。我们把这种表达某种期望的语句称为断言。 static_assert机制能用于任何可以表达为常量表达式的东西。例如： constexpr double C = 2299.456; void f(double speed) { const double local_max = 160.0/(60*60); static_assert(speed \u003c C, \"can't go that fast\"); //错误，速度必须是个常量 static_assert(local_max \u003c C, \"can't go that fast\"); //OK } 通常情况下，static_assert(A,S)的作用是当A不为true时，把S作为一条编译器错误信息输出。 static_assert最重要的用途是为泛型编程中作为形参的类型设置断言。 ","date":"10-16","objectID":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:10:0","series":["C++程序设计语言"],"tags":["指针","模块化","不变式"],"title":"C++概览基础知识","uri":"/2022/c-%E6%A6%82%E8%A7%88%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#静态断言"},{"categories":["我的炼丹日记"],"content":"ADDerNetQ:在硬件设备上加法的复杂度远小于乘法, 为更好地减少计算量提出AdderNet. 对AdderNet中的Winograd算法 （广泛用于加速卷积和节省计算量。由于乘法中的分配律对L1范式无效，因此原始的W算法无法直接在AdderNet上使用） 进行优化，并 （在Winograd算法中） 使用相加操作替换逐像素相乘。 分析AdderNet中Winograd的特征图不均衡的原因，提出了最大程度地增强新输出特征的特征表示能力的最佳变换矩阵。此外，提出l2-l1训练策略来适应 Winograd AdderNet 范式并避免网络性能下降。 实验证明，AdderNet在FPGA中的计算量比baseline减少2.1倍，并保持与baseline相当的性能。 ","date":"09-27","objectID":"/2022/lightweight/:1:0","series":["segmentation"],"tags":["Lightweight"],"title":"轻量化网络内容小结","uri":"/2022/lightweight/#addernet"},{"categories":["我的炼丹日记"],"content":"GhostNetQ:由于嵌入式设备有限的内存和计算资源，导致CNN难以在嵌入式设备上得到应用。 Ghost Moudle （一个即插即用的模块） ：将常规卷积层分为两部分，第一部分是传统卷积层，但是数量受到严格控制；对第一部分得到的特征图再使用一系列简单地线性操作来生成更多的特征图。在不改变特征图尺寸的条件下，GM相较于普通的卷积减少大量参数量和计算复杂度。 GhonstNet：基于GM建立了有效的GNet。其中，首次使用GM替换网络中的常规卷积层来证明 Ghost 模块的有效性，然后在几个数据集上验证GN的性能。 实验证明GM相较于常规卷积，在减少计算量的情况下还保持了相当的性能。 ","date":"09-27","objectID":"/2022/lightweight/:2:0","series":["segmentation"],"tags":["Lightweight"],"title":"轻量化网络内容小结","uri":"/2022/lightweight/#ghostnet"},{"categories":["我的炼丹日记"],"content":"GPUNetQ：之前的网络在优化网络结构的同时也引入更多的参数，并低效的生成有效的特征图。 GP-moudle GPU-Net：一个轻量的UNet在有效减少参数量和FLOPs的情况下保持相当甚至更好地性能。也是第一篇探索将GM及其变种应用与UNet的论文。 ","date":"09-27","objectID":"/2022/lightweight/:3:0","series":["segmentation"],"tags":["Lightweight"],"title":"轻量化网络内容小结","uri":"/2022/lightweight/#gpunet"},{"categories":["我的炼丹日记"],"content":"Lite-HRNetQ： 在HRNet中使用shuffleNet中的Shuffle block。性能超过ShuffleNet、MobileNet。 引入轻量的条件通道加权单元 (权重从HRNet的并行分支中所有的通道和分辨率中学习得到) 来替换shuffle block中的点卷积，来减少计算量 (通道加权的复杂度与通道数成线性关系，低于逐点卷积的二次时间复杂度。) 。它使用权重作为跨通道和分辨率交换信息的桥梁，补偿逐点（1×1）卷积所起的作用。 ","date":"09-27","objectID":"/2022/lightweight/:4:0","series":["segmentation"],"tags":["Lightweight"],"title":"轻量化网络内容小结","uri":"/2022/lightweight/#lite-hrnet"},{"categories":["我的炼丹日记"],"content":"RegSegQ：现有的成功的网络极大依赖大计算量，如果没有足够大的感受野就无法作出最佳的选择。 受ResNeXt启发，设计了一个块结构。该结构并行使用两个有不同膨胀率的卷积，在增大网络感受野的同时保留局部信息。通过堆叠使用这个模块，可以在不使用额外计算量的条件下控制网络感受野。 提出一个轻量解码器，相较于常规解码器，该解码器能更好地恢复局部信息。 ","date":"09-27","objectID":"/2022/lightweight/:5:0","series":["segmentation"],"tags":["Lightweight"],"title":"轻量化网络内容小结","uri":"/2022/lightweight/#regseg"},{"categories":["我的炼丹日记"],"content":"RepMLPQ: 全连接层在长效依赖和位置信息建模方面表现优越，但是在捕获局部信息方面较弱。 提出利用 FC 的全局信息捕获能力和位置感知，并为其配备局部先验 (在RepMLP中的FC层中建立卷积层进行提取) 以进行图像识别。 提出了一种简单、与平台无关且可微分的算法，将并行 conv 和 BN 合并到局部先验的 FC 中，并且不需要消耗推理时间。 提出RepMLP，在许多视觉任务上都展示了其性能。 ","date":"09-27","objectID":"/2022/lightweight/:6:0","series":["segmentation"],"tags":["Lightweight"],"title":"轻量化网络内容小结","uri":"/2022/lightweight/#repmlp"},{"categories":["我的炼丹日记"],"content":"Swin-UnetQ：尽管CNN有出色的表现，但是由于卷积操作的局部性，它不能很好的学习到全局信息和长效语义信息。 基于Swin Transformer block，设计了对称的带跳跃连接的编解码结构。在编码器中实现了从局部到全局的自注意力机制，在解码器全局特征被上采样到输入尺寸大小来得到最终的分割结果。 开发了一个patch扩展层，在不使用卷积或插值操作的情况下实现上采样和特征维数增加。 建立纯Transformer的U形带跳跃连接结构，命名为SwinUnet。 ","date":"09-27","objectID":"/2022/lightweight/:7:0","series":["segmentation"],"tags":["Lightweight"],"title":"轻量化网络内容小结","uri":"/2022/lightweight/#swin-unet"},{"categories":["我的炼丹日记"],"content":"UNeXtQ:现有的U型网络（TransUnet）不能有效地用于即时应用中的快速图像分割，因为它们参数繁重、计算复杂且使用缓慢。 提出UNeXt，第一个基于卷积MLP的图像分割网络。 提出了一种轴向位移的tokenized MLP模块，有效地学习潜在空间的良好表示。 成功提高医学图像分割任务性能的同时减少参数量、提高推理速度并降低计算复杂度。 ","date":"09-27","objectID":"/2022/lightweight/:8:0","series":["segmentation"],"tags":["Lightweight"],"title":"轻量化网络内容小结","uri":"/2022/lightweight/#unext"},{"categories":["C++学习"],"content":"IO类iostream定义了用于读写流的基本类型 fstream定义了读写命名文件的类型 sstream定义了读写内存string对象的类型 ","date":"09-19","objectID":"/2022/io%E5%BA%93/:1:0","series":["C++ Primer"],"tags":["函数IO库"],"title":"C++学习之IO库","uri":"/2022/io%E5%BA%93/#io类"},{"categories":["C++学习"],"content":"IO对象无拷贝或赋值 ofstream out1, out2; out1 = out2; //错误：不能对流对象赋值 ofstream print(ofstream); //错误：不能初始化ofstream参数 out2 = print(out2); //错误：不能拷贝流对象 由于不能拷贝io对象，因此也不能将形参或返回类型设置为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 一个IO错误的例子： int ival; cin \u003e\u003e ival; 输入运算符期待读取一个int，但是得到一个字符B，这样就会错误。 一个流一旦错误，后续的IO操作都会失败。只有在流处于无错状态时，才能正常读写数据。 由于流可能处于错误状态，因此在使用前需要对其进行检查，最简单的方法是将其当作一个条件来使用： while(cin \u003e\u003e word) // ok,读操作成功 while循环检查»表达式返回的流的状态。如果输入成功，流保持有效状态，则条件为真。 ","date":"09-19","objectID":"/2022/io%E5%BA%93/:1:1","series":["C++ Primer"],"tags":["函数IO库"],"title":"C++学习之IO库","uri":"/2022/io%E5%BA%93/#io对象无拷贝或赋值"},{"categories":["C++学习"],"content":"管理条件状态流对象的rdstate成员返回一个iostate值，对应流的当前状态。 setstate操作将给定条件位置位，表示发生对应错误。 clear成员是一个重载的成员：他有一个不接受版本的参数，而另一个版本即诶搜一个iostate类型的参数。clear不接受参数的版本清除所有错误标志为，执行clear()后，调用good会返回true。可以这样使用这些成员： auto old_satate = cin.rdstate(); cin.clear(); //使cin有效 process_input(cin); //使用cin cin.setstate(old_state); //将cin置为原有状态 带参数的clear版本接受一个iostate值，表示流的新状态。为了复位单一的条件状态位，首先永rdstate读出当前条件状态，然后用复位操作来生成新的状态。 //复位failbit和badbit，保持其他标志位不变 cin.clear(cin.rdstate() \u0026 ~cin.failbit \u0026 ~bin.badbit); ","date":"09-19","objectID":"/2022/io%E5%BA%93/:1:2","series":["C++ Primer"],"tags":["函数IO库"],"title":"C++学习之IO库","uri":"/2022/io%E5%BA%93/#管理条件状态"},{"categories":["C++学习"],"content":"管理输出缓冲每个输出流都管理一个缓冲区，用来保存程序读写的数据。如果执行以下代码 os \u003c\u003c \"please enter a value:\"; 文本可能立即打印出来，也可能保存在缓冲区随后再打印。操作系统可以使用缓冲机制将程序的多个输出操作组合成单一的系统级写操作。由于设备的写操作可能很好事，允许操作系统将多个输出操作组合为单一的设备写操作可以带来很大的性能提升。 导致缓冲刷新的原因有很多： 程序正常结束，作为main函数的return操作的一部分，缓冲刷新被执行。 缓冲区满，需要刷新缓冲。 使用操纵符如endl来显式刷新缓冲区。 每个输出操作后，可以使用操纵符unitbuf设置流的内部状态，来清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。 一个输出流可能被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，默认情况下，cin和cerr都关联到cout。因此，读cin或写cerr都会导致cout的缓冲区被刷新。 ","date":"09-19","objectID":"/2022/io%E5%BA%93/:2:0","series":["C++ Primer"],"tags":["函数IO库"],"title":"C++学习之IO库","uri":"/2022/io%E5%BA%93/#管理输出缓冲"},{"categories":["C++学习"],"content":"刷新输出缓冲区endl操纵符完成换行并刷新缓冲区的工作。IO库还有两个类似的操纵符：flush和ends。flush刷新缓冲区，但不输出任何额外的字符；ends向缓冲区插入一个空字符，然后刷新缓冲区： cout \u003c\u003c \"hi!\" \u003c\u003c endl; //输出hi和一个换行，然后刷新缓冲区 cout \u003c\u003c \"hi!\" \u003c\u003c flush; //输出和i，然后刷新缓冲区，不附加任何额外字符 cout \u003c\u003c \"hi!\" \u003c\u003c ends; //输出hi和一个空字符，然后刷新缓冲区 ","date":"09-19","objectID":"/2022/io%E5%BA%93/:2:1","series":["C++ Primer"],"tags":["函数IO库"],"title":"C++学习之IO库","uri":"/2022/io%E5%BA%93/#刷新输出缓冲区"},{"categories":["C++学习"],"content":"unitbuf操纵符如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操纵符。它使流在接下来的每次写操作之后都进行一次flush操作，而nounitbuf操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制： cout \u003c\u003c unitbuf; // 所有输出操作后都会立即刷新缓冲区 // 任何输出都立即刷新，无缓冲 cout \u003c\u003c nounitbuf; // 回到正常的缓冲方式 如果程序异常终止，输出缓冲区不会被刷新，输出的数据可能停留在输出缓冲区中等待打印 因此在调试一个已经崩溃的程序时，需要确认输出的数据确实已经刷新了。 ","date":"09-19","objectID":"/2022/io%E5%BA%93/:2:2","series":["C++ Primer"],"tags":["函数IO库"],"title":"C++学习之IO库","uri":"/2022/io%E5%BA%93/#unitbuf操纵符"},{"categories":["C++学习"],"content":"关联输入和输出流当一个输入流被关联到一输出流使，任何试图从输入流中读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起，因此 cin \u003e\u003e ival; 导致cout的缓冲区被刷新。 tie有两个重载的版本：一个版本不带参数，返回指向输出流的指针。如果本对象当前关联到一个输出流，返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针。tie的第二个版本接受一个指向ostream的指针，将自己关联到此ostream。即，x.tie(\u0026o)，将流x关联到输出流o。 既可以将一个istream对象关联到另一个ostream，也可以将一个ostreaim关联到另一个ostream。 cin.tie(\u0026cout); //old_tie指向当前关联到cin的流 ostream *old_tie = cin.tie(nullptr); //cin不再与其他流关联 // 将cin与cerr关联 cin.tie(\u0026cerr); //读取cin会刷新cerr cin.tie(old_tie); //重建cin和cout之间的正常关联 为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给tie，为了彻底解开流的关联，传递一个空指针。每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream。 ","date":"09-19","objectID":"/2022/io%E5%BA%93/:2:3","series":["C++ Primer"],"tags":["函数IO库"],"title":"C++学习之IO库","uri":"/2022/io%E5%BA%93/#关联输入和输出流"},{"categories":["C++学习"],"content":"cin.get()在接收到任意输入后再执行下一条语句。 ","date":"07-06","objectID":"/2022/review/:0:1","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#cinget"},{"categories":["C++学习"],"content":"声明语句使用变量前必须声明它。 尽可能在首次使用变量前声明它。 要将信息项存储在计算机中，必须之处信息的存储位置和所需的内存空间。在C++中，完成这种任务相对简便的方法是使用声明语句之处存储类型，并提供位置标签。 声明通常指出要存储的数据类型和程序对存储在这里的数据使用的名称。 程序中的声明语句叫做定义声明语句，简称定义。这意味着它将导致编译器为变量分配内存空间。 ","date":"07-06","objectID":"/2022/review/:0:2","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#声明语句"},{"categories":["C++学习"],"content":"赋值语句C++中有一项不寻常的特性，可以连续使用赋值运算符。 int s; int b; int y; y = b = s = 88; 赋值从右往左进行，先将88赋给s，再将s的值赋给b，最后将b的值赋给y。 ","date":"07-06","objectID":"/2022/review/:0:3","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#赋值语句"},{"categories":["C++学习"],"content":"函数原型只描述函数接口，描述的是发送给函数的信息和返回的信息。 而定义中包含函数的代码。 应该在首次使用函数之前提供原型，通常的做法是把原型放到main()函数定义的前面。 void simon(int n){ cout \u003c\u003c n \u003c\u003c \"times.\" \u003c\u003cendl; } int simple = simon(3); //错误，因为simon没有返回值。 ","date":"07-06","objectID":"/2022/review/:0:4","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#函数"},{"categories":["C++学习"],"content":"运算符sizeof可以对类型名或变量名使用sizeof运算符。对类型名(如int)使用sizeof运算符时，应将名称放在括号中；但对变量名使用sizeof运算符，括号则是可选的。 int max = INT_MAX; cout \u003c\u003c \"int is \" \u003c\u003c sizeof(int) \u003c\u003c \"bytes.\" cout \u003c\u003c \"int is \" \u003c\u003c sizeof(max) \u003c\u003c \"bytes.\" cout \u003c\u003c \"int is \" \u003c\u003c sizeof max \u003c\u003c \"bytes.\" ","date":"07-06","objectID":"/2022/review/:0:5","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#运算符sizeof"},{"categories":["C++学习"],"content":"头文件limits头文件climits定义了符号常量来表示类型的限制。详细可参考。 ","date":"07-06","objectID":"/2022/review/:0:6","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#头文件limits"},{"categories":["C++学习"],"content":"C++11初始化方式 int emus{7} //set eum to 7 int rheas = {12} // set rhea to 12 int rocs = {} // set roc to 0 int psychics{} //set psychics to 0 ","date":"07-06","objectID":"/2022/review/:0:7","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#c11初始化方式"},{"categories":["C++学习"],"content":"cout.put()函数该函数显示一个字符。 ","date":"07-06","objectID":"/2022/review/:0:8","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#coutput函数"},{"categories":["C++学习"],"content":"signed char 和 unsigned char与int不同，char在默认情况下，既不是没有符号也不是有符号。是否由符号由C++实现决定。如果char有某种特定行为特别重要，则可以显式的将类型设置为signed char或unsigned char。 char fodo; //may be signed, may be unsigned unsigned char bar; //definitely usigned signed char snark; //definitely signed ","date":"07-06","objectID":"/2022/review/:0:9","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#signed-char-和-unsigned-char"},{"categories":["C++学习"],"content":"const限定符创建常量的通用格式如下： const type name = value; 应当在声明时就对const进行初始化，如果在声明常量时没有初始化，则该常量的值将是不确定的，且无法修改。 为什么const比define好 const能够明确指定类型。 const可以使用C++的作用域规则将定义限制在特定的函数或。 可以将const用于更复杂的类型。 ","date":"07-06","objectID":"/2022/review/:0:10","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#const限定符"},{"categories":["C++学习"],"content":"类型转换","date":"07-06","objectID":"/2022/review/:1:0","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#类型转换"},{"categories":["C++学习"],"content":"初始化和赋值进行的转换假如so_long的类为long ","date":"07-06","objectID":"/2022/review/:1:1","series":["C++ Primer"],"tags":["Review"],"title":"Review","uri":"/2022/review/#初始化和赋值进行的转换"},{"categories":["C++学习"],"content":"构造函数 类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是初始化类对象的数据成员。 构造函数没有返回类型，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，不同的构造函数之间必须在参数数量或参数类型上有所区别。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#构造函数"},{"categories":["C++学习"],"content":"默认构造函数 如果类中没有显式的定义构造函数，那么编译器会隐式的定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数，对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员。 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#默认构造函数"},{"categories":["C++学习"],"content":"=default的含义如果我们需要默认的行为，那么可以通过在参数列表后写上 =default要求编译器生成构造函数。其中，=default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果=default出现在类的内部，则默认构造函数是内联的；如果在类的外部，则该成员默认情况下不是内联的。 Sales_data(const std::string\u0026s): book(s){} Sales_data(const std::string\u0026s, unsigned n, double p): book(s), units_sold(n), revenue(p*n){} 函数名和花括号之间的部分称为构造函数初始值列表，负责为新创建的对象的一个或几个数据成员赋初值。 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果不能使用类内初始值，则所有构造函数都应该显式的初始化每个内置类型的成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#default的含义"},{"categories":["C++学习"],"content":"构造函数初始值列表我们定义变量时习惯于立即对其进行初始化，而非先定义、再赋值： string foo = \"Hello World!\"; //定义并初始化 string bar; //默认初始化成string对象 bar = \"Hello World!\"; //为bar赋一个新值 就对象的数据成员而言，初始化和赋值也有类似的区别。如果没有在构造函数的初始值列表中显式的初始化成员，则该成员将在构造函数体之前执行默认初始化。 Sales_data::Sales_data(const string \u0026s, unsigned cnt, double price){ bookNo = s; units_sold = cnt; revenue = cnt * price; } 先前的版本是初始化了它的数据成员，而这个版本是对数据成员进行赋值操作。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#构造函数初始值列表"},{"categories":["C++学习"],"content":"构造函数的初始值有时必不可少有时可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者引用的话，必须将其初始化，类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。 class ConstRef{ public: ConstRef(int ii); private: int i; const int ci; int \u0026ri; }; 和其他 常量对象或引用一样，成员ci和ri都必须被初始化。因此，如果我们没有为它们提供构造函数初始值的话将会引发错误： ConstRef::ConstRef{int ii}{ i = ii; ci = ii; //错误，不能给const赋值 ri = i; //错误，ri没初始化 } 随着构造函数体一开始执行，初始化就完成。初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此该构造函数的正确形式是： ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(ii){} ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#构造函数的初始值有时必不可少"},{"categories":["C++学习"],"content":"成员初始化的顺序成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置不会影响实际的初始化顺序。 如果一成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。 class X{ int i; int j; public: //i在j之前被初始化 X(int val):j(val), i(j){} }; 实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的值j初始化i。 最好令构造函数初始值的顺序和成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。 可能的话，最好使用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是可以不必考虑成员的初始化顺序。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#成员初始化的顺序"},{"categories":["C++学习"],"content":"默认实参和构造函数Sales_data默认构造函数的行为与只接受一个string实参的构造函数差不多。唯一的区别就是接受string实参的构造函数使用这个实参初始化bookNo，而默认构造函数（隐式的）使用string的默认构造函数初始化bookNo。我们可以将它们写成一个使用默认实参的构造函数。 class Sales_data{ public: // 定义默认构造函数，令其只接受一个string实参的构造函数功能相同 Sales_data(std::string s = “ ”):bookNo(s){} // 其他构造函数与之前一致 Sales_data(std::string s, unsigned cnt, double rev):bookNo(s), units_sold(cnt), revenue(rev*cnt){} Sales_data(std::istream \u0026is){ read(is,*this); } }; 当没有给定实参，或者给定一个string实参时，两个版本的类创建了相同的对象。 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:6","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#默认实参和构造函数"},{"categories":["C++学习"],"content":"委托构造函数一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把自己的一些（或全部）职责委托给了其他构造函数。 一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员的初始值一样，类名后边紧跟圆括号括起来的参数列表，参数列表必须与类中另一个构造函数相匹配。 class Sales_data{ public: //非委托构造函数使用对用的实参初始化成员 Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} //其余构造函数全都委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0){} Sales_data(std::string s):Sales_data(s,0,0){} Sales_data(std::istream \u0026is): Sales_data(){ read(is, *this); } }; 在上面的例子中，除了一个构造函数外，其他的都委托了他的工作。第一个构造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。我们定义默认构造函数令其使用三参数的构造函数完成初始化过程，它也无须执行其他任务。 接受istream\u0026的构造函数也是委托构造函数，它委托给默认构造函数，默认构造函数函数又委托给三参数构造函数。当受委托的构造函数执行完成后，接着执行istream\u0026构造函数体的内容。它的构造函数体调用read函数读取给定的istream。 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在Sales_data类中，受委托的构造函数体恰好是空的。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:7","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#委托构造函数"},{"categories":["C++学习"],"content":"默认构造函数的作用当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况发生： 当我们在块作用域内不使用任意初始值定义一个非静态变量或者数组时。 当一个类本身含有类类型的成员且使用合成的默认构造函数时。 当类类型的成员没有在构造函数初始值列表中显式的初始化时。 值初始化在以下情况发生： 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。 当我们不使用初始值定义一个局部静态变量时。 当我们通过书写形如T()的表达式显式的请求值初始化时，其中T是类型名。 类必须包含一个默认构造函数以便在上述情况下使用，其中大多数情况非常容易判断。 不那么明显的一种情况是类的某些数据成员缺少默认构造函数： class NoDefault{ public: NoDefault(const std::string\u0026); // 还有其他成员，但是没有其他构造函数了 }; struct A { //默认情况下，my_mem是public的 NoDefault my_eme; }; A a; // 错误，不能为A合成构造函数 struct B { B() {} //错误，b_member没有初始值 NoDefault b_member; }; 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:8","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#默认构造函数的作用"},{"categories":["C++学习"],"content":"使用默认构造函数下面的obj的声明可以正常编译通过： Sales_data obj(); // 正确：定义了一个函数而非对象 if (obj.isbn == Primer_5th_ed.isbn()) // 错误，obj是一个函数 Sales_data obj2; // 正确，obj2是一个对象而非函数。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:9","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#使用默认构造函数"},{"categories":["C++学习"],"content":"拷贝、赋值和析构除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。如果不主动定义这些操作，编译器将替我们合成它们。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:2:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#拷贝赋值和析构"},{"categories":["C++学习"],"content":"某些类不能依赖于合成的版本尽管编译器可以替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:2:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#某些类不能依赖于合成的版本"},{"categories":["C++学习"],"content":"访问控制与封装 定义在 public 说明符之后的成员在整个程序内可被访问，public成员定义类的接口。 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:3:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#访问控制与封装"},{"categories":["C++学习"],"content":"使用class或struct关键字struct和class之间的唯一一点区别就是，struct和class的默认访问权限不同。 如果使用struct关键字，则定义在第一个访问说明符之前的成员时public的；相反，如果使用class关键字，则这些成员是private的。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:3:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#使用class或struct关键字"},{"categories":["C++学习"],"content":"友元类可以允许其他类或函数访问它的非公有成员，方法是令其他类或者函数成为他的友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字展开的函数声明语句即可。 class Sales_data{ friend Sales_data add(const Slaes_data\u0026, const Slaes_data\u0026); }; 友元声明只能出现在类定义的内部，但是在类内出现的位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。 一般来说，最好在类定义开始或结束前的位置集中声明友元。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#友元"},{"categories":["C++学习"],"content":"友元的声明友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，那么就必须在友元声明之外再专门对函数进行一次说明。 为了使友元对类的用户可见，通常把友元的声明和类本身放置在同一个头文件中。 除了可以将普通的函数定义成友元，类还可以把其他类定义成友元，也可以把其他类的成员函数定义成友元。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#友元的声明"},{"categories":["C++学习"],"content":"类之间的友元关系假设需要为window_mgr类添加一个名为clear的成员，负责将一个指定的Screen的内容设为空白。为完成这一任务，clear需要访问Screen的私有成员；要令这种行为合法，Screen需要将window_mgr指定成它的友元。 class Screen{ friend class window_mgr; }; 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。通过上面的声明，window_mgr被指定为Screen的友元，因此可以将window_mgr的clear成员写成如下形式： class window_mgr{ public: using ScreenIndex = std::vector\u003cScreen\u003e::size_type; void clear(ScreenIndex); private: std::vector\u003cScreen\u003e screens{Screen(24, 80, ' ')}; }; void window_mgr::clear(ScreenIndex i){ Screen \u0026s = screens[i]; //s是想清空的屏幕 s.contents = string(s.height * s.width, ' '); //将选定的屏幕重置为空白 } 需要注意的是，友元关系不存在传递性。也就是说，如果window_mgr有它自己的友元，则这些友元不能理所当然的具有访问Screen的特权。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类之间的友元关系"},{"categories":["C++学习"],"content":"令成员函数作为友元除了令整个window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，必须明确指出该成员函数属于哪个类： class Screen{ // window_mgr::clear必须在Screen类之前被声明 friend void window_mgr::clear(ScreenIndex); // Screen类的剩余部分 }; 要令某个成员函数作为友元，必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在本例中，按照如下方式设计程序： 首先定义window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 接下来定义Screen，包括对于clear的友元声明。 最后定义clear，此时它才可以使用Screen的成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#令成员函数作为友元"},{"categories":["C++学习"],"content":"函数重载和友元尽管重载函数的名字相同，但他们仍是不同的函数。因此，如果想把一组重载函数声明成它的友元，需要对这组函数的每一个分别声明： extern std::ostream\u0026 storeOn(sdt::ostream \u0026, Screen \u0026); extern BitMap\u0026 storeOn(BitMap \u0026, Screen \u0026); class Screen{ friend std::ostream\u0026 storeOn(sdt::ostream \u0026, Screen \u0026); }; Screen类把接受ostream\u0026的storeOn声明成它的友元，但是接受BitMap\u0026作为参数的版本仍然不能访问Screen。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#函数重载和友元"},{"categories":["C++学习"],"content":"友元声明和作用域类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，他也必须是声明过的： struct X { frined void f(); X() { f(); } void g(); void h(); }; void X::g() { return f(); } // 错误，f没有被声明 void f(); void X::h() { return f(); } // 正确，现在f的声明在作用域中 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#友元声明和作用域"},{"categories":["C++学习"],"content":"类的其他特性","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类的其他特性"},{"categories":["C++学习"],"content":"定义一个类型成员 class Screen{ public: typedef std::string::size_type pos; private: pos sursor = 0; pos height = 0, width = 0; std::string contents; }; 在Screen的public部分定义pos，这样用户就可以使用这个名字。 关于pos的定义又两点需要注意。首先，我们使用了typedef，也可以等价的使用类型别名： class Screen{ public: using pos = std::string::size_type; }; 其次，用来定义类型的成员必须先定义后使用。类的成员通常出现在类开始的地方。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#定义一个类型成员"},{"categories":["C++学习"],"content":"Screen类的成员函数 #include \u003ciostream\u003e using namespace std; class Screen{ public: typedef std::string::size_type pos; Screen() = default;//Screen有另一个构造函数，所以本函数是必须的。 Screen(pos ht, pos wd, char c):height(ht), width(wd), contents(ht*wd,c){}//cursor初始值初始化为0 char get() const{ return contents[cursor]; //隐式内联 } inline char get(pos ht, pos wd) const; //显式内联 Screen \u0026move(pos r, pos c); //能在之后设置为内联 private: pos cursor = 0; pos height = 0, width = 0; std::string contents; }; 因为已经提供一个构造函数，所以编译器不会自动生成默认的构造函数。如果类需要默认构造函数，就必须显式的把它声明出来。 在第二个构造函数为cursor成员隐式的使用类内初始值。如果类中不存在cursor的类内初始值，就需要像其他成员一样显式的初始化cursor。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#screen类的成员函数"},{"categories":["C++学习"],"content":"令成员作为内联函数在类中，常有一些规模较小的函数适合于被声明为内联函数，定义在类内部的成员函数都是自动inline的。 我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样地，也能在类的外部用inline关键字修饰函数的定义。 inline //在函数的定义处指定inline Screen \u0026Screen::move(pos r, pos c){ pos row = r * width; // 计算行的位置 cursor = row + c; //在行内将光标移动到指定列 return *this; //以左值的形式返回对象 } char Screen::get(pos r, pos c) const{ // 在类的内部声明成inline pos row = r * width; //计算行的位置 return contents[row + c]; //返回给定字符 } 最好只在类外部定义的地方说明inline，这样可以使类更容易理解。inline函数应该与相应的类定义在同一个头文件中。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#令成员作为内联函数"},{"categories":["C++学习"],"content":"重载成员函数和非成员函数一样，成员函数也可以被重载，只要函数之间在参数的数量和/或类型上有所区别即可。成员函数的函数匹配过程同样与非成员函数十分类似。 Screen myscreen; char ch = myscreen.get(); //Screen::get() ch = myscreen.get(0,0); // Screen::get(pos,pos) ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#重载成员函数"},{"categories":["C++学习"],"content":"可变数据成员有时我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入 mutable关键字做到这一点。 一个可变数据成员永远不会是const，即使它是const对象的成员，因此，一个const成员函数可以改变一个可变成员的值。 class Screen{ public: void some_member() const; private: mutable size_t access_ctr; //即使在一个const对象内也能被修改 }; void Screen::some_member() const{ ++access_ctr; //保存一个计数值，用于记录成员函数被调用的次数 } ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#可变数据成员"},{"categories":["C++学习"],"content":"类数据成员的初始值在定义好Screen类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一组Screen。这个类将包含一个Screen类型的vector，每个元素表示一个特定的Screen。默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的Screen。在C++11标准中，最好的方式就是把这个默认值声明成一个类内初始值： class Windoe_mgr{ private: std::vector\u003cScreen\u003e screens{Screen(24, 80, ' ')}; }; 类内初始值必须使用=的初始化形式或者花括号阔气来的直接初始化形式。 当我们提供一个类内初始值时，必须以符号=或花括号结尾 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:6","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类数据成员的初始值"},{"categories":["C++学习"],"content":"返回*this的成员函数 class Screen{ public: typedef std::string::size_type pos; Screen \u0026set(char); Screen \u0026set(pos, pos, char); }; inline Screen \u0026Screen::set(char c){ contents[cursor] = c; // return *this; //将this对象作为左值返回 } inline Screen \u0026Screen::set(pos r, pos col, char ch){ contents[r * width + col] = ch; return *this; } 返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本，如果将一系列的操作连接在一条表达式中的话： myScreen.move(4,0).set('#'); 如果令move和set返回的是Screen而非Screen\u0026的话，上述语句行为将大不相同，等价于： Screen temp = myScreen.move(4,0); //对返回值进行拷贝 temp.set('#'); // 不会改变myScreen的contents 如果定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变没有Screen的值。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:6:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#返回this的成员函数"},{"categories":["C++学习"],"content":"从const成员函数返回*this一个const成员函数如果以引用的形式返回*this，那么它的返回类将是常量引用。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:6:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#从const成员函数返回this"},{"categories":["C++学习"],"content":"基于const的重载 class Screen{ public: typedef std::string::size_type pos; Screen \u0026display(std::ostream \u0026os){ do_display(os); return *this; } Screen \u0026display(std::ostream \u0026os) const{ do_display(os); return *this; } private: void do_display(std::ostream \u0026os) const{ os \u003c\u003c contents; } 当display调用do_display时，它的this指针隐式的传递给do_display。当display的非常量版本调用do_display时，它的this指针将隐式的从指向非常量的指针转换成指向常量的指针。 当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个非常量的引用；而const成员则返回一个常量引用。 当在某个对象上调用display时。该对象是否是const决定了应该调用disply的哪个版本。 Screen myScreen(5,3); const Screen blank(5,3); myScreen.set('#').display(cout); //非常量版本 blank.display(cout); //常量版本 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:6:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#基于const的重载"},{"categories":["C++学习"],"content":"类类型对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:7:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类类型"},{"categories":["C++学习"],"content":"类的声明像可以把函数的声明和定义分开来一样，也可以先声明类而不定义它。 class Screen; 这种声明有时被称为前向声明，向程序中引入名字Screen并指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型，此时只知道Screen是一个类类型，但不清楚其包含哪些成员。 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但不能定义）以不完全类型作为参数或返回类型的函数。 直到类被定义之后数据成员才能被声明成这种类类型。只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:7:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类的声明"},{"categories":["C++学习"],"content":"类的作用域每个类都会定义自己的作用域，在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类类型成员则使用作用域运算符进行访问。不论哪种情况，跟在运算符之后的名字都必须是对应类的成员： Screen::pos ht = 24, wd = 80; // 使用Screen定义的pos类型 Screen scr(ht, wd, ' '); Screen *p = \u0026scr; char c = scr.get(); // 访问scr对象的get成员 c = p -\u003e get(); // 访问p所指对象的get成员 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:8:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类的作用域"},{"categories":["C++学习"],"content":"作用域和定义在类外部的成员类一旦遇到类名，定义的剩余部分就在类的作用域之内，这里的剩余部分包括参数列表和函数体。结果就是，可以直接使用类的其他成员而无须再次授权。 void window_mgr::clear(ScreenIndex){ Screen \u0026s = screen[i]; s.contents = string(s.height * s.width, ' '); } 因为编译器在处理参数列表之前已经明确了我们当前正位于window_mgr类的作用域中，所以不必再专门说明ScreenIndex是window_mgr声明的。出于同样的原因，编译器也能知道函数体中用到的screens也是在window_mgr类中定义的。 另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。例如，向window_mgr类中添加一个新的名为addScreen的函数，负责向显示器添加一个新的屏幕。这个成员的返回类型将是ScreenIndex，用户可以通过它定位到指定Screen： class window_mgr{ public: ScreenIndex addScreen(const creen\u0026); }; window_mgr::ScreenIndex window_mgr::addScreen(const Screen \u0026s){ screens.push_back(s); return screen.size() - 1; } 因为返回类型出现在类名之前，所以事实上它是位于window_mgr类的作用域之外的。在这种情况下，要想使用ScreenIndex作为返回类型，我们必须明确指定哪个类定义了它。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:8:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#作用域和定义在类外部的成员类"},{"categories":["C++学习"],"content":"名字查找与类的作用域 首先在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。 如果没找到，继续查找外层作用域。 如果最终没有找到匹配的声明，则程序报错。 对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别。类的定义分两步处理： 首先，编译成员的声明。 直到类全部可见后才编译函数体。 按照这种两阶段的方式处理类可以简化类代码的组织方式。因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#名字查找与类的作用域"},{"categories":["C++学习"],"content":"用于类成员声明的名字查找两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须确保在使用前可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。例如： typedef double Money; string bal; class Account{ public: Money balance(){ return bal; } private: Money bal； }; 当编译器看到balance函数的声明语句时，将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到类的外层作用域中查找。在本例中，编译器会找到Money的typedef语句。另外ia，balance函数体在整个类可见后才被处理，因此，该函数返回名为bal的成员，而非外层作用域的string对象。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#用于类成员声明的名字查找"},{"categories":["C++学习"],"content":"类姓名要特殊处理在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。 typedef double Money; class Account{ public: Money balance(){ return bal; } private: typedef double Money; // 错误，不能重新定义Money Money bal; }; 需要注意的是，即使Account中定义的Money类型与外层作用域一致，上述代码仍然是错误的。 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类姓名要特殊处理"},{"categories":["C++学习"],"content":"成员定义中普通块作用域的名字查找c成员函数中使用的名字按照如下方式解析: 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。 一般来说，不建议使用其他成员的名字作为某个成员函数的参数。 int height; class Screen{ public: typedef std::string::size_type pos; void dummy_fcn(pos height){ cursor = width * height; //使用哪个height } private: pos cursor = 0; pos height = 0, width = 0; }; 当编译器处理dummy_fcn中的乘法表达式时，首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明。 此例中，height参数隐藏了同名的成员。如果想绕开上面的查找规则1，应该将代码变为： // 成员函数中的名字不应该隐藏同名成员 void Screen::dummy_fcn(pos height){ cursor = width * this-\u003eheight; //另一种表示该成员的方式 cursor = width * Screen::height; } 最好的确保使用height成员的方法是给参数起个其他名字： //建议的写法：不要把成员名字作为参数或其他局部变量使用 void Screen::dummy_fcn(pos ht){ cursor = width * height; } 在此例中，编译器查找名字height时，在dummy_fcn函数内部是找不到的。编译器接着会在Screen内查找匹配的声明，即使height的声明在dummy_fcn使用它之后，编译器也能正确地解析函数使用的是名为height的成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#成员定义中普通块作用域的名字查找"},{"categories":["C++学习"],"content":"类作用域之后，在外围的作用域中查找如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。在我们的例子中。名字height定义在外层作用域中。且位于Screen的定义之前。然而，外层作用域中的对象被名为height的成员隐藏掉了。因此，如果我们需要的是外层作用域中的名字，可以显式的通过作用域运算符进行请求： //不建议的写法，不要隐藏外层作用域中可能被用到的名字 void Screen::dummy_fcn(pos height){ cursor = width * ::height; } ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类作用域之后在外围的作用域中查找"},{"categories":["C++学习"],"content":"在文件中名字出现处对其进行解析当成员定义在类的外部时，名字查找的第三步不仅要考虑定义之前的全局作用域中的声明，还要考虑在成员函数定义之前的全局作用域中的声明。 int height; class Screen{ public: typedef std::string::size_type pos; void setHeight(pos); pos height = 0; //隐藏外层作用域中的height }; Screen::pos verify(Screen::pos); void Screen::setHeight(pos var){ //var：参数 //height：类的成员 //verify：全局函数 height = verify(var); } 全局函数verify的声明在Screen的定义之前是不可见的。然而，名字查找的第三步包括了成员函数出现之前的全局作用域。在此例中，verify的声明位于setHeight的定义之前，因此可以被正常使用。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#在文件中名字出现处对其进行解析"},{"categories":["C++学习"],"content":"隐式的类类型转换如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们将这种构造函数称为转换构造函数。 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。 在Saels_data类中，接受string的构造函数和接受istream的构造函数分别定义了两种类型向Sales_data隐式转换的规则。也就是说，在需要使用Sales_data的地方，我们可以使用string和istream作为替代： string null_book = \"9-999-99999-9\"; // 建立一个临时的Sales_data对象 //该对象的units_sold和revenue等于0，bookNo等于null_boook item.combine(null_book); 这里我们用一个string实参调用Sales_data的combine成员。该调用是合法的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#隐式的类类型转换"},{"categories":["C++学习"],"content":"只允许一步类类型转换编译器只会自动的执行一步类型转换。例如，下边的代码隐式的使用了两种转换规则，所以它是错误的： // 错误，需要用户定义的两种转换： // （1）把“9-999-99999-9”转换成string // （2）再把临时的string转换为Sales_data item.combine(\"9-999-99999-9\"); 如果想完成上述调用，可以显式的把字符串转换为string或Sales_data对象： // 正确：显式的转换成string，隐式的转化成Sales_data item.combine(string(\"9-999-99999-9\")); // 正确：隐式的转换为string，显式的转换为Slaes_data item.combine(Sales_data(\"9-999-99999-9\")); ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#只允许一步类类型转换"},{"categories":["C++学习"],"content":"类类型转换不是总有效是否需要从string到Sales_data的转换依赖于我们对用户使用该转换的看法。在此例中，这种转换可能是对的。null_book中的string可能表示了一个不存在的ISBN编号。 另一个是从istream到Sales_data的转换： // 使用istream构造函数创建一个函数传递给combine item.combine(cin); 这段代码隐式的把cin转换成Sales_data，这个转换执行了接受一个istream的Sales_data构造函数。该构造函数通过读取标准输入创建了一个临时的Sales_data对象，随后将得到的对象传递给combine。 Sales_data对象是个临时量，一旦combine完成我们就不能再访问它。实际上，我们构建一个对象，先将它的值加到item中，随后将其丢弃。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类类型转换不是总有效"},{"categories":["C++学习"],"content":"抑制构造函数定义的隐式转换在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止： class Sales_data{ public: Sales_data() = default; Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} explicit Sales_data(const std::string \u0026s):bookNo(s){} explicit Sales_data(std::istream \u0026is); 此时，没有任何构造函数能够用于隐式的创建Sales_data对象，之前的两种用法都无法通过编译： item.conbine(null_book); // 错误，string构造函数是explicit的 item.combine(cin); // 错误，istream构造函数是explicit的 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的，只需要在类内声明构造函数时使用explicit关键字，在类外部定义时不用重复： // 错误：explicit关键字只允许出现在类内的构造函数声明处 explicit Sales_data::Sales_data(isteam\u0026 is){ rean(is, *this); } ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#抑制构造函数定义的隐式转换"},{"categories":["C++学习"],"content":"explicit构造函数只能用于直接初始化发生隐式转换的一种情况是当我们执行拷贝形式的初始化时。此时，我们只能使用直接初始化，而不能使用explicit构造函数： Sales_data item1(null_book); // 正确，直接初始化 // 错误，不能将explicit构造函数用于拷贝形式的初始化过程诶 Sales_data item2 - null_book; ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#explicit构造函数只能用于直接初始化"},{"categories":["C++学习"],"content":"为转换显式的使用构造函数尽管编译器不会将explicit的构造函数用于隐式转换过程，但是可以使用这样的构造函数显式的强制进行转换： // 正确，实参是一个显式构造的Sales_data对象 item.combine(Sales_data(null_book)); // 正确：static_cast可以使用explicit的构造函数 item.combine(Sales_data(static_cast\u003cSales_data\u003e(cin))) 在第一个调用中，直接使用Sales_data的构造函数，该调用通过接受string的构造函数创建了一个临时的Sales_data对象。 在第二个调用中，使用static_cast执行了显式而非隐式的转换。其中，static_cast使用istream构造函数创建了一个临时的Sales_data对象。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#为转换显式的使用构造函数"},{"categories":["C++学习"],"content":"标准库中含有显式构造函数的类我们用过一些白赚苦衷的类含有单参数的构造函数： 接受一个单参数的const char*的string构造函数不是explicit的。 接受一个容量参数的vector构造函数是explicit的。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:6","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#标准库中含有显式构造函数的类"},{"categories":["C++学习"],"content":"聚合类聚合类使得用户可以直接访问其成员，并具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的。 所有成员都是public的。 没有定义任何构造函数。 没有类内初始值。 没有基类，也没有virtual函数。 下面的类是一个聚合类。 struct Data { int ival; string s; }; 可以使用一个花括号括起来的成员初始值列表，并用它初始化聚合类的数据成员。 // val1.ival = 0, val1.s = string(\"Anna\") Data val1 = {0, \"Anna\"}; 初始值的顺序必须与声明的顺序一致。下面的例子是错误的： Data val2 = {\"Anna\"， 0}; 与初始化数组元素的规则一致，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。 显式的初始化类的对象的成员存在三个明显的缺点： 要求类的所有成员都是pubic的。 将正确初始化每个对象每个成员的重任交给了类的用户。 添加或删除一个成员之后，所有的初始化语句都需要更新。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:11:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#聚合类"},{"categories":["C++学习"],"content":"字面值常量constexpr函数的参数和返回值必须是字面值类型。除了算数类型、引用和指针外，某些值也是字面值类型。和其他类不同，字面值类型的类可能含有constexpr函数成员。这样的成员必须符合constexpr函数的所有要求，它们是隐式const的。 数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但他符合下述要求，则它也是一个字面值常量类： 数据成员都必须是字面值类型。 类必须至少含有一个constexpr构造函数。 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。 类必须使用析构函数的默认的定义，该成员负责销毁类的对象。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:12:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#字面值常量"},{"categories":["C++学习"],"content":"constexpr构造函数尽管构造函数不能是const的，但是字面值常量类的构造函数可以是constexpr函数。事实上，一个字面值常量类必须至少提供一个constexpr构造函数。 constexpr构造函数可以声明成=default的形式。否则constexpr构造函数就必须既符合构造函数的要求（不不能包含返回语句），又符合constexpr函数的要求（唯一可执行语句就是返回语句）。因此，constexpr构造函数体一般是空的。通过前置关键字constexpr就可以声明一个constexpr构造函数。 class Debug{ public: constexpr Debug(bool b = true):hw(b), io(b), other(b){} constexpr Debug(bool h, bool i, bool o):hw(h), io(i), other(o){} constexpr bool any(){ return hw || io || other; } void set_io(bool b){ io = b; } void set_hw(bool b){ hw = b; } void set_other(bool b){ other = b; } private: bool hw; bool io; bool other; }; constexpr构造函数必须初始化所有数据成员，初始值或者使用constexpr构造函数，或者是一条常量表达式。 constexpr构造函数用于生成constexpr对象以及constexpr函数的参数或返回类型。 constexpr Debug io_sub(false, true, false); //调试io if (io_sub.any()) // 等价于if(true) cerr \u003c\u003c \"print appropriate error message\" \u003c\u003c endl; constexpr Debug prod(false); // 无调试 if (prod.any()) // 等价于if(false) cerr \u003c\u003c \"print an error message\" \u003c\u003c endl; ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:12:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#constexpr构造函数"},{"categories":["C++学习"],"content":"类的静态成员有的时候类需要它的一些成员与类本身直接相关，而不是和类的各个对象保持关联。例如，一个银行账户可能需要一个数据成员来表示当前的基准利率。在此例中，我们希望利率与类关联，而非和类的每个对象关联。从实现效率的角度来看，没必要每个对象都存储利率信息。而且更加重要的是，一旦利率浮动，我们希望所有的对象都使用新值。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:13:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类的静态成员"},{"categories":["C++学习"],"content":"声明静态成员我们通过在成员的声明之前加上关键字static使得其与类关联在一起。和其他成员一样，静态成员可以是public或private的。静态成员的数据类型可以是常量、引用、指针、类类型等。 class Account{ public: void calculate(){ amount += amount * interestRate; } static double rate(){ return interestRate; } static void rate(double); private: string owner; double amount; static double interestRate; static double initRate(); }; 类的静态成员存在与任何对象之外，对象中不包含任何与静态数据成员有关的数据，因此，每个Account对象将包含两个数据成员:owner和amount。只存在一个interestRate被它被所有Account对象共享。 类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。作为结果，静态成员函数不能声明成const的，而且我们也不能在static函数体内使用this指针。这一限制既适用于this的显式使用，也对调用非静态成员的隐式使用有效。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:13:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#声明静态成员"},{"categories":["C++学习"],"content":"使用类的静态成员我们使用作用域运算符直接访问静态成员： double r; r = Account::rate(); // 使用作用域运算符访问静态成员 虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或指针来访问静态成员。 Account ac1; Account *ac2 = \u0026ac1; // 调用静态成员函数rate的等价形式 r = ac1.rate(); // 通过Account的对象或引用 r = ac2 -\u003e rate(); // 通过指向Account对象的指针 成员函数不用通过作用域运算符就能直接使用静态成员： class Account{ public: void calculate(){ amount += amount * interestRate; } private: string owner; double amount; static double interestRate; static double initRate(); }; ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:13:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#使用类的静态成员"},{"categories":["C++学习"],"content":"定义静态成员和其他成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。当在类的外部定义静态成员时，不能重复static关键字，该关键字只出现在类内部的声明语句。 void Account::rate(double newRate){ interestRate = newRate; } 和类的所有成员一样，当在指向类外部的静态成员是，必须指明成员所属的类名。static关键字只出现在类内部的声明语句中。 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着它们不是由类的构造函数初始化的。而且一般来说，不能再类的内部初始化静态成员。相反地，必须在类的外部定义和初始化每个静态成员。和其他对象一样，一个静态数据成员只能定义一次。 类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在与程序的整个生命周期中。 定义静态数据成员和在类的外部定义成员函数差不多。需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字。 //定义并初始化一个静态成员 double Account::interestRate = initRate(); 上面的语句定义了名为interestRate的对象，该对象是Account的静态成员，其类型是double。从类名开始，这条定义语句的剩余部分就位于类的作用域之内。因此，直接使用initRate函数。 注意，虽然initRate是私有的，我们也可以使用它初始化interestRate。和其他成员的定义一样，interestRate的定义也可以访问类的私有成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:13:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#定义静态成员"},{"categories":["C++学习"],"content":"静态成员的类内初始化通常情况下，类的静态成员不应该在类的内部初始化。然而，我们可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们可以用一个初始化了的静态数据成员指定数组成员的维度： class Account{ public: static double rate(){ return interestRate; } static void rate(double); private: static constexpr int period = 30; double daily_tbl[period]; }; 如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的const或constexpr static不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须由一条定义语句。 例如，如果period的唯一用途就是定义daily_tbl的维度，则不需要在Account外面专门定义period。此时，如果我们忽略了这条定义，那么对程序非常微小的改动也可能造成编译错误，因为程序找不到该成员的定义语句。举个例子，当需要把Account::period传递给一个接受const int\u0026的函数时，必须定义period。 如果在类的内部提供论文一个初始值，则成员的定义不能再指定一个初始值了： //一个不带初始值的静态成员的定义 constexpr int Account::period; //初始值在类的定义内提供 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:13:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#静态成员的类内初始化"},{"categories":["C++学习"],"content":"静态成员能用与某些场景，而普通成员不能静态成员独立于任何对象。因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常的使用。举个例子，静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，值能声明成它所属类的指针或引用： class Bar{ public: //... private: static Bar meml; //正确：静态成员可以是不完全类型 Bar *mem2; //正确：指针成员可以是不完全类型 Bar mem3; //错误：数据成员必须是完全类型 }; 静态成员和普通成员的另外一个区别是我们可以通过使用静态成员作为默认实参： class Screen{ public: //bkground表示一个在类中稍后定义的静态成员 Screen\u0026 clear(char = bkground); private: static const char bkground; }; 非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:13:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#静态成员能用与某些场景而普通成员不能"},{"categories":["中国电影"],"content":"This is a test text!!!","date":"04-04","objectID":"/2022/youngstyle/:0:0","series":["电影"],"tags":["高考","青春","中国电影"],"title":"青春派","uri":"/2022/youngstyle/#this-is-a-test-text"},{"categories":["C++学习"],"content":"函数基础典型的函数定义包括以下部分：返回类型、函数名、形参列表和函数体。 形参列表中形参用逗号隔开，其中每个形参都是一个含有声明符的声明。即使两个形参的类型一样，也必须把两个类型写出来。 int fun(int a,b) // false int fun(int a, int b) // true #include \u003ciostream\u003eusing namespace std; int jc(int a){ int res = 1; for(int i = 1; i \u003c= a; i++){ res *= i; } return res; } int main(){ int a; cin \u003e\u003e a; cout \u003c\u003c jc(a) \u003c\u003c endl; } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:1:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数基础"},{"categories":["C++学习"],"content":"局部对象名字有作用域，对象有生命周期。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:2:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#局部对象"},{"categories":["C++学习"],"content":"自动对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义的块末尾时销毁它。把志存在于块执行期间的对象成为自动对象。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:2:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#自动对象"},{"categories":["C++学习"],"content":"局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响。 将局部变量定义为static类型来获得这样的对象。 #include \u003ciostream\u003eusing namespace std; size_t count_calls(){ static size_t ctr = 0; return ++ctr; } int main(){ for(size_t i = 0; i != 10; ++i){ count_calls(); } cout \u003c\u003c count_calls(); // 11, 如果ctr没有被定义为static，则输出1. return 0; } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:2:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#局部静态对象"},{"categories":["C++学习"],"content":"函数声明函数只能定义一次，但是可以声明多次。函数的声明和定义十分类似，唯一的区别就是函数声明无需函数体，一个分号替代即可。 函数的三要素（返回类型、函数声明和形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也被成为函数原型。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:3:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数声明"},{"categories":["C++学习"],"content":"参数传递形参的类型决定了形参和实参交互方式。如果形参时引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。 当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用。 当实参的值被拷贝给形参时，形参和实参时两个相互独立的对象。我们说这样的实参被值传递或者函数被传值调用。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:4:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#参数传递"},{"categories":["C++学习"],"content":"指针形参当执行指针拷贝操作时，拷贝的时指针的值。拷贝之后，两个指针是不同的指针。因为指针时我们可以间接访问它所指的对象，所以通过指针可以修改它所指对象的值。 #include \u003ciostream\u003eusing namespace std; int main(){ int n = 0, i = 42; int* p = \u0026n; int* q = \u0026i; cout \u003c\u003c *p \u003c\u003c *q \u003c\u003c endl;// 0, 42 *p = 4; cout \u003c\u003c n \u003c\u003c endl;// 4 p = q; cout \u003c\u003c *p \u003c\u003c n \u003c\u003c endl;// 42, 4 } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:4:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#指针形参"},{"categories":["C++学习"],"content":"传引用参数 使用引用避免拷贝 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本不治持拷贝操作（包括IO类型在内）。当某种类型不治持拷贝操作时，函数只能通过引用形参访问该类型的对象。 使用形参返回额外信息 ？？？还没整明白 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:4:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#传引用参数"},{"categories":["C++学习"],"content":"const形参和实参和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。当形参有顶层const时，传给他常量对象或者非常量对象都是可以的。 void func(const int i){} // 该函数只能读取i，不能对i的值做修改。 在调用func函数时，既可以传入const int，也可以传入int。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:5:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#const形参和实参"},{"categories":["C++学习"],"content":"指针或引用型参与const可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用类型必须用同类型的对象初始化。 int i = 42; const int *cp = \u0026i; //对 const int \u0026r = i; //对 const int \u0026r2 = 42; //对 int *p = co; //错，类型不匹配 int \u0026r3 = r; //错，类型不匹配 int \u0026r4 = 42; //错，类型不匹配 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:5:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#指针或引用型参与const"},{"categories":["C++学习"],"content":"尽量使用常量引用把函数不会改变的形参定义成普通引用是一种比较常见的错误，这样做会给调用者一种误导，即函数可以修改它实参的值。此外，使用引用而非常量引用也会极大限制函数所能接受的实参类型。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:5:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#尽量使用常量引用"},{"categories":["C++学习"],"content":"数组形参数组的两个特殊性质： 1.不允许拷贝数组； 2.使用数组时通常会将其转换为指针。 因为不能拷贝数组，所以无法以值传递的方式使用数组参数。因为数组会被转换为指针，所以为函数传递一个数组时，实际上传递的事指向数组首元素的指针。 虽然不能以值传递的方式传递数组，但是可以将形参写成类似数组的形式。 void print(const int*); void print(const int[]); void print(const int[10]); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#数组形参"},{"categories":["C++学习"],"content":"使用标记指定数组长度要求数组本身包含一个结束标记，这种方法的典型示例是C风格字符串，C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。 void print(const char* cp){ if(cp) while(*cp) cout \u003c\u003c *cp++; } 适用于有明显结束标记且该标记不会与普通数据混淆的情况。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#使用标记指定数组长度"},{"categories":["C++学习"],"content":"使用标准库规范管理数组实参的第二种技术是传递指向首元素和尾后元素的指针。 void print(const int* beg, const int* end){ while(beg != end){ cout \u003c\u003c *beg++ \u003c\u003c endl; } } int j[2] = {0, 1}; print(begin(j), end(j)); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#使用标准库规范"},{"categories":["C++学习"],"content":"显式传递一个表示数组大小的形参 void print(const int ia[], size_t size){ for(size_t i = 0; i != size; ++i){ cout \u003c\u003c ia[i] \u003c\u003c endl; } } int j[] = {0,1}; print(j, end(j) - begin(j)); 只要传递给函数的size步超过数组实际大小，函数就是安全的。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:3","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#显式传递一个表示数组大小的形参"},{"categories":["C++学习"],"content":"数组形参和const当函数不需要对数组元素执行写操作时，数组形参应该是指向const的指针。 当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:4","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#数组形参和const"},{"categories":["C++学习"],"content":"数组引用形参C++允许将变量定义成数组的应用，同理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定在数组上。 void print(int (\u0026arr)[10]){ for (auto elem : arr) cout \u003c\u003c elem \u003c\u003c endl; } int j[2] = {0,1}; int k[10] = {0,1,2,3,4,5,6,7,8,9}; print(j); // 错误，实参不是含有10个整数的数组 print(k); // 正确 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:5","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#数组引用形参"},{"categories":["C++学习"],"content":"传递多维数组将多维数组传给函数时，真正传递的是指向数组首元素的指针。因为处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维的大小都是数组类型的一部分。 void print(int (*matrix)[10], int rowSize) // 等价定义 void print(int matrix[][10], int rowSize) ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:6","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#传递多维数组"},{"categories":["C++学习"],"content":"含有可变形参的函数有时无法提前预知应该向函数传递几个实参，此时最好使用同一个函数实现该项功能。 initializer_list形参 如果函数的实参数量未知但是全部实参类型都相同，此时可以使用initializer_list类型的形参。 initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。 和vector一样，initializer_list也是一种模板类型，在定义initializer_list对象时，必须说明列表所含元素的类型。 initializer_list\u003cint\u003e li; 和vector不一样的是，initializer_list对象中的元素永远是常量值，无法对initializer_list对象中元素的值。 如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内。 void error_msg(initializer_list\u003cstring\u003e il){ for(auto beg = il.begin(); beg != il.end(); ++beg) cout \u003c\u003c *beg \u003c\u003c \" \"; cout \u003c\u003c endl; } if(expected != actual) error_msg({\"function\", expected, actual}); else error_msg({\"functionX\", \"okay\"}); 含有initializer_list形参的函数也可以同时拥有其他形参。 void error_msg(ErrCode e,initializer_list\u003cstring\u003e il){ cout \u003c\u003c e,msg() \u003c\u003c \": \"; for(const auto \u0026elem : il) cout \u003c\u003c elem \u003c\u003c \" \"; cout \u003c\u003c endl; } if(expected != actual) error_msg(ErrCode(42), {\"function\", expected, actual}); else error_msg(ErrCode(0), {\"functionX\", \"okay\"}); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:7:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#含有可变形参的函数"},{"categories":["C++学习"],"content":"返回类型和return语句","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:8:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#返回类型和return语句"},{"categories":["C++学习"],"content":"无返回值函数没有返回值的return语句只能用在返回类型是void的函数中。 通常，如果void函数如果想在中间位置提前退出，可以使用return语句。此时return语句的作用类似于break语句。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:8:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#无返回值函数"},{"categories":["C++学习"],"content":"有返回值的函数 不要返回局部对象的引用或指针 函数完成后，它所占用的存储空间也随之被释放。因此，函数终止意味着局部变量的引用意味着局部变量的引用将指向不再有效的内存区域。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:8:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#有返回值的函数"},{"categories":["C++学习"],"content":"函数重载如果同一作用域的几个函数名字相同但形参列表不同，称之为重载函数。(main函数不能重载) 重载函数最好只用于操作非常相似的函数。 虽然函数的名称相同，但编译器会格局实参的类型确定应该调用哪个函数。 但是，不允许两个函数除了返回值类型之外其他所有的要素都相同。假设有两个函数，他们的形参列表一样，的那是返回类型不同，那么第二个函数的声明是错误的。 int lookup(const Account\u0026); bool lookup(const Account\u0026); //错误，与上一函数相比，仅返回类型不同。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:9:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数重载"},{"categories":["C++学习"],"content":"重载和const形参一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。 Record lookup(phone); Record lookup(const phone); //重复声明了Record lookup(phone) 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。 Record lookup(Account\u0026); Reocrd lookup(const Account\u0026); Record lookup(Account*); Reocrd lookup(const Account*); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:9:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#重载和const形参"},{"categories":["C++学习"],"content":"const_cast和重载 const string \u0026shortString(const string \u0026s1, const string \u0026s2){ reutrn s1.size() \u003c= s2.size() ? s1 : s2; } 这个函数的参数和返回值类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果依然是const string的引用。因此，我们需要一种新的shortString函数，当它的实参不是常量时，得到的结果是一个普通的引用，此时可使用const_cast。 string \u0026shortString(string \u0026s1, string \u0026s2){ auto \u0026r = shortString(const_cast\u003cconst string\u0026\u003e(s1), const_cast\u003cconst string\u0026\u003e(s2)); return const_cast\u003cstring\u0026\u003e(r); } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:9:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#const_cast和重载"},{"categories":["C++学习"],"content":"默认实参默认实参只能在函数声明和lambda表达式的形参列表中出现，而不能在函数指针、到函数的引用，或在typedef声明中出现。 如果friend声明指定了默认实参。那么它必须是友元函数的定义，且该翻译单元中不能有此函数的其他声明。 在函数的很多次调用中他们都被赋予一个相同的值，此时，将这个反复出现的值称为函数的默认实参。 typedef string::size_type sz; string screen(sz ht = 24, sz wid = 80, char backgrnd = ' '); string window; window = screen(); // screen(24,80,' ') window = screen(66,256,'#'); // screen(66,256,'#') ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:10:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#默认实参"},{"categories":["C++学习"],"content":"默认实参声明对于函数声明，通常习惯将其放在头文件中，并且一个函数只声明一次，但多次声明同一函数也是合法的。 但是，需要注意，在给定的作用域中，一个形参只能被赋予一次默认实参。换句话说，就是在函数的后续声明中，只能为之前没有默认值的形参添加默认实参，而且该形参右侧所有形参必须都有默认值。 string screen(sz, sz, char = ' '); string screen(sz, sz, char = '*'); // 错误，不能修改一个已经存在的默认值 string screen(sz = 24, sz = 24, hcar); //正确，添加默认实参 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:10:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#默认实参声明"},{"categories":["C++学习"],"content":"默认实参初始值局部变量不能作为默认实参。除此之外，只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认实参。 sz wd = 80; char def = ' '; sz ht(); string screen(sz = ht(), sz = wd, char = def); string window = screen(); // screen(ht(), 80, ' ') void f2(){ def = '*'; sz wd = 100; window = screen(); // screen(ht(), 80, '*') } def的值在函数f2中被改变，所以screen会调用这个更新过的值，但是wd只是函数内部声明的一个局部变量，和传给screen的实参没有任何关系。 using声明会将已知的默认实参集承接过来，如果向函数的命名空间中添加更多的默认形参，那么这些默认实参在这条using声明可见得的任何位置均可见。 namespace N{ void f(int, int = 1); } using N::f; void g(){ f(7); // 正确，f(7,1) f(); // 错误，实参数量不够 } namespace N{ void f(int = 2, int); } void h(){ f(); // 正确，f(2,1) } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:10:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#默认实参初始值"},{"categories":["C++学习"],"content":"变长实参允许函数接受任意数量的额外实参。由跟在函数声明的形参列表之后的尾随…指定。 int printx(const char* fmt, ...); printx(\"hello world\"); printx(\"a=%d b=%d\", a,b); int printx(const char* fmt...); //效果同上述函数声明 int printy(...,const char* fmt...); //错误，...不能作为形参出现 int ptintz(...); //合法，但无法可移植的访问参数 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:11:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#变长实参"},{"categories":["C++学习"],"content":"内联函数和constexpr函数内联函数和constexpr函数通常定义在头文件中。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:12:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#内联函数和constexpr函数"},{"categories":["C++学习"],"content":"内联函数可以避免函数调用的开销将函数指定为内联函数(inline)，通常就是在他的每个调用点上内联的展开。 cout \u003c\u003c shotrString(s1, s2) \u003c\u003c endl; 会在编译过程中展开成如下形式 cout \u003c\u003c (s1.size() \u003c s2.size() ? s1 : s2) \u003c\u003c endl; 从而消除shortString函数的运行时开销。 在函数的返回类型前加上关键字inline，就可以将函数声明为内联函数。 inline const string\u0026 shortString(const String \u0026s1, const String \u0026s2){ return s1.size() \u003c s2.size() ? s1 : s2; } 需要注意，内联函数只是向编译器发出的一个请求，编译器可以选择忽略这个请求。 一般来说，内联机制用于优化规模较小，流程直接，频繁调用的函数。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:12:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#内联函数可以避免函数调用的开销"},{"categories":["C++学习"],"content":"constexpr函数contexpr函数是指能用与常量表达式的函数。定义constexpr函数的方法和其他函数类似，不过要遵循几项约定：函数的返回类型以及所有形参的类型都得是字面值类型，而且函数体中有且只有一条return语句。 constexpr int new_sz() { return 42; } constexpr int foo = new_sz(); constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行操作即可。例如，contexor函数中可以有空语句、类型别名以及using声明。 也允许constexpr函数的返回值并非一个常量。 constexpr size_t scale(size_t cnt) { return new_sz() * cnt; } 当scale的实参是常量表达式时，它的返回值也是常量表达式，反之则不然。 int arr[scale(2)]; // 正确 int i = 2; int arr[scale(i)]; // 错误，scale(i)不是常量表达式 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:12:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#constexpr函数"},{"categories":["C++学习"],"content":"函数匹配 void f(); void f(int); void f(int, int); void f(double, double = 3.14); f(5.6); // 调用f(double, double) ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:13:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数匹配"},{"categories":["C++学习"],"content":"函数指针函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定。 bool lengthCompare(const string \u0026, const string \u0026); bool (*pf)(const string \u0026, const string\u0026) *pf两端的括号必不可少，如果没有括号，则pf是一个返回值为bool指针的函数。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数指针"},{"categories":["C++学习"],"content":"使用函数指针当把函数名作为一个值使用时，该函数自动转换为指针，按照如下形式可以将lengthCompare函数的地址赋给pf pf = lengthCompare; pf = \u0026lengthCompare; // 等价赋值语句，取址符时可选的 此外，可以直接使用指向函数的指针调用该函数，无须提前解引用指针： bool b1 = pf(\"hello\", \"goodbye\"); bool b2 = (*pf)(\"hello\", \"goodbye\"); //等价调用 bool b3 = lengthCompare(\"hello\", \"goodbye\"); //另一个等价调用 在指向不同的函数类型的指针间不存在转换规则。但是和往常一样，可以为函数指针赋一个nullptr或值为0的整型常量表达式，表示该指针没有指向任何一个函数。 string::size_type sumLength(const string\u0026, const string\u0026); bool cstringCompare(const char*, const char*); pf = 0; // 正确，此时pf为空指针 pf = sumLength; // 错误，返回值类型不匹配 pf = cstringCompare; // 错误，形参类型不匹配 pf = lengthComapre; // 正确，函数和指针的类型精确匹配 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#使用函数指针"},{"categories":["C++学习"],"content":"重载函数的指针当使用重载函数时，上下文必须清晰的界定到底选用哪个函数。如果定义了指向重载函数的指针，编译器通过指针类型决定选用哪个函数，指针类型必须和重载函数中某一个精确匹配。 void ff(int*); void ff(unsigned int); void (*pf1)(unsigned int) = ff; //pf1指向ff(unsigned) void (*pf2)(int) = ff; //错误，没有ff与此形参列表匹配 double (*pf3)(int*) = ff; // 错误，返回类型不匹配 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#重载函数的指针"},{"categories":["C++学习"],"content":"函数和指针形参和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。 void useBigger(const string \u0026s1, const string \u0026s2, bool pf(const string \u0026, const string \u0026)); // 第三个形参是函数类型，会自动转换成指向函数的指针 void useBigger(const string \u0026s1, const string \u0026s2, bool (*pf)(const string \u0026, const string \u0026)); // 等价声明，显式的将形参定义为指向函数的指针 useBigger(s1, s2, lengthCompare); //自动将lenthCompare转换成指向该函数的指针 直接使用函数指针类型显得冗长而繁琐。类型别名和decltype可以简化使用函数指针的代码。 //Func和Func2时函数类型 typedef bool Func(const string\u0026, const string\u0026); typedef decltype(lengthCompare) Func2;//等价的类型 //FuncP和FuncP2是指向函数的指针 typedef bool(*FuncP)(const string\u0026, const string\u0026); typedef decltype(lengthCompare) *FuncP2 // 等价的类型 需要注意的是，decltype返回函数类型，此时不会将函数类型自动转换为指针类型。因为decltype的结果是哈书类型，所以只有在结果前加上*才能得到指针。可以使用如下的形式重新声明useBigger： void useBigger(const string\u0026, const string\u0026, Func); void useBigger(const string\u0026, const string\u0026, *FuncP2); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:3","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数和指针形参"},{"categories":["C++学习"],"content":"返回指向函数的指针和数组类似虽然不能返回一个函数，但是可以返回指向函数类型的指针。然而，必须把返回类型写成指针类型，编译器不会自动将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的方法是使用类型别名： using F = int(int*, int); //F为函数类型 using PF = int(*)(int*, int); // PF是指针类型 PF f1(int); // 正确，PF是指向函数的指针，f1返回指向函数的指针 F f1(int); //错误，F是函数类型，f1不能返回一个函数 F *f1(int); //正确，显式的指定返回类型是指向函数的指针 int (*f1(int))(int*, int); //或使用尾置返回类型 auto f1(int) -\u003e int(*)(int*, int); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:4","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#返回指向函数的指针"},{"categories":["C++学习"],"content":"lambda表达式构造闭包：能够捕获作用域中的变量的无名函数对象。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:15:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#lambda表达式"},{"categories":["C++学习"],"content":"简单语句 空语句 空语句中只含有一个单独的分号。 ; //空语句 如果程序的某个地方，语法上需要一条语句，但是逻辑上不需要，此时应该使用空语句。 例如，想读取输入流的内容直到遇见一个特定值，除此之外什么也不做。 while(cin \u003e\u003e s \u0026\u0026 s != sought) ; //空语句 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:1:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#简单语句"},{"categories":["C++学习"],"content":"条件语句 switch语句 case关键字和它对应的值一起被称为case标签，case标签必须是整型常量表达式。 如果没有任何一个case标签能够匹配上switch表达式的值，程序将执行紧跟在default标签之后的语句。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:2:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#条件语句"},{"categories":["C++学习"],"content":"循环语句 while 只要条件为真，while语句就重复的执行循环体。 当不确定要迭代多少次时，使用while循环比较合适。或想要在循环结束后访问循环控制变量。 传统for语句 for(init-statement; condition; expression) statement; 范围for语句 for(declaration: expression) statement; expression表示的必须是一个序列，如数组或vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。 不能通过范围for语句增加vector对象的元素。因为在范围for语句中预存了end()值，一旦添加元素，end函数的值可能无效。 do while语句 与while语句非常相似，但是do while语句先执行循环体再检查条件。 do statement; while (condition); 不允许在条件部分定义变量。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:3:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#循环语句"},{"categories":["C++学习"],"content":"跳转语句 break语句 终止离它最近的while、do while、for或switch语句，并从这些语句后第一条语句开始执行。 continue语句 终止最近的循环中的当前迭代，并立即开始下一次迭代。 string buf; while(cin \u003e\u003e buf \u0026\u0026 !buf.empyt()){ if(buf[0] != '_') continue; //读取下一输入 } ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:4:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#跳转语句"},{"categories":["C++学习"],"content":"try语句块和异常处理 throw表达式 throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。 if(item1.isbn() != item2.isbn()) throw runtime_error(\"Data must refer to same ISBN\"); runtime_error是标准异常类型的一种，定义在stdexcept头文件中。 try语句块 try{ program-statement; }catch(exception-declaration){ handler-statements; }catch(exception-declaration){ handler-statements; } catch子句包含三部分：关键字catch、括号内一个对象的声明以及一个块。选中某个catch子句处理异常后，执行与之对应的块。catch一旦执行完成，则跳转到try语句块最后一个catch子句之后的那条语句继续执行。 while(cin \u003e\u003e item1 \u003e\u003e item2){ try{ //添加两个sales_item对象的代码 //如果添加失败，抛出一个runtime_error异常 }catch(runtime_error err){ //提醒用户两个ISBN必须一致，询问是否重新输入 cout \u003c\u003c err.what() \u003c\u003c \"\\nTry Again? Entry y or n\" \u003c\u003c endl; char c; cin \u003e\u003e c; if(!cin || c == 'n') break; } } ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:5:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#try语句块和异常处理"},{"categories":["C++学习"],"content":"标准异常 exception exception头文件定义最通用的异常类exception。只报告异常的发生，不提供任何额外信息。 stdexcept 异常类 异常类型 exception 最常见的问题 runtime_error 只有在运行时才能检测出的问题 range_error 运行时错误：生成的结果超过了有意义的值域范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的结果值不存在 invalid_error 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用一个超出有效范围的值 new头文件定义bad_alloc异常类型，将在之后介绍 type_info头文件定义了bad_cast异常类型，将在之后介绍 只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。 其他异常类型的行为刚好相反：应使用string或C风格字符串初始化这些类型的对象，但不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:6:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#标准异常"},{"categories":["C++学习"],"content":"优先级与结合律 优先级会影响程序的正确性，这一点也适用于解引用和指针运算。 int ia[] = {0,2,4,6,8}; int last = *(ia + 4); //此时last值为ia[4]的值 last = *ia + 4; //此时last值为[0]+4 进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为比较对象。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#优先级与结合律"},{"categories":["C++学习"],"content":"递增和递减运算符 前置版本 首先将运算对象加一或减一，然后将改变后的对象作为求值结果(先加再用)。 后置版本 首先将运算对象加一或减一，但求值结果是运算对象改变之前那个值的副本(先用再加)。 int i = 0, j; j = ++i; // j = 1, i = 1 j = i++; // j = 1, i = 2 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#递增和递减运算符"},{"categories":["C++学习"],"content":"算数转换 运算符的运算对象将被转换为最宽的类型 例如，如果一个运算对象的类型是long double，那么不论另一个运算对象的类型是什么，它都会被转换成long double型。 另一种更普遍的情况是，当表达式中既有浮点类型和整数类型时，整数型将被转换成相应的浮点类型。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#算数转换"},{"categories":["C++学习"],"content":"其他隐式类型转换 数组转换为指针 int ia[10]; int* ip = ia; //ia转换成指向数组首元素的指针 指针的转换 转换成布尔类型 char *cp = get_string(); if(cp) /*...*/ //如果指针不是0，条件为真 while(*cp) /*...*/ //如果*cp不是空字符，条件为真 转换成常量 int i; const int \u0026j = i; //非常量转换为const int的引用 const int *p = \u0026i; //非常量的地址转换为const的地址 int \u0026r = j, *q = p; //错误，不允许const转换为非常量 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#其他隐式类型转换"},{"categories":["C++学习"],"content":"显式转换一个命名的强制类型转换具有如下形式： cast-name\u003ctype\u003e(expression) type是转换的目标类型，expression是要转换的值。casy-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。 static_cast 适用于任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 当把较大的算数类型赋值给较小的类型时，static_cast非常有用。 static_cast同样适用于编译器无法自动执行的类型转换。 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; struct B{ int m = 0; void hello() const{ cout \u003c\u003c \"this is B\" \u003c\u003c endl; } }; struct D:B{ void hello() const{ cout \u003c\u003c \"this is D\" \u003c\u003c endl; } }; int main(){ D d; B\u0026 br = d; br.hello(); // this is B D\u0026 another_d = static_cast\u003cD\u0026\u003e(br); another_d.hello(); // this is D } const_cast 只能改变运算对象的底层const,可以用来移除常量性或易变性。 函数指针和成员函数指针无法用于const_cast。 const_cast使得到非const类型的应用或指针能够实际指代const对象，货或到非volatile类型的引用或指针能够实际指代volatile对象。 #include \u003ciostream\u003eusing namespace std; struct type{ int i; type(): i(3){} // 构造函数 void f(int v) const{ // this-\u003ei = v; const_cast\u003ctype*\u003e(this)-\u003ei = v; } }; int main(){ int i = 3; const int\u0026 rci = i; cout \u003c\u003c rci \u003c\u003c endl; // 3 const_cast\u003cint\u0026\u003e(rci) = 4; cout \u003c\u003c rci \u003c\u003c endl; // 4 type t; t.f(5); cout \u003c\u003c t.i \u003c\u003c endl; } reinterpret_cast 与static_const不同，但与const_cast类似。reinterpret_cast是一个编译时指令，通常为运算对象的位模式提供较低层次上的重新编译。 int *io; char *pc = reinterpret_cast\u003cchar*\u003e(ip); string str(pc) //错误，pc所指的真实对象是一个int而非字符。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#显式转换"},{"categories":["C++学习"],"content":"stringstring表示可变长的字符序列，使用string类型前需要包含string头文件，同时需要在命名空间中声明。需要注意，string对象对大小写敏感。 #incude \u003cstring\u003e using std::string; 在最终的字符串中保留输入时的空白符，可以使用getline函数。 string line; getline(cin, line); getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，遇到换行符则停止读入，然后将读入的内容存到string对象中。需要注意，如果一开始就读到换行符的话，就会得到一个空的string。 empty函数判断一个string对象是否为空。 size函数返回string对象的长度(无符号整数)。 在使用‘+’对string进行操作时候，必须确保运算符两侧的对象至少有一个是string。 cctype头文件中定义了一组标准库函数对string进行处理。 如果想要使用循环改变string中字符的值。必须将循环变量定义成引用类型。 front函数返回字符串中的首位字符。用法同back函数。 back函数返回字符串中的末位字符。 int main(){ { string s(\"Exemplary\"); char\u0026 back = s.back(); back = 's'; cout \u003c\u003c s \u003c\u003c endl; // Exemplars } { string const c(\"Exemplary\"); char const\u0026 back = c.back(); cout \u003c\u003c back \u003c\u003c endl; // y } } capacity函数返回当前为string分配的存储。 #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; void show_capacity(string const\u0026 s){ cout \u003c\u003c \" \" \u003c\u003c s \u003c\u003c \" has capacity \" \u003c\u003c s.capacity() \u003c\u003c endl; } int main(){ string s(\"Exemplar\"); show_capacity(s); // Exemplar has capacity 15 s += \" is an example.\"; show_capacity(s); // Exemplar is an example. has capacity 30 } find函数用于搜索指定范围中满足特定判别标准的首个元素的迭代器，若找不到则返回last。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003citerator\u003eusing namespace std; int main(){ vector\u003cint\u003e v{1,2,3,4}; int n1 = 3; int n2 = 5; auto res1 = find(begin(v), end(v), n1); auto res2 = find(begin(v), end(v), n2); (res1 != end(v)) ? cout \u003c\u003c \"v contains \" \u003c\u003c n1 \u003c\u003c endl : cout \u003c\u003c \"v does nor contain \" \u003c\u003c n1 \u003c\u003c endl; // v contains 3 (res2 != end(v)) ? cout \u003c\u003c \"v contains \" \u003c\u003c n2 \u003c\u003c endl : cout \u003c\u003c \"v does nor contain \" \u003c\u003c n2 \u003c\u003c endl; // v does nor contain 5 } find_first_of，寻找等于给定字符序列中字符之一的首个字符。搜索只考虑区间 [pos, size()) 。若区间中不存在字符，则返回 npos 。 find_last_of, 寻找等于给定字符序列中字符之一的最后字符。不指定准确的搜索算法。搜索只考虑区间 [0, pos] 。若区间中不存在这种字符，则返回 npos 。用法同find_first_of。 #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main(){ const string s(\"Hello World!\"); const string search_str(\"o\"); const char* search_cstr = \"Good Bye!\"; cout \u003c\u003c s.find_first_of(search_str) \u003c\u003c endl; // 4 cout \u003c\u003c s.find_first_of(search_str, 5) \u003c\u003c endl; // 7 cout \u003c\u003c s.find_first_of(search_cstr) \u003c\u003c endl; // 1 cout \u003c\u003c s.find_first_of(search_cstr, 5, 2) \u003c\u003c endl; // 7 } find_first_not_of, 寻找不等于给定字符序列中任何字符的首个字符。搜索只考虑区间 [pos, size()) 。若区间中不存在字符，则将返回 npos 。 find_lat_not_of, 寻找不等于给定字符序列中任何字符的最后字符。搜索只考虑区间 [0, pos] 。若区间中不存在这种字符，则返回 npos 。 #include \u003cstring\u003e#include \u003ciostream\u003e int main() { std::string to_search = \"Some data with %MACROS to substitute\"; std::cout \u003c\u003c \"Before: \" \u003c\u003c to_search \u003c\u003c '\\n'; auto pos = std::string::npos; while ((pos = to_search.find('%')) != std::string::npos) { // 宏名中容许大写字母、小写字母和数字 const auto after = to_search.find_first_not_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\" \"0123456789\", pos + 1); // 现在 to_search[pos] == '%' 而 to_search[after] == ' ' （在 'S' 后） if(after != std::string::npos) to_search.replace(pos, after - pos, \"some very nice macros\"); } std::cout \u003c\u003c \"After: \" \u003c\u003c to_search \u003c\u003c '\\n'; } Before: Some data with %MACROS to substitute After: Some data with some very nice macros to substitute rfind,寻找等于给定字符序列的最后子串。搜索始于 pos ，即找到的子串必须不始于 pos 后的位置。若将 npos 或任何不小于 size()-1 的值作为 pos 传递，则在整个字符串中搜索。即从尾部开始寻找最后出现的给定子串。 #include \u003cstring\u003e#include \u003ciostream\u003e void print(std::string::size_type n, std::string const \u0026s) { if (n == std::string::npos) { std::cout \u003c\u003c \"not found\\n\"; } else { std::cout \u003c\u003c \"found: \\\"\" \u003c\u003c s.substr(n) \u003c\u003c \"\\\"at \" \u003c\u003c n \u003c\u003c '\\n'; } } int main() { std::string::size_type n; std::string const s = \"This is a string\"; // 从字符串尾反向搜索 n = s.rfind(\"is\"); print(n, s); //5 // 从位置 4 反向搜索 n = s.rfind(\"is\", 4); print(n, s); //2 // 寻找单个字符 n = s.rfind('s'); print(n, s); //10 // 寻找单个字符 n = s.rfind('q'); print(n, s); //not found } erase函数用于从string中移除指定字符。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cstring\u003eusing namespace std; int main(){ string s(\"This is an example\"); s.erase(0,5); cout \u003c\u003c s \u003c\u003cendl; //is an example s.erase(find(s.begin(), s.end(), ' ')); cout \u003c\u003c s \u003c\u003cendl; //isan example s.erase(s.find(' ')); // 从‘ ’擦除到尾部 cout \u003c\u003c s \u003c\u003c endl;//isan } cl","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:1:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#string"},{"categories":["C++学习"],"content":"vectorvector存放某种给定类型的可变长序列，由于vector容纳者其他对象，因此也被称为容器。同string，要使用vector，必须包含相应的头文件，同时在命名空间中声明。 #include \u003cvector\u003eusing std::vector; vector\u003cint\u003e ivec; //ivec保存int类型的对象 vector\u003cint\u003e ivec2(ivec); //创建ivec2，并把ivec的值复制给ivec2 front和back函数分别实现访问当前容器的首位元素或末位元素。 #include \u003cvector\u003e#include \u003ciostream\u003e int main() { std::vector\u003cchar\u003e letters {'o', 'm', 'g', 'w', 't', 'f'}; if (!letters.empty()) { std::cout \u003c\u003c \"The first character is: \" \u003c\u003c letters.front() \u003c\u003c '\\n'; // o std::cout \u003c\u003c \"The last character is: \" \u003c\u003c letters.back() \u003c\u003c '\\n'; // f } } begin,cbegin,rbegin迭代器见上述string部分内容。 max_size函数返回容器可容纳元素数量最大值。 shrink_to_fit 请求移除未使用的容量,是减少 capacity() 到 size()非强制性请求。 emplace（待补充） emplace_back（待补充） 使用push_back函数可以往vector对象尾压入元素。 使用pop_back函数可以移除vector对象尾元素。 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; void print(vector\u003cint\u003e\u0026 v){ for(auto i : v) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; } int main(){ vector\u003cint\u003e v{1,2,3,4,5}; print(v); // 1 2 3 4 5 v.push_back(6); print(v); // 1 2 3 4 5 6 v.pop_back(); v.pop_back(); print(v); // 1 2 3 4 } back_inserter函数可以往容器尾端添加元素。(C++20)。 front_inserter函数可以向容器首端添加元素。(C++20)，用法同back_insert函数。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003citerator\u003eusing namespace std; int main(){ vector\u003cint\u003e v{1,2,3,4,5}; fill_n(back_inserter(v), 3, -1); for(auto i : v) cout \u003c\u003c i \u003c\u003c \" \"; // 1,2,3,4,5,-1,-1,-1 } fill_n函数（待整理） 需要注意，如果循环体内包含有向vector对象添加元素的语句，则不能使用范围for循环。 访问vector中元素的方法和访问string中字符的方法是差不多的，包括empty，size等。 如果在for循环中对vector元素继续赋值操作，则需要将循环变量设置为引用类型。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:2:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#vector"},{"categories":["C++学习"],"content":"迭代器在迭代器中，begin成员负责返回指向第一个元素的迭代器。end则负责指向尾元素的下一个位置（尾后元素）。 begin和end的返回值类型是由对象是否是常量决定，如果对象是常量则返回const_iterator，如果对象不是常量，则返回iterator。 如果对象只需要读操作而无需写操作的话，最好使用常量类型，此时可以使用cbegin和cend函数，上述函数不论对象本身是否为常量，返回值都是const_iterator。 rbegin和rend函数，与begin、end函数用法相同，但是不同之处在于，rbegin指向最后一个元素，rend则指向首位字符的前一位置。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003calgorithm\u003e#include \u003cstring\u003eusing namespace std; int main(){ string s(\"Exenplar!\"); *s.rbegin() = 'y'; cout \u003c\u003c s \u003c\u003c endl; // Exemplary string c; copy(s.crbegin(), s.crend(), back_inserter(c)); cout \u003c\u003c c \u003c\u003c endl; // yralpmexE } ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:3:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#迭代器"},{"categories":["C++学习"],"content":"解引用解引用迭代器可以获得迭代器所指的对象，如果该对象恰好是类，就有可能希望进一步访问他的成员。 例如，对于一个由字符串组成的vector对象来说，检查其元素是否为空，令it为迭代器，检查it所指字符串是否为空即可。需要注意，(*it)的圆括号必不可少。 (*it).empty(); //先解引用，再调用empty *it.empty(); //错误，it是个迭代器 或直接使用箭头运算符(-\u003e)，箭头运算符把解引用和成员访问两个操作结合在一起。 (*it).empty(); //判断it是否为空 it-\u003eempty(); //判断it是否为空 但凡是使用迭代器的循环体，都不要向迭代器所属容器添加元素。 string和vector的迭代器可以使用加减操作，使得迭代器每次的移动跨过多个元素。 在对两个迭代器进行运算时，参与运算的两个迭代器必须指向的是同一容器中的元素。 迭代器可用于实现二分搜索。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:3:1","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#解引用"},{"categories":["C++学习"],"content":"数组数组也是存放类型相同的对象的容器，与vector类似，但与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。 如果不清楚元素的确切数量，则使用vector 数组在定义时需指定类型，不允许使用auto关键字推断。 不能将数组的内容拷贝给其他数组做初始值。 int *ptrs[10]; //ptrs是含有10个整形指针的数组 int (*Parray)[10] = \u0026arr; //Parray指向一个含有10个整数的数组 int (\u0026arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#数组"},{"categories":["C++学习"],"content":"指针和数组 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针。 int ia[] = {0,1,2}; auto ia2(ia); //ia2是一个指针，指向ia的第一个元素 指向数组的指针可以当作迭代器进行使用，但是尾后元素需要自行获取。 int arr[] = {0,1,2,3,4}; int *p = arr; //p指向arr第一个元素 int *e = arr[5]; //e指向arr尾元素的下一位置 C++11引入名为begin和end的函数用于获取数组首元素和尾后元素,这两个函数定义在iterator头文件中。 int arr[] = {0,1,2,3,4}; int *p = begin(arr); //p指向arr第一个元素 int *e = end(arr); //e指向arr尾元素的下一位置 指针运算和迭代器运算类似。 假如结果指针指向了一个元素，则允许解引用该结果指针。 int arr[] = {0,2,4,6,8}; int last = *(ar + 4); //last值为8 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:1","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#指针和数组"},{"categories":["C++学习"],"content":"多维数组多维数组就是数组的数组。 C++11中新增or语句对多维数组进行处理。 int ia[3][4]; size_t cnt = 0; for(auto \u0026row : ia) //对于外层数组的每一个元素 for(auto \u0026col : row){ //对于内层数组的每一个元素 col = cnt; cnt++; } 在遍历多维数组时，要将外围for循环的循环变量设置为引用型，这样是为了避免数组被自动转换为指针。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:2","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#多维数组"},{"categories":["C++学习"],"content":"指针和多维数组 int ia[3][4]; for(auto p = begin(ia); p != end(ia); p++){ //q指向内层元素的首元素 for(auto q = begin(*p); q != end(*q); q++) cout \u003c\u003c *q; //输出q所指的值 } ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:3","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#指针和多维数组"},{"categories":null,"content":"友情链接 感谢大佬在博客搭建过程中提供的帮助，以及耐心的解答。 大佬的博客：https://blog.ginshio.org/ ","date":"01-01","objectID":"/link/:1:0","series":null,"tags":null,"title":"友链","uri":"/link/#友情链接"},{"categories":null,"content":"个人信息 名称：煜江叔叔 简介：这个人很懒，什么都没有留下 地址：https://treamn.github.io/ 头像：https://treamn.github.io/avatar.jpg ","date":"01-01","objectID":"/link/:2:0","series":null,"tags":null,"title":"友链","uri":"/link/#个人信息"}]