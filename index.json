[{"categories":["C++学习"],"content":"简单语句 空语句 空语句中只含有一个单独的分号。 ; //空语句 如果程序的某个地方，语法上需要一条语句，但是逻辑上不需要，此时应该使用空语句。 例如，想读取输入流的内容直到遇见一个特定值，除此之外什么也不做。 while(cin \u003e\u003e s \u0026\u0026 s != sought) ; //空语句 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:1:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#简单语句"},{"categories":["C++学习"],"content":"条件语句 switch语句 case关键字和它对应的值一起被称为case标签，case标签必须是整型常量表达式。 如果没有任何一个case标签能够匹配上switch表达式的值，程序将执行紧跟在default标签之后的语句。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:2:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#条件语句"},{"categories":["C++学习"],"content":"循环语句 while 只要条件为真，while语句就重复的执行循环体。 当不确定要迭代多少次时，使用while循环比较合适。或想要在循环结束后访问循环控制变量。 传统for语句 for(init-statement; condition; expression) statement; 范围for语句 for(declaration: expression) statement; expression表示的必须是一个序列，如数组或vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。 不能通过范围for语句增加vector对象的元素。因为在范围for语句中预存了end()值，一旦添加元素，end函数的值可能无效。 do while语句 与while语句非常相似，但是do while语句先执行循环体再检查条件。 do statement; while (condition); 不允许在条件部分定义变量。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:3:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#循环语句"},{"categories":["C++学习"],"content":"跳转语句 break语句 终止离它最近的while、do while、for或switch语句，并从这些语句后第一条语句开始执行。 continue语句 终止最近的循环中的当前迭代，并立即开始下一次迭代。 string buf; while(cin \u003e\u003e buf \u0026\u0026 !buf.empyt()){ if(buf[0] != '_') continue; //读取下一输入 } ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:4:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#跳转语句"},{"categories":["C++学习"],"content":"try语句块和异常处理 throw表达式 throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。 if(item1.isbn() != item2.isbn()) throw runtime_error(\"Data must refer to same ISBN\"); runtime_error是标准异常类型的一种，定义在stdexcept头文件中。 try语句块 try{ program-statement; }catch(exception-declaration){ handler-statements; }catch(exception-declaration){ handler-statements; } catch子句包含三部分：关键字catch、括号内一个对象的声明以及一个块。选中某个catch子句处理异常后，执行与之对应的块。catch一旦执行完成，则跳转到try语句块最后一个catch子句之后的那条语句继续执行。 while(cin \u003e\u003e item1 \u003e\u003e item2){ try{ //添加两个sales_item对象的代码 //如果添加失败，抛出一个runtime_error异常 }catch(runtime_error err){ //提醒用户两个ISBN必须一致，询问是否重新输入 cout \u003c\u003c err.what() \u003c\u003c \"\\nTry Again? Entry y or n\" \u003c\u003c endl; char c; cin \u003e\u003e c; if(!cin || c == 'n') break; } } ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:5:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#try语句块和异常处理"},{"categories":["C++学习"],"content":"标准异常 exception exception头文件定义最通用的异常类exception。只报告异常的发生，不提供任何额外信息。 stdexcept 异常类 异常类型 exception 最常见的问题 runtime_error 只有在运行时才能检测出的问题 range_error 运行时错误：生成的结果超过了有意义的值域范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的结果值不存在 invalid_error 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用一个超出有效范围的值 new头文件定义bad_alloc异常类型，将在之后介绍 type_info头文件定义了bad_cast异常类型，将在之后介绍 只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。 其他异常类型的行为刚好相反：应使用string或C风格字符串初始化这些类型的对象，但不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:6:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#标准异常"},{"categories":["C++学习"],"content":"优先级与结合律 优先级会影响程序的正确性，这一点也适用于解引用和指针运算。 int ia[] = {0,2,4,6,8}; int last = *(ia + 4); //此时last值为ia[4]的值 last = *ia + 4; //此时last值为[0]+4 进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为比较对象。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#优先级与结合律"},{"categories":["C++学习"],"content":"递增和递减运算符 前置版本 首先将运算对象加一或减一，然后将改变后的对象作为求值结果(先加再用)。 后置版本 首先将运算对象加一或减一，但求值结果是运算对象改变之前那个值的副本(先用再加)。 int i = 0, j; j = ++i; // j = 1, i = 1 j = i++; // j = 1, i = 2 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#递增和递减运算符"},{"categories":["C++学习"],"content":"算数转换 运算符的运算对象将被转换为最宽的类型 例如，如果一个运算对象的类型是long double，那么不论另一个运算对象的类型是什么，它都会被转换成long double型。 另一种更普遍的情况是，当表达式中既有浮点类型和整数类型时，整数型将被转换成相应的浮点类型。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#算数转换"},{"categories":["C++学习"],"content":"其他隐式类型转换 数组转换为指针 int ia[10]; int* ip = ia; //ia转换成指向数组首元素的指针 指针的转换 转换成布尔类型 char *cp = get_string(); if(cp) /*...*/ //如果指针不是0，条件为真 while(*cp) /*...*/ //如果*cp不是空字符，条件为真 转换成常量 int i; const int \u0026j = i; //非常量转换为const int的引用 const int *p = \u0026i; //非常量的地址转换为const的地址 int \u0026r = j, *q = p; //错误，不允许const转换为非常量 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#其他隐式类型转换"},{"categories":["C++学习"],"content":"显式转换一个命名的强制类型转换具有如下形式： cast-name\u003ctype\u003e(expression) type是转换的目标类型，expression是要转换的值。casy-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。 static_cast 适用于任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 当把较大的算数类型赋值给较小的类型时，static_cast非常有用。 ststic_cast同样适用于编译器无法自动执行的类型转换。 void* p = \u0026 d; double *dp = static_cast\u003cdouble*\u003e(p); //将void*转换为初始的指针类型 const_cast 只能改变运算对象的底层const。 const char *pc; char *p = const_cast\u003cchar*\u003e(pc); reinterpret_cast 通常为运算对象的位模式提供较低层次上的重新编译。 int *io; char *pc = reinterpret_cast\u003cchar*\u003e(ip); string str(pc) //错误，pc所指的真实对象是一个int而非字符。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#显式转换"},{"categories":["C++学习"],"content":"stringstring表示可变长的字符序列，使用string类型前需要包含string头文件，同时需要在命名空间中声明。需要注意，string对象对大小写敏感。 #incude \u003cstring\u003e using std::string; 在最终的字符串中保留输入时的空白符，可以使用getline函数。 string line; getline(cin, line); getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，遇到换行符则停止读入，然后将读入的内容存到string对象中。需要注意，如果一开始就读到换行符的话，就会得到一个空的string。 empty函数判断一个string对象是否为空。 size函数返回string对象的长度(无符号整数)。 在使用‘+’对string进行操作时候，必须确保运算符两侧的对象至少有一个是string。 cctype头文件中定义了一组标准库函数对string进行处理。 如果想要使用循环改变string中字符的值。必须将循环变量定义成引用类型。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:1:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#string"},{"categories":["C++学习"],"content":"vectorvector存放某种给定类型的可变长序列，由于vector容纳者其他对象，因此也被称为容器。同string，要使用vector，必须包含相应的头文件，同时在命名空间中声明。 #include \u003cvector\u003eusing std::vector; vector\u003cint\u003e ivec; //ivec保存int类型的对象 vector\u003cint\u003e ivec2(ivec); //创建ivec2，并把ivec的值复制给ivec2 使用push_back函数可以往vector对象中压入元素。 需要注意，如果循环体内包含有向vector对象添加元素的语句，则不能使用范围for循环。 访问vector中元素的方法和访问string中字符的方法是差不多的，包括empty，size等。 如果在for循环中对vector元素继续赋值操作，则需要将循环变量设置为引用类型。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:2:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#vector"},{"categories":["C++学习"],"content":"迭代器在迭代器中，begin成员负责返回指向第一个元素的迭代器。end则负责指向尾元素的下一个位置（尾后元素）。 begin和end的返回值类型是由对象是否是常量决定，如果对象是常量则返回const_iterator，如果对象不是常量，则返回iterator。 如果对象只需要读操作而无需写操作的话，最好使用常量类型，此时可以使用cbegin和cend函数，上述函数不论对象本身是否为常量，返回值都是const_iterator。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:3:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#迭代器"},{"categories":["C++学习"],"content":"解引用解引用迭代器可以获得迭代器所指的对象，如果该对象恰好是类，就有可能希望进一步访问他的成员。 例如，对于一个由字符串组成的vector对象来说，检查其元素是否为空，令it为迭代器，检查it所指字符串是否为空即可。需要注意，(*it)的圆括号必不可少。 (*it).empty(); //先解引用，再调用empty *it.empty(); //错误，it是个迭代器 或直接使用箭头运算符(-\u003e)，箭头运算符把解引用和成员访问两个操作结合在一起。 (*it).empty(); //判断it是否为空 it-\u003eempty(); //判断it是否为空 但凡是使用迭代器的循环体，都不要向迭代器所属容器添加元素。 string和vector的迭代器可以使用加减操作，使得迭代器每次的移动跨过多个元素。 在对两个迭代器进行运算时，参与运算的两个迭代器必须指向的是同一容器中的元素。 迭代器可用于实现二分搜索。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:3:1","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#解引用"},{"categories":["C++学习"],"content":"数组数组也是存放类型相同的对象的容器，与vector类似，但与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。 如果不清楚元素的确切数量，则使用vector 数组在定义时需指定类型，不允许使用auto关键字推断。 不能将数组的内容拷贝给其他数组做初始值。 int *ptrs[10]; //ptrs是含有10个整形指针的数组 int (*Parray)[10] = \u0026arr; //Parray指向一个含有10个整数的数组 int (\u0026arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#数组"},{"categories":["C++学习"],"content":"指针和数组 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针。 int ia[] = {0,1,2}; auto ia2(ia); //ia2是一个指针，指向ia的第一个元素 指向数组的指针可以当作迭代器进行使用，但是尾后元素需要自行获取。 int arr[] = {0,1,2,3,4}; int *p = arr; //p指向arr第一个元素 int *e = arr[5]; //e指向arr尾元素的下一位置 C++11引入名为begin和end的函数用于获取数组首元素和尾后元素,这两个函数定义在iterator头文件中。 int arr[] = {0,1,2,3,4}; int *p = begin(arr); //p指向arr第一个元素 int *e = end(arr); //e指向arr尾元素的下一位置 指针运算和迭代器运算类似。 假如结果指针指向了一个元素，则允许解引用该结果指针。 int arr[] = {0,2,4,6,8}; int last = *(ar + 4); //last值为8 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:1","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#指针和数组"},{"categories":["C++学习"],"content":"多维数组多维数组就是数组的数组。 C++11中新增or语句对多维数组进行处理。 int ia[3][4]; size_t cnt = 0; for(auto \u0026row : ia) //对于外层数组的每一个元素 for(auto \u0026col : row){ //对于内层数组的每一个元素 col = cnt; cnt++; } 在遍历多维数组时，要将外围for循环的循环变量设置为引用型，这样是为了避免数组被自动转换为指针。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:2","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#多维数组"},{"categories":["C++学习"],"content":"指针和多维数组 int ia[3][4]; for(auto p = begin(ia); p != end(ia); p++){ //q指向内层元素的首元素 for(auto q = begin(*p); q != end(*q); q++) cout \u003c\u003c *q; //输出q所指的值 } ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:3","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#指针和多维数组"},{"categories":null,"content":"友情链接 感谢大佬在博客搭建过程中提供的帮助，以及耐心的解答。 大佬的博客：https://blog.ginshio.org/ ","date":"01-01","objectID":"/link/:1:0","series":null,"tags":null,"title":"友链","uri":"/link/#友情链接"},{"categories":null,"content":"个人信息 名称：煜江叔叔 简介：这个人很懒，什么都没有留下 地址：https://treamn.github.io/ 头像：https://treamn.github.io/avatar.jpg ","date":"01-01","objectID":"/link/:2:0","series":null,"tags":null,"title":"友链","uri":"/link/#个人信息"}]