[{"categories":["C++学习"],"content":"构造函数 类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫构造函数。构造函数的任务是初始化类对象的数据成员。 构造函数没有返回类型，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，不同的构造函数之间必须在参数数量或参数类型上有所区别。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#构造函数"},{"categories":["C++学习"],"content":"默认构造函数 如果类中没有显式的定义构造函数，那么编译器会隐式的定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数，对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员。 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#默认构造函数"},{"categories":["C++学习"],"content":"=default的含义如果我们需要默认的行为，那么可以通过在参数列表后写上 =default要求编译器生成构造函数。其中，=default既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果=default出现在类的内部，则默认构造函数是内联的；如果在类的外部，则该成员默认情况下不是内联的。 Sales_data(const std::string\u0026s): book(s){} Sales_data(const std::string\u0026s, unsigned n, double p): book(s), units_sold(n), revenue(p*n){} 函数名和花括号之间的部分称为构造函数初始值列表，负责为新创建的对象的一个或几个数据成员赋初值。 构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果不能使用类内初始值，则所有构造函数都应该显式的初始化每个内置类型的成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#default的含义"},{"categories":["C++学习"],"content":"构造函数初始值列表我们定义变量时习惯于立即对其进行初始化，而非先定义、再赋值： string foo = \"Hello World!\"; //定义并初始化 string bar; //默认初始化成string对象 bar = \"Hello World!\"; //为bar赋一个新值 就对象的数据成员而言，初始化和赋值也有类似的区别。如果没有在构造函数的初始值列表中显式的初始化成员，则该成员将在构造函数体之前执行默认初始化。 Sales_data::Sales_data(const string \u0026s, unsigned cnt, double price){ bookNo = s; units_sold = cnt; revenue = cnt * price; } 先前的版本是初始化了它的数据成员，而这个版本是对数据成员进行赋值操作。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#构造函数初始值列表"},{"categories":["C++学习"],"content":"构造函数的初始值有时必不可少有时可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。如果成员是const或者引用的话，必须将其初始化，类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。 class ConstRef{ public: ConstRef(int ii); private: int i; const int ci; int \u0026ri; }; 和其他 常量对象或引用一样，成员ci和ri都必须被初始化。因此，如果我们没有为它们提供构造函数初始值的话将会引发错误： ConstRef::ConstRef{int ii}{ i = ii; ci = ii; //错误，不能给const赋值 ri = i; //错误，ri没初始化 } 随着构造函数体一开始执行，初始化就完成。初始化const或者引用类型的数据成员的唯一机会就是通过构造函数初始值，因此该构造函数的正确形式是： ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(ii){} ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#构造函数的初始值有时必不可少"},{"categories":["C++学习"],"content":"成员初始化的顺序成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置不会影响实际的初始化顺序。 如果一成员是用另一个成员来初始化的，那么这两个成员的初始化顺序就很关键了。 class X{ int i; int j; public: //i在j之前被初始化 X(int val):j(val), i(j){} }; 实际上，i先被初始化，因此这个初始值的效果是试图使用未定义的值j初始化i。 最好令构造函数初始值的顺序和成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。 可能的话，最好使用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是可以不必考虑成员的初始化顺序。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#成员初始化的顺序"},{"categories":["C++学习"],"content":"默认实参和构造函数Sales_data默认构造函数的行为与只接受一个string实参的构造函数差不多。唯一的区别就是接受string实参的构造函数使用这个实参初始化bookNo，而默认构造函数（隐式的）使用string的默认构造函数初始化bookNo。我们可以将它们写成一个使用默认实参的构造函数。 class Sales_data{ public: // 定义默认构造函数，令其只接受一个string实参的构造函数功能相同 Sales_data(std::string s = “ ”):bookNo(s){} // 其他构造函数与之前一致 Sales_data(std::string s, unsigned cnt, double rev):bookNo(s), units_sold(cnt), revenue(rev*cnt){} Sales_data(std::istream \u0026is){ read(is,*this); } }; 当没有给定实参，或者给定一个string实参时，两个版本的类创建了相同的对象。 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:6","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#默认实参和构造函数"},{"categories":["C++学习"],"content":"委托构造函数一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把自己的一些（或全部）职责委托给了其他构造函数。 一个委托构造函数也有一个成员初始值的列表和一个函数体。在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员的初始值一样，类名后边紧跟圆括号括起来的参数列表，参数列表必须与类中另一个构造函数相匹配。 class Sales_data{ public: //非委托构造函数使用对用的实参初始化成员 Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} //其余构造函数全都委托给另一个构造函数 Sales_data():Sales_data(\"\", 0, 0){} Sales_data(std::string s):Sales_data(s,0,0){} Sales_data(std::istream \u0026is): Sales_data(){ read(is, *this); } }; 在上面的例子中，除了一个构造函数外，其他的都委托了他的工作。第一个构造函数接受三个实参，使用这些实参初始化数据成员，然后结束工作。我们定义默认构造函数令其使用三参数的构造函数完成初始化过程，它也无须执行其他任务。 接受istream\u0026的构造函数也是委托构造函数，它委托给默认构造函数，默认构造函数函数又委托给三参数构造函数。当受委托的构造函数执行完成后，接着执行istream\u0026构造函数体的内容。它的构造函数体调用read函数读取给定的istream。 当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行。在Sales_data类中，受委托的构造函数体恰好是空的。假如函数体包含有代码的话，将先执行这些代码，然后控制权才会交还给委托者的函数体。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:7","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#委托构造函数"},{"categories":["C++学习"],"content":"默认构造函数的作用当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况发生： 当我们在块作用域内不使用任意初始值定义一个非静态变量或者数组时。 当一个类本身含有类类型的成员且使用合成的默认构造函数时。 当类类型的成员没有在构造函数初始值列表中显式的初始化时。 值初始化在以下情况发生： 在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时。 当我们不使用初始值定义一个局部静态变量时。 当我们通过书写形如T()的表达式显式的请求值初始化时，其中T是类型名。 类必须包含一个默认构造函数以便在上述情况下使用，其中大多数情况非常容易判断。 不那么明显的一种情况是类的某些数据成员缺少默认构造函数： class NoDefault{ public: NoDefault(const std::string\u0026); // 还有其他成员，但是没有其他构造函数了 }; struct A { //默认情况下，my_mem是public的 NoDefault my_eme; }; A a; // 错误，不能为A合成构造函数 struct B { B() {} //错误，b_member没有初始值 NoDefault b_member; }; 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:8","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#默认构造函数的作用"},{"categories":["C++学习"],"content":"使用默认构造函数下面的obj的声明可以正常编译通过： Sales_data obj(); // 正确：定义了一个函数而非对象 if (obj.isbn == Primer_5th_ed.isbn()) // 错误，obj是一个函数 Sales_data obj2; // 正确，obj2是一个对象而非函数。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:1:9","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#使用默认构造函数"},{"categories":["C++学习"],"content":"拷贝、赋值和析构除了定义类的对象如何初始化之外，类还需要控制拷贝、赋值和销毁对象时发生的行为。如果不主动定义这些操作，编译器将替我们合成它们。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:2:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#拷贝赋值和析构"},{"categories":["C++学习"],"content":"某些类不能依赖于合成的版本尽管编译器可以替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:2:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#某些类不能依赖于合成的版本"},{"categories":["C++学习"],"content":"访问控制与封装 定义在 public 说明符之后的成员在整个程序内可被访问，public成员定义类的接口。 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:3:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#访问控制与封装"},{"categories":["C++学习"],"content":"使用class或struct关键字struct和class之间的唯一一点区别就是，struct和class的默认访问权限不同。 如果使用struct关键字，则定义在第一个访问说明符之前的成员时public的；相反，如果使用class关键字，则这些成员是private的。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:3:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#使用class或struct关键字"},{"categories":["C++学习"],"content":"友元类可以允许其他类或函数访问它的非公有成员，方法是令其他类或者函数成为他的友元（friend）。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字展开的函数声明语句即可。 class Sales_data{ friend Sales_data add(const Slaes_data\u0026, const Slaes_data\u0026); }; 友元声明只能出现在类定义的内部，但是在类内出现的位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。 一般来说，最好在类定义开始或结束前的位置集中声明友元。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#友元"},{"categories":["C++学习"],"content":"友元的声明友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果希望类的用户能够调用某个友元函数，那么就必须在友元声明之外再专门对函数进行一次说明。 为了使友元对类的用户可见，通常把友元的声明和类本身放置在同一个头文件中。 除了可以将普通的函数定义成友元，类还可以把其他类定义成友元，也可以把其他类的成员函数定义成友元。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#友元的声明"},{"categories":["C++学习"],"content":"类之间的友元关系假设需要为window_mgr类添加一个名为clear的成员，负责将一个指定的Screen的内容设为空白。为完成这一任务，clear需要访问Screen的私有成员；要令这种行为合法，Screen需要将window_mgr指定成它的友元。 class Screen{ friend class window_mgr; }; 如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。通过上面的声明，window_mgr被指定为Screen的友元，因此可以将window_mgr的clear成员写成如下形式： class window_mgr{ public: using ScreenIndex = std::vector\u003cScreen\u003e::size_type; void clear(ScreenIndex); private: std::vector\u003cScreen\u003e screens{Screen(24, 80, ' ')}; }; void window_mgr::clear(ScreenIndex i){ Screen \u0026s = screens[i]; //s是想清空的屏幕 s.contents = string(s.height * s.width, ' '); //将选定的屏幕重置为空白 } 需要注意的是，友元关系不存在传递性。也就是说，如果window_mgr有它自己的友元，则这些友元不能理所当然的具有访问Screen的特权。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类之间的友元关系"},{"categories":["C++学习"],"content":"令成员函数作为友元除了令整个window_mgr作为友元之外，Screen还可以只为clear提供访问权限。当把一个成员函数声明成友元时，必须明确指出该成员函数属于哪个类： class Screen{ // window_mgr::clear必须在Screen类之前被声明 friend void window_mgr::clear(ScreenIndex); // Screen类的剩余部分 }; 要令某个成员函数作为友元，必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在本例中，按照如下方式设计程序： 首先定义window_mgr类，其中声明clear函数，但是不能定义它。在clear使用Screen的成员之前必须先声明Screen。 接下来定义Screen，包括对于clear的友元声明。 最后定义clear，此时它才可以使用Screen的成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#令成员函数作为友元"},{"categories":["C++学习"],"content":"函数重载和友元尽管重载函数的名字相同，但他们仍是不同的函数。因此，如果想把一组重载函数声明成它的友元，需要对这组函数的每一个分别声明： extern std::ostream\u0026 storeOn(sdt::ostream \u0026, Screen \u0026); extern BitMap\u0026 storeOn(BitMap \u0026, Screen \u0026); class Screen{ friend std::ostream\u0026 storeOn(sdt::ostream \u0026, Screen \u0026); }; Screen类把接受ostream\u0026的storeOn声明成它的友元，但是接受BitMap\u0026作为参数的版本仍然不能访问Screen。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#函数重载和友元"},{"categories":["C++学习"],"content":"友元声明和作用域类和非成员函数的声明不是必须在它们的友元声明之前。当一个名字第一次出现在一个友元声明中，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。 甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，他也必须是声明过的： struct X { frined void f(); X() { f(); } void g(); void h(); }; void X::g() { return f(); } // 错误，f没有被声明 void f(); void X::h() { return f(); } // 正确，现在f的声明在作用域中 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:4:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#友元声明和作用域"},{"categories":["C++学习"],"content":"类的其他特性","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类的其他特性"},{"categories":["C++学习"],"content":"定义一个类型成员 class Screen{ public: typedef std::string::size_type pos; private: pos sursor = 0; pos height = 0, width = 0; std::string contents; }; 在Screen的public部分定义pos，这样用户就可以使用这个名字。 关于pos的定义又两点需要注意。首先，我们使用了typedef，也可以等价的使用类型别名： class Screen{ public: using pos = std::string::size_type; }; 其次，用来定义类型的成员必须先定义后使用。类的成员通常出现在类开始的地方。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#定义一个类型成员"},{"categories":["C++学习"],"content":"Screen类的成员函数 #include \u003ciostream\u003e using namespace std; class Screen{ public: typedef std::string::size_type pos; Screen() = default;//Screen有另一个构造函数，所以本函数是必须的。 Screen(pos ht, pos wd, char c):height(ht), width(wd), contents(ht*wd,c){}//cursor初始值初始化为0 char get() const{ return contents[cursor]; //隐式内联 } inline char get(pos ht, pos wd) const; //显式内联 Screen \u0026move(pos r, pos c); //能在之后设置为内联 private: pos cursor = 0; pos height = 0, width = 0; std::string contents; }; 因为已经提供一个构造函数，所以编译器不会自动生成默认的构造函数。如果类需要默认构造函数，就必须显式的把它声明出来。 在第二个构造函数为cursor成员隐式的使用类内初始值。如果类中不存在cursor的类内初始值，就需要像其他成员一样显式的初始化cursor。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#screen类的成员函数"},{"categories":["C++学习"],"content":"令成员作为内联函数在类中，常有一些规模较小的函数适合于被声明为内联函数，定义在类内部的成员函数都是自动inline的。 我们可以在类的内部把inline作为声明的一部分显式的声明成员函数，同样地，也能在类的外部用inline关键字修饰函数的定义。 inline //在函数的定义处指定inline Screen \u0026Screen::move(pos r, pos c){ pos row = r * width; // 计算行的位置 cursor = row + c; //在行内将光标移动到指定列 return *this; //以左值的形式返回对象 } char Screen::get(pos r, pos c) const{ // 在类的内部声明成inline pos row = r * width; //计算行的位置 return contents[row + c]; //返回给定字符 } 最好只在类外部定义的地方说明inline，这样可以使类更容易理解。inline函数应该与相应的类定义在同一个头文件中。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#令成员作为内联函数"},{"categories":["C++学习"],"content":"重载成员函数和非成员函数一样，成员函数也可以被重载，只要函数之间在参数的数量和/或类型上有所区别即可。成员函数的函数匹配过程同样与非成员函数十分类似。 Screen myscreen; char ch = myscreen.get(); //Screen::get() ch = myscreen.get(0,0); // Screen::get(pos,pos) ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#重载成员函数"},{"categories":["C++学习"],"content":"可变数据成员有时我们希望能修改类的某个数据成员，即使是在一个const成员函数内。可以通过在变量的声明中加入 mutable关键字做到这一点。 一个可变数据成员永远不会是const，即使它是const对象的成员，因此，一个const成员函数可以改变一个可变成员的值。 class Screen{ public: void some_member() const; private: mutable size_t access_ctr; //即使在一个const对象内也能被修改 }; void Screen::some_member() const{ ++access_ctr; //保存一个计数值，用于记录成员函数被调用的次数 } ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#可变数据成员"},{"categories":["C++学习"],"content":"类数据成员的初始值在定义好Screen类之后，我们将继续定义一个窗口管理类并用它表示显示器上的一组Screen。这个类将包含一个Screen类型的vector，每个元素表示一个特定的Screen。默认情况下，我们希望Window_mgr类开始时总是拥有一个默认初始化的Screen。在C++11标准中，最好的方式就是把这个默认值声明成一个类内初始值： class Windoe_mgr{ private: std::vector\u003cScreen\u003e screens{Screen(24, 80, ' ')}; }; 类内初始值必须使用=的初始化形式或者花括号阔气来的直接初始化形式。 当我们提供一个类内初始值时，必须以符号=或花括号结尾 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:5:6","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类数据成员的初始值"},{"categories":["C++学习"],"content":"返回*this的成员函数 class Screen{ public: typedef std::string::size_type pos; Screen \u0026set(char); Screen \u0026set(pos, pos, char); }; inline Screen \u0026Screen::set(char c){ contents[cursor] = c; // return *this; //将this对象作为左值返回 } inline Screen \u0026Screen::set(pos r, pos col, char ch){ contents[r * width + col] = ch; return *this; } 返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本，如果将一系列的操作连接在一条表达式中的话： myScreen.move(4,0).set('#'); 如果令move和set返回的是Screen而非Screen\u0026的话，上述语句行为将大不相同，等价于： Screen temp = myScreen.move(4,0); //对返回值进行拷贝 temp.set('#'); // 不会改变myScreen的contents 如果定义的返回类型不是引用，则move的返回值将是*this的副本，因此调用set只能改变临时副本，而不能改变没有Screen的值。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:6:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#返回this的成员函数"},{"categories":["C++学习"],"content":"从const成员函数返回*this一个const成员函数如果以引用的形式返回*this，那么它的返回类将是常量引用。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:6:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#从const成员函数返回this"},{"categories":["C++学习"],"content":"基于const的重载 class Screen{ public: typedef std::string::size_type pos; Screen \u0026display(std::ostream \u0026os){ do_display(os); return *this; } Screen \u0026display(std::ostream \u0026os) const{ do_display(os); return *this; } private: void do_display(std::ostream \u0026os) const{ os \u003c\u003c contents; } 当display调用do_display时，它的this指针隐式的传递给do_display。当display的非常量版本调用do_display时，它的this指针将隐式的从指向非常量的指针转换成指向常量的指针。 当do_display完成后，display函数各自返回解引用this所得的对象。在非常量版本中，this指向一个非常量对象，因此display返回一个非常量的引用；而const成员则返回一个常量引用。 当在某个对象上调用display时。该对象是否是const决定了应该调用disply的哪个版本。 Screen myScreen(5,3); const Screen blank(5,3); myScreen.set('#').display(cout); //非常量版本 blank.display(cout); //常量版本 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:6:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#基于const的重载"},{"categories":["C++学习"],"content":"类类型对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:7:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类类型"},{"categories":["C++学习"],"content":"类的声明像可以把函数的声明和定义分开来一样，也可以先声明类而不定义它。 class Screen; 这种声明有时被称为前向声明，向程序中引入名字Screen并指明Screen是一种类类型。对于类型Screen来说，在它声明之后定义之前是一个不完全类型，此时只知道Screen是一个类类型，但不清楚其包含哪些成员。 不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但不能定义）以不完全类型作为参数或返回类型的函数。 直到类被定义之后数据成员才能被声明成这种类类型。只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，他就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:7:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类的声明"},{"categories":["C++学习"],"content":"类的作用域每个类都会定义自己的作用域，在类的作用域之外，普通的数据和函数成员只能由对象、引用或者指针使用成员访问运算符来访问。对于类类类型成员则使用作用域运算符进行访问。不论哪种情况，跟在运算符之后的名字都必须是对应类的成员： Screen::pos ht = 24, wd = 80; // 使用Screen定义的pos类型 Screen scr(ht, wd, ' '); Screen *p = \u0026scr; char c = scr.get(); // 访问scr对象的get成员 c = p -\u003e get(); // 访问p所指对象的get成员 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:8:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类的作用域"},{"categories":["C++学习"],"content":"作用域和定义在类外部的成员类一旦遇到类名，定义的剩余部分就在类的作用域之内，这里的剩余部分包括参数列表和函数体。结果就是，可以直接使用类的其他成员而无须再次授权。 void window_mgr::clear(ScreenIndex){ Screen \u0026s = screen[i]; s.contents = string(s.height * s.width, ' '); } 因为编译器在处理参数列表之前已经明确了我们当前正位于window_mgr类的作用域中，所以不必再专门说明ScreenIndex是window_mgr声明的。出于同样的原因，编译器也能知道函数体中用到的screens也是在window_mgr类中定义的。 另一方面，函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。例如，向window_mgr类中添加一个新的名为addScreen的函数，负责向显示器添加一个新的屏幕。这个成员的返回类型将是ScreenIndex，用户可以通过它定位到指定Screen： class window_mgr{ public: ScreenIndex addScreen(const creen\u0026); }; window_mgr::ScreenIndex window_mgr::addScreen(const Screen \u0026s){ screens.push_back(s); return screen.size() - 1; } 因为返回类型出现在类名之前，所以事实上它是位于window_mgr类的作用域之外的。在这种情况下，要想使用ScreenIndex作为返回类型，我们必须明确指定哪个类定义了它。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:8:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#作用域和定义在类外部的成员类"},{"categories":["C++学习"],"content":"名字查找与类的作用域 首先在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明。 如果没找到，继续查找外层作用域。 如果最终没有找到匹配的声明，则程序报错。 对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别。类的定义分两步处理： 首先，编译成员的声明。 直到类全部可见后才编译函数体。 按照这种两阶段的方式处理类可以简化类代码的组织方式。因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#名字查找与类的作用域"},{"categories":["C++学习"],"content":"用于类成员声明的名字查找两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须确保在使用前可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。例如： typedef double Money; string bal; class Account{ public: Money balance(){ return bal; } private: Money bal； }; 当编译器看到balance函数的声明语句时，将在Account类的范围内寻找对Money的声明。编译器只考虑Account中在使用Money前出现的声明，因为没找到匹配的成员，所以编译器会接着到类的外层作用域中查找。在本例中，编译器会找到Money的typedef语句。另外ia，balance函数体在整个类可见后才被处理，因此，该函数返回名为bal的成员，而非外层作用域的string对象。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#用于类成员声明的名字查找"},{"categories":["C++学习"],"content":"类姓名要特殊处理在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字。 typedef double Money; class Account{ public: Money balance(){ return bal; } private: typedef double Money; // 错误，不能重新定义Money Money bal; }; 需要注意的是，即使Account中定义的Money类型与外层作用域一致，上述代码仍然是错误的。 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类姓名要特殊处理"},{"categories":["C++学习"],"content":"成员定义中普通块作用域的名字查找c成员函数中使用的名字按照如下方式解析: 首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑。 如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑。 如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。 一般来说，不建议使用其他成员的名字作为某个成员函数的参数。 int height; class Screen{ public: typedef std::string::size_type pos; void dummy_fcn(pos height){ cursor = width * height; //使用哪个height } private: pos cursor = 0; pos height = 0, width = 0; }; 当编译器处理dummy_fcn中的乘法表达式时，首先在函数作用域内查找表达式中用到的名字。函数的参数位于函数作用域内，因此dummy_fcn函数体内用到的名字height指的是参数声明。 此例中，height参数隐藏了同名的成员。如果想绕开上面的查找规则1，应该将代码变为： // 成员函数中的名字不应该隐藏同名成员 void Screen::dummy_fcn(pos height){ cursor = width * this-\u003eheight; //另一种表示该成员的方式 cursor = width * Screen::height; } 最好的确保使用height成员的方法是给参数起个其他名字： //建议的写法：不要把成员名字作为参数或其他局部变量使用 void Screen::dummy_fcn(pos ht){ cursor = width * height; } 在此例中，编译器查找名字height时，在dummy_fcn函数内部是找不到的。编译器接着会在Screen内查找匹配的声明，即使height的声明在dummy_fcn使用它之后，编译器也能正确地解析函数使用的是名为height的成员。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#成员定义中普通块作用域的名字查找"},{"categories":["C++学习"],"content":"类作用域之后，在外围的作用域中查找如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。在我们的例子中。名字height定义在外层作用域中。且位于Screen的定义之前。然而，外层作用域中的对象被名为height的成员隐藏掉了。因此，如果我们需要的是外层作用域中的名字，可以显式的通过作用域运算符进行请求： //不建议的写法，不要隐藏外层作用域中可能被用到的名字 void Screen::dummy_fcn(pos height){ cursor = width * ::height; } ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类作用域之后在外围的作用域中查找"},{"categories":["C++学习"],"content":"在文件中名字出现处对其进行解析当成员定义在类的外部时，名字查找的第三步不仅要考虑定义之前的全局作用域中的声明，还要考虑在成员函数定义之前的全局作用域中的声明。 int height; class Screen{ public: typedef std::string::size_type pos; void setHeight(pos); pos height = 0; //隐藏外层作用域中的height }; Screen::pos verify(Screen::pos); void Screen::setHeight(pos var){ //var：参数 //height：类的成员 //verify：全局函数 height = verify(var); } 全局函数verify的声明在Screen的定义之前是不可见的。然而，名字查找的第三步包括了成员函数出现之前的全局作用域。在此例中，verify的声明位于setHeight的定义之前，因此可以被正常使用。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:9:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#在文件中名字出现处对其进行解析"},{"categories":["C++学习"],"content":"隐式的类类型转换如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们将这种构造函数称为转换构造函数。 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。 在Saels_data类中，接受string的构造函数和接受istream的构造函数分别定义了两种类型向Sales_data隐式转换的规则。也就是说，在需要使用Sales_data的地方，我们可以使用string和istream作为替代： string null_book = \"9-999-99999-9\"; // 建立一个临时的Sales_data对象 //该对象的units_sold和revenue等于0，bookNo等于null_boook item.combine(null_book); 这里我们用一个string实参调用Sales_data的combine成员。该调用是合法的，编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:0","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#隐式的类类型转换"},{"categories":["C++学习"],"content":"只允许一步类类型转换编译器只会自动的执行一步类型转换。例如，下边的代码隐式的使用了两种转换规则，所以它是错误的： // 错误，需要用户定义的两种转换： // （1）把“9-999-99999-9”转换成string // （2）再把临时的string转换为Sales_data item.combine(\"9-999-99999-9\"); 如果想完成上述调用，可以显式的把字符串转换为string或Sales_data对象： // 正确：显式的转换成string，隐式的转化成Sales_data item.combine(string(\"9-999-99999-9\")); // 正确：隐式的转换为string，显式的转换为Slaes_data item.combine(Sales_data(\"9-999-99999-9\")); ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:1","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#只允许一步类类型转换"},{"categories":["C++学习"],"content":"类类型转换不是总有效是否需要从string到Sales_data的转换依赖于我们对用户使用该转换的看法。在此例中，这种转换可能是对的。null_book中的string可能表示了一个不存在的ISBN编号。 另一个是从istream到Sales_data的转换： // 使用istream构造函数创建一个函数传递给combine item.combine(cin); 这段代码隐式的把cin转换成Sales_data，这个转换执行了接受一个istream的Sales_data构造函数。该构造函数通过读取标准输入创建了一个临时的Sales_data对象，随后将得到的对象传递给combine。 Sales_data对象是个临时量，一旦combine完成我们就不能再访问它。实际上，我们构建一个对象，先将它的值加到item中，随后将其丢弃。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:2","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#类类型转换不是总有效"},{"categories":["C++学习"],"content":"抑制构造函数定义的隐式转换在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为explicit加以阻止： class Sales_data{ public: Sales_data() = default; Sales_data(std::string s, unsigned cnt, double price):bookNo(s), units_sold(cnt), revenue(cnt*price){} explicit Sales_data(const std::string \u0026s):bookNo(s){} explicit Sales_data(std::istream \u0026is); 此时，没有任何构造函数能够用于隐式的创建Sales_data对象，之前的两种用法都无法通过编译： item.conbine(null_book); // 错误，string构造函数是explicit的 item.combine(cin); // 错误，istream构造函数是explicit的 关键字explicit只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为explicit的，只需要在类内声明构造函数时使用explicit关键字，在类外部定义时不用重复： // 错误：explicit关键字只允许出现在类内的构造函数声明处 explicit Sales_data::Sales_data(isteam\u0026 is){ rean(is, *this); } ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:3","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#抑制构造函数定义的隐式转换"},{"categories":["C++学习"],"content":"explicit构造函数只能用于直接初始化发生隐式转换的一种情况是当我们执行拷贝形式的初始化时。此时，我们只能使用直接初始化，而不能使用explicit构造函数： Sales_data item1(null_book); // 正确，直接初始化 // 错误，不能将explicit构造函数用于拷贝形式的初始化过程诶 Sales_data item2 - null_book; ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:4","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#explicit构造函数只能用于直接初始化"},{"categories":["C++学习"],"content":"为转换显式的使用构造函数尽管编译器不会将explicit的构造函数用于隐式转换过程，但是可以使用这样的构造函数显式的强制进行转换： // 正确，实参是一个显式构造的Sales_data对象 item.combine(Sales_data(null_book)); // 正确：static_cast可以使用explicit的构造函数 item.combine(Sales_data(static_cast\u003cSales_data\u003e(cin))) 在第一个调用中，直接使用Sales_data的构造函数，该调用通过接受string的构造函数创建了一个临时的Sales_data对象。 在第二个调用中，使用static_cast执行了显式而非隐式的转换。其中，static_cast使用istream构造函数创建了一个临时的Sales_data对象。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:5","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#为转换显式的使用构造函数"},{"categories":["C++学习"],"content":"标准库中含有显式构造函数的类我们用过一些白赚苦衷的类含有单参数的构造函数： 接受一个单参数的const char*的string构造函数不是explicit的。 接受一个容量参数的vector构造函数是explicit的。 ","date":"04-05","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/:10:6","series":["C++ Primer"],"tags":["类","继承"],"title":"C++学习之类","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB/#标准库中含有显式构造函数的类"},{"categories":["中国电影"],"content":"This is a test text!!!","date":"04-04","objectID":"/2022/youngstyle/:0:0","series":["电影"],"tags":["高考","青春","中国电影"],"title":"青春派","uri":"/2022/youngstyle/#this-is-a-test-text"},{"categories":["C++学习"],"content":"函数基础典型的函数定义包括以下部分：返回类型、函数名、形参列表和函数体。 形参列表中形参用逗号隔开，其中每个形参都是一个含有声明符的声明。即使两个形参的类型一样，也必须把两个类型写出来。 int fun(int a,b) // false int fun(int a, int b) // true #include \u003ciostream\u003eusing namespace std; int jc(int a){ int res = 1; for(int i = 1; i \u003c= a; i++){ res *= i; } return res; } int main(){ int a; cin \u003e\u003e a; cout \u003c\u003c jc(a) \u003c\u003c endl; } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:1:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数基础"},{"categories":["C++学习"],"content":"局部对象名字有作用域，对象有生命周期。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:2:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#局部对象"},{"categories":["C++学习"],"content":"自动对象对于普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义的块末尾时销毁它。把志存在于块执行期间的对象成为自动对象。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:2:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#自动对象"},{"categories":["C++学习"],"content":"局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对他有影响。 将局部变量定义为static类型来获得这样的对象。 #include \u003ciostream\u003eusing namespace std; size_t count_calls(){ static size_t ctr = 0; return ++ctr; } int main(){ for(size_t i = 0; i != 10; ++i){ count_calls(); } cout \u003c\u003c count_calls(); // 11, 如果ctr没有被定义为static，则输出1. return 0; } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:2:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#局部静态对象"},{"categories":["C++学习"],"content":"函数声明函数只能定义一次，但是可以声明多次。函数的声明和定义十分类似，唯一的区别就是函数声明无需函数体，一个分号替代即可。 函数的三要素（返回类型、函数声明和形参类型）描述了函数的接口，说明了调用该函数所需的全部信息。函数声明也被成为函数原型。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:3:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数声明"},{"categories":["C++学习"],"content":"参数传递形参的类型决定了形参和实参交互方式。如果形参时引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。 当形参是引用类型时，我们说它对应的实参被引用传递或者函数被传引用调用。 当实参的值被拷贝给形参时，形参和实参时两个相互独立的对象。我们说这样的实参被值传递或者函数被传值调用。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:4:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#参数传递"},{"categories":["C++学习"],"content":"指针形参当执行指针拷贝操作时，拷贝的时指针的值。拷贝之后，两个指针是不同的指针。因为指针时我们可以间接访问它所指的对象，所以通过指针可以修改它所指对象的值。 #include \u003ciostream\u003eusing namespace std; int main(){ int n = 0, i = 42; int* p = \u0026n; int* q = \u0026i; cout \u003c\u003c *p \u003c\u003c *q \u003c\u003c endl;// 0, 42 *p = 4; cout \u003c\u003c n \u003c\u003c endl;// 4 p = q; cout \u003c\u003c *p \u003c\u003c n \u003c\u003c endl;// 42, 4 } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:4:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#指针形参"},{"categories":["C++学习"],"content":"传引用参数 使用引用避免拷贝 拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本不治持拷贝操作（包括IO类型在内）。当某种类型不治持拷贝操作时，函数只能通过引用形参访问该类型的对象。 使用形参返回额外信息 ？？？还没整明白 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:4:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#传引用参数"},{"categories":["C++学习"],"content":"const形参和实参和其他初始化过程一样，当用实参初始化形参时会忽略掉顶层const。当形参有顶层const时，传给他常量对象或者非常量对象都是可以的。 void func(const int i){} // 该函数只能读取i，不能对i的值做修改。 在调用func函数时，既可以传入const int，也可以传入int。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:5:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#const形参和实参"},{"categories":["C++学习"],"content":"指针或引用型参与const可以使用非常量初始化一个底层const对象，但是反过来不行；同时一个普通的引用类型必须用同类型的对象初始化。 int i = 42; const int *cp = \u0026i; //对 const int \u0026r = i; //对 const int \u0026r2 = 42; //对 int *p = co; //错，类型不匹配 int \u0026r3 = r; //错，类型不匹配 int \u0026r4 = 42; //错，类型不匹配 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:5:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#指针或引用型参与const"},{"categories":["C++学习"],"content":"尽量使用常量引用把函数不会改变的形参定义成普通引用是一种比较常见的错误，这样做会给调用者一种误导，即函数可以修改它实参的值。此外，使用引用而非常量引用也会极大限制函数所能接受的实参类型。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:5:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#尽量使用常量引用"},{"categories":["C++学习"],"content":"数组形参数组的两个特殊性质： 1.不允许拷贝数组； 2.使用数组时通常会将其转换为指针。 因为不能拷贝数组，所以无法以值传递的方式使用数组参数。因为数组会被转换为指针，所以为函数传递一个数组时，实际上传递的事指向数组首元素的指针。 虽然不能以值传递的方式传递数组，但是可以将形参写成类似数组的形式。 void print(const int*); void print(const int[]); void print(const int[10]); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#数组形参"},{"categories":["C++学习"],"content":"使用标记指定数组长度要求数组本身包含一个结束标记，这种方法的典型示例是C风格字符串，C风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。 void print(const char* cp){ if(cp) while(*cp) cout \u003c\u003c *cp++; } 适用于有明显结束标记且该标记不会与普通数据混淆的情况。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#使用标记指定数组长度"},{"categories":["C++学习"],"content":"使用标准库规范管理数组实参的第二种技术是传递指向首元素和尾后元素的指针。 void print(const int* beg, const int* end){ while(beg != end){ cout \u003c\u003c *beg++ \u003c\u003c endl; } } int j[2] = {0, 1}; print(begin(j), end(j)); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#使用标准库规范"},{"categories":["C++学习"],"content":"显式传递一个表示数组大小的形参 void print(const int ia[], size_t size){ for(size_t i = 0; i != size; ++i){ cout \u003c\u003c ia[i] \u003c\u003c endl; } } int j[] = {0,1}; print(j, end(j) - begin(j)); 只要传递给函数的size步超过数组实际大小，函数就是安全的。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:3","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#显式传递一个表示数组大小的形参"},{"categories":["C++学习"],"content":"数组形参和const当函数不需要对数组元素执行写操作时，数组形参应该是指向const的指针。 当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:4","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#数组形参和const"},{"categories":["C++学习"],"content":"数组引用形参C++允许将变量定义成数组的应用，同理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定在数组上。 void print(int (\u0026arr)[10]){ for (auto elem : arr) cout \u003c\u003c elem \u003c\u003c endl; } int j[2] = {0,1}; int k[10] = {0,1,2,3,4,5,6,7,8,9}; print(j); // 错误，实参不是含有10个整数的数组 print(k); // 正确 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:5","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#数组引用形参"},{"categories":["C++学习"],"content":"传递多维数组将多维数组传给函数时，真正传递的是指向数组首元素的指针。因为处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维的大小都是数组类型的一部分。 void print(int (*matrix)[10], int rowSize) // 等价定义 void print(int matrix[][10], int rowSize) ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:6:6","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#传递多维数组"},{"categories":["C++学习"],"content":"含有可变形参的函数有时无法提前预知应该向函数传递几个实参，此时最好使用同一个函数实现该项功能。 initializer_list形参 如果函数的实参数量未知但是全部实参类型都相同，此时可以使用initializer_list类型的形参。 initializer_list是一种标准库类型，用于表示某种特定类型的值的数组。 和vector一样，initializer_list也是一种模板类型，在定义initializer_list对象时，必须说明列表所含元素的类型。 initializer_list\u003cint\u003e li; 和vector不一样的是，initializer_list对象中的元素永远是常量值，无法对initializer_list对象中元素的值。 如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一对花括号内。 void error_msg(initializer_list\u003cstring\u003e il){ for(auto beg = il.begin(); beg != il.end(); ++beg) cout \u003c\u003c *beg \u003c\u003c \" \"; cout \u003c\u003c endl; } if(expected != actual) error_msg({\"function\", expected, actual}); else error_msg({\"functionX\", \"okay\"}); 含有initializer_list形参的函数也可以同时拥有其他形参。 void error_msg(ErrCode e,initializer_list\u003cstring\u003e il){ cout \u003c\u003c e,msg() \u003c\u003c \": \"; for(const auto \u0026elem : il) cout \u003c\u003c elem \u003c\u003c \" \"; cout \u003c\u003c endl; } if(expected != actual) error_msg(ErrCode(42), {\"function\", expected, actual}); else error_msg(ErrCode(0), {\"functionX\", \"okay\"}); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:7:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#含有可变形参的函数"},{"categories":["C++学习"],"content":"返回类型和return语句","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:8:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#返回类型和return语句"},{"categories":["C++学习"],"content":"无返回值函数没有返回值的return语句只能用在返回类型是void的函数中。 通常，如果void函数如果想在中间位置提前退出，可以使用return语句。此时return语句的作用类似于break语句。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:8:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#无返回值函数"},{"categories":["C++学习"],"content":"有返回值的函数 不要返回局部对象的引用或指针 函数完成后，它所占用的存储空间也随之被释放。因此，函数终止意味着局部变量的引用意味着局部变量的引用将指向不再有效的内存区域。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:8:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#有返回值的函数"},{"categories":["C++学习"],"content":"函数重载如果同一作用域的几个函数名字相同但形参列表不同，称之为重载函数。(main函数不能重载) 重载函数最好只用于操作非常相似的函数。 虽然函数的名称相同，但编译器会格局实参的类型确定应该调用哪个函数。 但是，不允许两个函数除了返回值类型之外其他所有的要素都相同。假设有两个函数，他们的形参列表一样，的那是返回类型不同，那么第二个函数的声明是错误的。 int lookup(const Account\u0026); bool lookup(const Account\u0026); //错误，与上一函数相比，仅返回类型不同。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:9:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数重载"},{"categories":["C++学习"],"content":"重载和const形参一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。 Record lookup(phone); Record lookup(const phone); //重复声明了Record lookup(phone) 如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层的。 Record lookup(Account\u0026); Reocrd lookup(const Account\u0026); Record lookup(Account*); Reocrd lookup(const Account*); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:9:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#重载和const形参"},{"categories":["C++学习"],"content":"const_cast和重载 const string \u0026shortString(const string \u0026s1, const string \u0026s2){ reutrn s1.size() \u003c= s2.size() ? s1 : s2; } 这个函数的参数和返回值类型都是const string的引用。我们可以对两个非常量的string实参调用这个函数，但返回的结果依然是const string的引用。因此，我们需要一种新的shortString函数，当它的实参不是常量时，得到的结果是一个普通的引用，此时可使用const_cast。 string \u0026shortString(string \u0026s1, string \u0026s2){ auto \u0026r = shortString(const_cast\u003cconst string\u0026\u003e(s1), const_cast\u003cconst string\u0026\u003e(s2)); return const_cast\u003cstring\u0026\u003e(r); } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:9:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#const_cast和重载"},{"categories":["C++学习"],"content":"默认实参默认实参只能在函数声明和lambda表达式的形参列表中出现，而不能在函数指针、到函数的引用，或在typedef声明中出现。 如果friend声明指定了默认实参。那么它必须是友元函数的定义，且该翻译单元中不能有此函数的其他声明。 在函数的很多次调用中他们都被赋予一个相同的值，此时，将这个反复出现的值称为函数的默认实参。 typedef string::size_type sz; string screen(sz ht = 24, sz wid = 80, char backgrnd = ' '); string window; window = screen(); // screen(24,80,' ') window = screen(66,256,'#'); // screen(66,256,'#') ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:10:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#默认实参"},{"categories":["C++学习"],"content":"默认实参声明对于函数声明，通常习惯将其放在头文件中，并且一个函数只声明一次，但多次声明同一函数也是合法的。 但是，需要注意，在给定的作用域中，一个形参只能被赋予一次默认实参。换句话说，就是在函数的后续声明中，只能为之前没有默认值的形参添加默认实参，而且该形参右侧所有形参必须都有默认值。 string screen(sz, sz, char = ' '); string screen(sz, sz, char = '*'); // 错误，不能修改一个已经存在的默认值 string screen(sz = 24, sz = 24, hcar); //正确，添加默认实参 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:10:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#默认实参声明"},{"categories":["C++学习"],"content":"默认实参初始值局部变量不能作为默认实参。除此之外，只要表达式的类型能够转换成形参所需的类型，该表达式就能作为默认实参。 sz wd = 80; char def = ' '; sz ht(); string screen(sz = ht(), sz = wd, char = def); string window = screen(); // screen(ht(), 80, ' ') void f2(){ def = '*'; sz wd = 100; window = screen(); // screen(ht(), 80, '*') } def的值在函数f2中被改变，所以screen会调用这个更新过的值，但是wd只是函数内部声明的一个局部变量，和传给screen的实参没有任何关系。 using声明会将已知的默认实参集承接过来，如果向函数的命名空间中添加更多的默认形参，那么这些默认实参在这条using声明可见得的任何位置均可见。 namespace N{ void f(int, int = 1); } using N::f; void g(){ f(7); // 正确，f(7,1) f(); // 错误，实参数量不够 } namespace N{ void f(int = 2, int); } void h(){ f(); // 正确，f(2,1) } ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:10:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#默认实参初始值"},{"categories":["C++学习"],"content":"变长实参允许函数接受任意数量的额外实参。由跟在函数声明的形参列表之后的尾随…指定。 int printx(const char* fmt, ...); printx(\"hello world\"); printx(\"a=%d b=%d\", a,b); int printx(const char* fmt...); //效果同上述函数声明 int printy(...,const char* fmt...); //错误，...不能作为形参出现 int ptintz(...); //合法，但无法可移植的访问参数 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:11:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#变长实参"},{"categories":["C++学习"],"content":"内联函数和constexpr函数内联函数和constexpr函数通常定义在头文件中。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:12:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#内联函数和constexpr函数"},{"categories":["C++学习"],"content":"内联函数可以避免函数调用的开销将函数指定为内联函数(inline)，通常就是在他的每个调用点上内联的展开。 cout \u003c\u003c shotrString(s1, s2) \u003c\u003c endl; 会在编译过程中展开成如下形式 cout \u003c\u003c (s1.size() \u003c s2.size() ? s1 : s2) \u003c\u003c endl; 从而消除shortString函数的运行时开销。 在函数的返回类型前加上关键字inline，就可以将函数声明为内联函数。 inline const string\u0026 shortString(const String \u0026s1, const String \u0026s2){ return s1.size() \u003c s2.size() ? s1 : s2; } 需要注意，内联函数只是向编译器发出的一个请求，编译器可以选择忽略这个请求。 一般来说，内联机制用于优化规模较小，流程直接，频繁调用的函数。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:12:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#内联函数可以避免函数调用的开销"},{"categories":["C++学习"],"content":"constexpr函数contexpr函数是指能用与常量表达式的函数。定义constexpr函数的方法和其他函数类似，不过要遵循几项约定：函数的返回类型以及所有形参的类型都得是字面值类型，而且函数体中有且只有一条return语句。 constexpr int new_sz() { return 42; } constexpr int foo = new_sz(); constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行操作即可。例如，contexor函数中可以有空语句、类型别名以及using声明。 也允许constexpr函数的返回值并非一个常量。 constexpr size_t scale(size_t cnt) { return new_sz() * cnt; } 当scale的实参是常量表达式时，它的返回值也是常量表达式，反之则不然。 int arr[scale(2)]; // 正确 int i = 2; int arr[scale(i)]; // 错误，scale(i)不是常量表达式 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:12:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#constexpr函数"},{"categories":["C++学习"],"content":"函数匹配 void f(); void f(int); void f(int, int); void f(double, double = 3.14); f(5.6); // 调用f(double, double) ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:13:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数匹配"},{"categories":["C++学习"],"content":"函数指针函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定。 bool lengthCompare(const string \u0026, const string \u0026); bool (*pf)(const string \u0026, const string\u0026) *pf两端的括号必不可少，如果没有括号，则pf是一个返回值为bool指针的函数。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数指针"},{"categories":["C++学习"],"content":"使用函数指针当把函数名作为一个值使用时，该函数自动转换为指针，按照如下形式可以将lengthCompare函数的地址赋给pf pf = lengthCompare; pf = \u0026lengthCompare; // 等价赋值语句，取址符时可选的 此外，可以直接使用指向函数的指针调用该函数，无须提前解引用指针： bool b1 = pf(\"hello\", \"goodbye\"); bool b2 = (*pf)(\"hello\", \"goodbye\"); //等价调用 bool b3 = lengthCompare(\"hello\", \"goodbye\"); //另一个等价调用 在指向不同的函数类型的指针间不存在转换规则。但是和往常一样，可以为函数指针赋一个nullptr或值为0的整型常量表达式，表示该指针没有指向任何一个函数。 string::size_type sumLength(const string\u0026, const string\u0026); bool cstringCompare(const char*, const char*); pf = 0; // 正确，此时pf为空指针 pf = sumLength; // 错误，返回值类型不匹配 pf = cstringCompare; // 错误，形参类型不匹配 pf = lengthComapre; // 正确，函数和指针的类型精确匹配 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:1","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#使用函数指针"},{"categories":["C++学习"],"content":"重载函数的指针当使用重载函数时，上下文必须清晰的界定到底选用哪个函数。如果定义了指向重载函数的指针，编译器通过指针类型决定选用哪个函数，指针类型必须和重载函数中某一个精确匹配。 void ff(int*); void ff(unsigned int); void (*pf1)(unsigned int) = ff; //pf1指向ff(unsigned) void (*pf2)(int) = ff; //错误，没有ff与此形参列表匹配 double (*pf3)(int*) = ff; // 错误，返回类型不匹配 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:2","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#重载函数的指针"},{"categories":["C++学习"],"content":"函数和指针形参和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。 void useBigger(const string \u0026s1, const string \u0026s2, bool pf(const string \u0026, const string \u0026)); // 第三个形参是函数类型，会自动转换成指向函数的指针 void useBigger(const string \u0026s1, const string \u0026s2, bool (*pf)(const string \u0026, const string \u0026)); // 等价声明，显式的将形参定义为指向函数的指针 useBigger(s1, s2, lengthCompare); //自动将lenthCompare转换成指向该函数的指针 直接使用函数指针类型显得冗长而繁琐。类型别名和decltype可以简化使用函数指针的代码。 //Func和Func2时函数类型 typedef bool Func(const string\u0026, const string\u0026); typedef decltype(lengthCompare) Func2;//等价的类型 //FuncP和FuncP2是指向函数的指针 typedef bool(*FuncP)(const string\u0026, const string\u0026); typedef decltype(lengthCompare) *FuncP2 // 等价的类型 需要注意的是，decltype返回函数类型，此时不会将函数类型自动转换为指针类型。因为decltype的结果是哈书类型，所以只有在结果前加上*才能得到指针。可以使用如下的形式重新声明useBigger： void useBigger(const string\u0026, const string\u0026, Func); void useBigger(const string\u0026, const string\u0026, *FuncP2); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:3","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#函数和指针形参"},{"categories":["C++学习"],"content":"返回指向函数的指针和数组类似虽然不能返回一个函数，但是可以返回指向函数类型的指针。然而，必须把返回类型写成指针类型，编译器不会自动将函数返回类型当成对应的指针类型处理。与往常一样，要想声明一个返回函数指针的函数，最简单的方法是使用类型别名： using F = int(int*, int); //F为函数类型 using PF = int(*)(int*, int); // PF是指针类型 PF f1(int); // 正确，PF是指向函数的指针，f1返回指向函数的指针 F f1(int); //错误，F是函数类型，f1不能返回一个函数 F *f1(int); //正确，显式的指定返回类型是指向函数的指针 int (*f1(int))(int*, int); //或使用尾置返回类型 auto f1(int) -\u003e int(*)(int*, int); ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:14:4","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#返回指向函数的指针"},{"categories":["C++学习"],"content":"lambda表达式构造闭包：能够捕获作用域中的变量的无名函数对象。 ","date":"03-28","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/:15:0","series":["C++ Primer"],"tags":["函数","形参","实参"],"title":"C++学习之函数","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%87%BD%E6%95%B0/#lambda表达式"},{"categories":["C++学习"],"content":"简单语句 空语句 空语句中只含有一个单独的分号。 ; //空语句 如果程序的某个地方，语法上需要一条语句，但是逻辑上不需要，此时应该使用空语句。 例如，想读取输入流的内容直到遇见一个特定值，除此之外什么也不做。 while(cin \u003e\u003e s \u0026\u0026 s != sought) ; //空语句 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:1:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#简单语句"},{"categories":["C++学习"],"content":"条件语句 switch语句 case关键字和它对应的值一起被称为case标签，case标签必须是整型常量表达式。 如果没有任何一个case标签能够匹配上switch表达式的值，程序将执行紧跟在default标签之后的语句。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:2:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#条件语句"},{"categories":["C++学习"],"content":"循环语句 while 只要条件为真，while语句就重复的执行循环体。 当不确定要迭代多少次时，使用while循环比较合适。或想要在循环结束后访问循环控制变量。 传统for语句 for(init-statement; condition; expression) statement; 范围for语句 for(declaration: expression) statement; expression表示的必须是一个序列，如数组或vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。 不能通过范围for语句增加vector对象的元素。因为在范围for语句中预存了end()值，一旦添加元素，end函数的值可能无效。 do while语句 与while语句非常相似，但是do while语句先执行循环体再检查条件。 do statement; while (condition); 不允许在条件部分定义变量。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:3:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#循环语句"},{"categories":["C++学习"],"content":"跳转语句 break语句 终止离它最近的while、do while、for或switch语句，并从这些语句后第一条语句开始执行。 continue语句 终止最近的循环中的当前迭代，并立即开始下一次迭代。 string buf; while(cin \u003e\u003e buf \u0026\u0026 !buf.empyt()){ if(buf[0] != '_') continue; //读取下一输入 } ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:4:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#跳转语句"},{"categories":["C++学习"],"content":"try语句块和异常处理 throw表达式 throw表达式包含关键字throw和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。 if(item1.isbn() != item2.isbn()) throw runtime_error(\"Data must refer to same ISBN\"); runtime_error是标准异常类型的一种，定义在stdexcept头文件中。 try语句块 try{ program-statement; }catch(exception-declaration){ handler-statements; }catch(exception-declaration){ handler-statements; } catch子句包含三部分：关键字catch、括号内一个对象的声明以及一个块。选中某个catch子句处理异常后，执行与之对应的块。catch一旦执行完成，则跳转到try语句块最后一个catch子句之后的那条语句继续执行。 while(cin \u003e\u003e item1 \u003e\u003e item2){ try{ //添加两个sales_item对象的代码 //如果添加失败，抛出一个runtime_error异常 }catch(runtime_error err){ //提醒用户两个ISBN必须一致，询问是否重新输入 cout \u003c\u003c err.what() \u003c\u003c \"\\nTry Again? Entry y or n\" \u003c\u003c endl; char c; cin \u003e\u003e c; if(!cin || c == 'n') break; } } ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:5:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#try语句块和异常处理"},{"categories":["C++学习"],"content":"标准异常 exception exception头文件定义最通用的异常类exception。只报告异常的发生，不提供任何额外信息。 stdexcept 异常类 异常类型 exception 最常见的问题 runtime_error 只有在运行时才能检测出的问题 range_error 运行时错误：生成的结果超过了有意义的值域范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的结果值不存在 invalid_error 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用一个超出有效范围的值 new头文件定义bad_alloc异常类型，将在之后介绍 type_info头文件定义了bad_cast异常类型，将在之后介绍 只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。 其他异常类型的行为刚好相反：应使用string或C风格字符串初始化这些类型的对象，但不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/:6:0","series":["C++ Primer"],"tags":["语句","异常"],"title":"C++学习之语句及异常","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%AF%AD%E5%8F%A5%E5%8F%8A%E5%BC%82%E5%B8%B8/#标准异常"},{"categories":["C++学习"],"content":"优先级与结合律 优先级会影响程序的正确性，这一点也适用于解引用和指针运算。 int ia[] = {0,2,4,6,8}; int last = *(ia + 4); //此时last值为ia[4]的值 last = *ia + 4; //此时last值为[0]+4 进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为比较对象。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#优先级与结合律"},{"categories":["C++学习"],"content":"递增和递减运算符 前置版本 首先将运算对象加一或减一，然后将改变后的对象作为求值结果(先加再用)。 后置版本 首先将运算对象加一或减一，但求值结果是运算对象改变之前那个值的副本(先用再加)。 int i = 0, j; j = ++i; // j = 1, i = 1 j = i++; // j = 1, i = 2 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#递增和递减运算符"},{"categories":["C++学习"],"content":"算数转换 运算符的运算对象将被转换为最宽的类型 例如，如果一个运算对象的类型是long double，那么不论另一个运算对象的类型是什么，它都会被转换成long double型。 另一种更普遍的情况是，当表达式中既有浮点类型和整数类型时，整数型将被转换成相应的浮点类型。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#算数转换"},{"categories":["C++学习"],"content":"其他隐式类型转换 数组转换为指针 int ia[10]; int* ip = ia; //ia转换成指向数组首元素的指针 指针的转换 转换成布尔类型 char *cp = get_string(); if(cp) /*...*/ //如果指针不是0，条件为真 while(*cp) /*...*/ //如果*cp不是空字符，条件为真 转换成常量 int i; const int \u0026j = i; //非常量转换为const int的引用 const int *p = \u0026i; //非常量的地址转换为const的地址 int \u0026r = j, *q = p; //错误，不允许const转换为非常量 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#其他隐式类型转换"},{"categories":["C++学习"],"content":"显式转换一个命名的强制类型转换具有如下形式： cast-name\u003ctype\u003e(expression) type是转换的目标类型，expression是要转换的值。casy-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种。 static_cast 适用于任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast。 当把较大的算数类型赋值给较小的类型时，static_cast非常有用。 static_cast同样适用于编译器无法自动执行的类型转换。 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; struct B{ int m = 0; void hello() const{ cout \u003c\u003c \"this is B\" \u003c\u003c endl; } }; struct D:B{ void hello() const{ cout \u003c\u003c \"this is D\" \u003c\u003c endl; } }; int main(){ D d; B\u0026 br = d; br.hello(); // this is B D\u0026 another_d = static_cast\u003cD\u0026\u003e(br); another_d.hello(); // this is D } const_cast 只能改变运算对象的底层const,可以用来移除常量性或易变性。 函数指针和成员函数指针无法用于const_cast。 const_cast使得到非const类型的应用或指针能够实际指代const对象，货或到非volatile类型的引用或指针能够实际指代volatile对象。 #include \u003ciostream\u003eusing namespace std; struct type{ int i; type(): i(3){} // 构造函数 void f(int v) const{ // this-\u003ei = v; const_cast\u003ctype*\u003e(this)-\u003ei = v; } }; int main(){ int i = 3; const int\u0026 rci = i; cout \u003c\u003c rci \u003c\u003c endl; // 3 const_cast\u003cint\u0026\u003e(rci) = 4; cout \u003c\u003c rci \u003c\u003c endl; // 4 type t; t.f(5); cout \u003c\u003c t.i \u003c\u003c endl; } reinterpret_cast 与static_const不同，但与const_cast类似。reinterpret_cast是一个编译时指令，通常为运算对象的位模式提供较低层次上的重新编译。 int *io; char *pc = reinterpret_cast\u003cchar*\u003e(ip); string str(pc) //错误，pc所指的真实对象是一个int而非字符。 ","date":"03-20","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":["C++ Primer"],"tags":["运算符","类型转换"],"title":"C++学习之运算符","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%BF%90%E7%AE%97%E7%AC%A6/#显式转换"},{"categories":["C++学习"],"content":"stringstring表示可变长的字符序列，使用string类型前需要包含string头文件，同时需要在命名空间中声明。需要注意，string对象对大小写敏感。 #incude \u003cstring\u003e using std::string; 在最终的字符串中保留输入时的空白符，可以使用getline函数。 string line; getline(cin, line); getline函数的参数是一个输入流和一个string对象，函数从给定的输入流中读入内容，遇到换行符则停止读入，然后将读入的内容存到string对象中。需要注意，如果一开始就读到换行符的话，就会得到一个空的string。 empty函数判断一个string对象是否为空。 size函数返回string对象的长度(无符号整数)。 在使用‘+’对string进行操作时候，必须确保运算符两侧的对象至少有一个是string。 cctype头文件中定义了一组标准库函数对string进行处理。 如果想要使用循环改变string中字符的值。必须将循环变量定义成引用类型。 front函数返回字符串中的首位字符。用法同back函数。 back函数返回字符串中的末位字符。 int main(){ { string s(\"Exemplary\"); char\u0026 back = s.back(); back = 's'; cout \u003c\u003c s \u003c\u003c endl; // Exemplars } { string const c(\"Exemplary\"); char const\u0026 back = c.back(); cout \u003c\u003c back \u003c\u003c endl; // y } } capacity函数返回当前为string分配的存储。 #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; void show_capacity(string const\u0026 s){ cout \u003c\u003c \" \" \u003c\u003c s \u003c\u003c \" has capacity \" \u003c\u003c s.capacity() \u003c\u003c endl; } int main(){ string s(\"Exemplar\"); show_capacity(s); // Exemplar has capacity 15 s += \" is an example.\"; show_capacity(s); // Exemplar is an example. has capacity 30 } find函数用于搜索指定范围中满足特定判别标准的首个元素的迭代器，若找不到则返回last。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003citerator\u003eusing namespace std; int main(){ vector\u003cint\u003e v{1,2,3,4}; int n1 = 3; int n2 = 5; auto res1 = find(begin(v), end(v), n1); auto res2 = find(begin(v), end(v), n2); (res1 != end(v)) ? cout \u003c\u003c \"v contains \" \u003c\u003c n1 \u003c\u003c endl : cout \u003c\u003c \"v does nor contain \" \u003c\u003c n1 \u003c\u003c endl; // v contains 3 (res2 != end(v)) ? cout \u003c\u003c \"v contains \" \u003c\u003c n2 \u003c\u003c endl : cout \u003c\u003c \"v does nor contain \" \u003c\u003c n2 \u003c\u003c endl; // v does nor contain 5 } find_first_of，寻找等于给定字符序列中字符之一的首个字符。搜索只考虑区间 [pos, size()) 。若区间中不存在字符，则返回 npos 。 find_last_of, 寻找等于给定字符序列中字符之一的最后字符。不指定准确的搜索算法。搜索只考虑区间 [0, pos] 。若区间中不存在这种字符，则返回 npos 。用法同find_first_of。 #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main(){ const string s(\"Hello World!\"); const string search_str(\"o\"); const char* search_cstr = \"Good Bye!\"; cout \u003c\u003c s.find_first_of(search_str) \u003c\u003c endl; // 4 cout \u003c\u003c s.find_first_of(search_str, 5) \u003c\u003c endl; // 7 cout \u003c\u003c s.find_first_of(search_cstr) \u003c\u003c endl; // 1 cout \u003c\u003c s.find_first_of(search_cstr, 5, 2) \u003c\u003c endl; // 7 } find_first_not_of, 寻找不等于给定字符序列中任何字符的首个字符。搜索只考虑区间 [pos, size()) 。若区间中不存在字符，则将返回 npos 。 find_lat_not_of, 寻找不等于给定字符序列中任何字符的最后字符。搜索只考虑区间 [0, pos] 。若区间中不存在这种字符，则返回 npos 。 #include \u003cstring\u003e#include \u003ciostream\u003e int main() { std::string to_search = \"Some data with %MACROS to substitute\"; std::cout \u003c\u003c \"Before: \" \u003c\u003c to_search \u003c\u003c '\\n'; auto pos = std::string::npos; while ((pos = to_search.find('%')) != std::string::npos) { // 宏名中容许大写字母、小写字母和数字 const auto after = to_search.find_first_not_of(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\" \"0123456789\", pos + 1); // 现在 to_search[pos] == '%' 而 to_search[after] == ' ' （在 'S' 后） if(after != std::string::npos) to_search.replace(pos, after - pos, \"some very nice macros\"); } std::cout \u003c\u003c \"After: \" \u003c\u003c to_search \u003c\u003c '\\n'; } Before: Some data with %MACROS to substitute After: Some data with some very nice macros to substitute rfind,寻找等于给定字符序列的最后子串。搜索始于 pos ，即找到的子串必须不始于 pos 后的位置。若将 npos 或任何不小于 size()-1 的值作为 pos 传递，则在整个字符串中搜索。即从尾部开始寻找最后出现的给定子串。 #include \u003cstring\u003e#include \u003ciostream\u003e void print(std::string::size_type n, std::string const \u0026s) { if (n == std::string::npos) { std::cout \u003c\u003c \"not found\\n\"; } else { std::cout \u003c\u003c \"found: \\\"\" \u003c\u003c s.substr(n) \u003c\u003c \"\\\"at \" \u003c\u003c n \u003c\u003c '\\n'; } } int main() { std::string::size_type n; std::string const s = \"This is a string\"; // 从字符串尾反向搜索 n = s.rfind(\"is\"); print(n, s); //5 // 从位置 4 反向搜索 n = s.rfind(\"is\", 4); print(n, s); //2 // 寻找单个字符 n = s.rfind('s'); print(n, s); //10 // 寻找单个字符 n = s.rfind('q'); print(n, s); //not found } erase函数用于从string中移除指定字符。 #include \u003ciostream\u003e#include \u003calgorithm\u003e#include \u003cstring\u003eusing namespace std; int main(){ string s(\"This is an example\"); s.erase(0,5); cout \u003c\u003c s \u003c\u003cendl; //is an example s.erase(find(s.begin(), s.end(), ' ')); cout \u003c\u003c s \u003c\u003cendl; //isan example s.erase(s.find(' ')); // 从‘ ’擦除到尾部 cout \u003c\u003c s \u003c\u003c endl;//isan } cl","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:1:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#string"},{"categories":["C++学习"],"content":"vectorvector存放某种给定类型的可变长序列，由于vector容纳者其他对象，因此也被称为容器。同string，要使用vector，必须包含相应的头文件，同时在命名空间中声明。 #include \u003cvector\u003eusing std::vector; vector\u003cint\u003e ivec; //ivec保存int类型的对象 vector\u003cint\u003e ivec2(ivec); //创建ivec2，并把ivec的值复制给ivec2 front和back函数分别实现访问当前容器的首位元素或末位元素。 #include \u003cvector\u003e#include \u003ciostream\u003e int main() { std::vector\u003cchar\u003e letters {'o', 'm', 'g', 'w', 't', 'f'}; if (!letters.empty()) { std::cout \u003c\u003c \"The first character is: \" \u003c\u003c letters.front() \u003c\u003c '\\n'; // o std::cout \u003c\u003c \"The last character is: \" \u003c\u003c letters.back() \u003c\u003c '\\n'; // f } } begin,cbegin,rbegin迭代器见上述string部分内容。 max_size函数返回容器可容纳元素数量最大值。 shrink_to_fit 请求移除未使用的容量,是减少 capacity() 到 size()非强制性请求。 emplace（待补充） emplace_back（待补充） 使用push_back函数可以往vector对象尾压入元素。 使用pop_back函数可以移除vector对象尾元素。 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; void print(vector\u003cint\u003e\u0026 v){ for(auto i : v) cout \u003c\u003c i \u003c\u003c \" \"; cout \u003c\u003c endl; } int main(){ vector\u003cint\u003e v{1,2,3,4,5}; print(v); // 1 2 3 4 5 v.push_back(6); print(v); // 1 2 3 4 5 6 v.pop_back(); v.pop_back(); print(v); // 1 2 3 4 } back_inserter函数可以往容器尾端添加元素。(C++20)。 front_inserter函数可以向容器首端添加元素。(C++20)，用法同back_insert函数。 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003citerator\u003eusing namespace std; int main(){ vector\u003cint\u003e v{1,2,3,4,5}; fill_n(back_inserter(v), 3, -1); for(auto i : v) cout \u003c\u003c i \u003c\u003c \" \"; // 1,2,3,4,5,-1,-1,-1 } fill_n函数（待整理） 需要注意，如果循环体内包含有向vector对象添加元素的语句，则不能使用范围for循环。 访问vector中元素的方法和访问string中字符的方法是差不多的，包括empty，size等。 如果在for循环中对vector元素继续赋值操作，则需要将循环变量设置为引用类型。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:2:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#vector"},{"categories":["C++学习"],"content":"迭代器在迭代器中，begin成员负责返回指向第一个元素的迭代器。end则负责指向尾元素的下一个位置（尾后元素）。 begin和end的返回值类型是由对象是否是常量决定，如果对象是常量则返回const_iterator，如果对象不是常量，则返回iterator。 如果对象只需要读操作而无需写操作的话，最好使用常量类型，此时可以使用cbegin和cend函数，上述函数不论对象本身是否为常量，返回值都是const_iterator。 rbegin和rend函数，与begin、end函数用法相同，但是不同之处在于，rbegin指向最后一个元素，rend则指向首位字符的前一位置。 #include \u003ciostream\u003e#include \u003cstring\u003e#include \u003calgorithm\u003e#include \u003cstring\u003eusing namespace std; int main(){ string s(\"Exenplar!\"); *s.rbegin() = 'y'; cout \u003c\u003c s \u003c\u003c endl; // Exemplary string c; copy(s.crbegin(), s.crend(), back_inserter(c)); cout \u003c\u003c c \u003c\u003c endl; // yralpmexE } ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:3:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#迭代器"},{"categories":["C++学习"],"content":"解引用解引用迭代器可以获得迭代器所指的对象，如果该对象恰好是类，就有可能希望进一步访问他的成员。 例如，对于一个由字符串组成的vector对象来说，检查其元素是否为空，令it为迭代器，检查it所指字符串是否为空即可。需要注意，(*it)的圆括号必不可少。 (*it).empty(); //先解引用，再调用empty *it.empty(); //错误，it是个迭代器 或直接使用箭头运算符(-\u003e)，箭头运算符把解引用和成员访问两个操作结合在一起。 (*it).empty(); //判断it是否为空 it-\u003eempty(); //判断it是否为空 但凡是使用迭代器的循环体，都不要向迭代器所属容器添加元素。 string和vector的迭代器可以使用加减操作，使得迭代器每次的移动跨过多个元素。 在对两个迭代器进行运算时，参与运算的两个迭代器必须指向的是同一容器中的元素。 迭代器可用于实现二分搜索。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:3:1","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#解引用"},{"categories":["C++学习"],"content":"数组数组也是存放类型相同的对象的容器，与vector类似，但与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。 如果不清楚元素的确切数量，则使用vector 数组在定义时需指定类型，不允许使用auto关键字推断。 不能将数组的内容拷贝给其他数组做初始值。 int *ptrs[10]; //ptrs是含有10个整形指针的数组 int (*Parray)[10] = \u0026arr; //Parray指向一个含有10个整数的数组 int (\u0026arrRef)[10] = arr; //arrRef引用一个含有10个整数的数组 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:0","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#数组"},{"categories":["C++学习"],"content":"指针和数组 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针。 int ia[] = {0,1,2}; auto ia2(ia); //ia2是一个指针，指向ia的第一个元素 指向数组的指针可以当作迭代器进行使用，但是尾后元素需要自行获取。 int arr[] = {0,1,2,3,4}; int *p = arr; //p指向arr第一个元素 int *e = arr[5]; //e指向arr尾元素的下一位置 C++11引入名为begin和end的函数用于获取数组首元素和尾后元素,这两个函数定义在iterator头文件中。 int arr[] = {0,1,2,3,4}; int *p = begin(arr); //p指向arr第一个元素 int *e = end(arr); //e指向arr尾元素的下一位置 指针运算和迭代器运算类似。 假如结果指针指向了一个元素，则允许解引用该结果指针。 int arr[] = {0,2,4,6,8}; int last = *(ar + 4); //last值为8 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:1","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#指针和数组"},{"categories":["C++学习"],"content":"多维数组多维数组就是数组的数组。 C++11中新增or语句对多维数组进行处理。 int ia[3][4]; size_t cnt = 0; for(auto \u0026row : ia) //对于外层数组的每一个元素 for(auto \u0026col : row){ //对于内层数组的每一个元素 col = cnt; cnt++; } 在遍历多维数组时，要将外围for循环的循环变量设置为引用型，这样是为了避免数组被自动转换为指针。 ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:2","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#多维数组"},{"categories":["C++学习"],"content":"指针和多维数组 int ia[3][4]; for(auto p = begin(ia); p != end(ia); p++){ //q指向内层元素的首元素 for(auto q = begin(*p); q != end(*q); q++) cout \u003c\u003c *q; //输出q所指的值 } ","date":"03-19","objectID":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/:4:3","series":["C++ Primer"],"tags":["string","vector","迭代器","数组"],"title":"C++学习之string、vector、迭代器和数组","uri":"/2022/c-%E5%AD%A6%E4%B9%A0%E4%B9%8Bstringvector%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%95%B0%E7%BB%84/#指针和多维数组"},{"categories":null,"content":"友情链接 感谢大佬在博客搭建过程中提供的帮助，以及耐心的解答。 大佬的博客：https://blog.ginshio.org/ ","date":"01-01","objectID":"/link/:1:0","series":null,"tags":null,"title":"友链","uri":"/link/#友情链接"},{"categories":null,"content":"个人信息 名称：煜江叔叔 简介：这个人很懒，什么都没有留下 地址：https://treamn.github.io/ 头像：https://treamn.github.io/avatar.jpg ","date":"01-01","objectID":"/link/:2:0","series":null,"tags":null,"title":"友链","uri":"/link/#个人信息"}]